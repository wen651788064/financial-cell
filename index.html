<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title><%= htmlWebpackPlugin.options.title %></title>
</head>
<body onload="load()">
<script>
    (function(){
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( this.Data.Stack === undefined ) this.Data.Stack = undefined;
        with ( function(){
            with ( Data ) {

                return function () {
                    var VERSION = '0.0.0';
                    var NAMESPACE;

                    /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Data.Stack module.
 *
 * The Initial Developer of the Original Code is
 * Daisuke Maki.
 * Portions created by the Initial Developer are Copyright (C) 2006
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */



                    NAMESPACE = 'Data';




                    function Stack ( )
                    {
                        this.length = 0;
                    }

                    var proto = Stack.prototype;

                    proto.pop  = Array.prototype.pop;
                    proto.push = Array.prototype.push;

                    proto.peek = function ( )
                    {
                        return this.length > 0
                            ?  this[this.length-1]
                            :  undefined;
                    };

                    proto.isEmpty = function ( )
                    {
                        return this.length == 0;
                    };

                    return {
                        Stack: Stack
                    };
                }();
            }
        }.call(null) ) {
            this.Data.Stack = Stack;
        }
    }).call(null);
    (function(){
        with ( function(){

            return function () {
                var VERSION = '0.1.0';
                var NAMESPACE;





                Function.prototype.bind = function ( o ) {
                    var f = this;
                    return function ( ) {
                        return f.apply(o, arguments);
                    };
                };

                return {

                };
            }();
        }.call(null) ) {
        }
    }).call(null);
    (function(){
        if ( !this.WebBrowser || (typeof this.WebBrowser != 'object' && typeof this.WebBrowser != 'function') ) this.WebBrowser = new Object();
        if ( !this.WebBrowser.GUI || (typeof this.WebBrowser.GUI != 'object' && typeof this.WebBrowser.GUI != 'function') ) this.WebBrowser.GUI = new Object();
        if ( !this.WebBrowser.GUI.Event || (typeof this.WebBrowser.GUI.Event != 'object' && typeof this.WebBrowser.GUI.Event != 'function') ) this.WebBrowser.GUI.Event = new Object();
        if ( this.WebBrowser.GUI.Event.attach === undefined ) this.WebBrowser.GUI.Event.attach = undefined;
        if ( this.WebBrowser.GUI.Event.detach === undefined ) this.WebBrowser.GUI.Event.detach = undefined;
        with ( function(){
            with ( WebBrowser.GUI.Event ) {

                return function () {
                    var VERSION = '0.0.0';
                    var NAMESPACE;



                    NAMESPACE = 'WebBrowser.GUI.Event';




                    var listener_id = 0;
                    var registry = {};

                    attach(window, "unload", function(){
                        for ( var i in registry ) detach(Number(i));
                    });




                    function attach ( element, type, listener, useCapture ) {
                        if ( !element || typeof element !== "object" ) {
                            throw new TypeError("argument not a element: " + element);
                        }
                        type = String(type);
                        if ( typeof listener !== "function" ) {
                            throw new TypeError("argument not a function: " + listener);
                        }
                        useCapture = Boolean(useCapture);

                        function handler ( e ) {
                            e = e || window.event;
                            if ( !e.stopPropagation ) { // Sets standard properties for IE
                                e.target        = e.srcElement;
                                e.currentTarget = this;
                                e.cancelable    = true;
                                e.stopPropagation = function stopPropagation ( ) {
                                    this.cancelBubble = true;
                                };
                                var prevent_default = false;
                                e.preventDefault = function preventDefault ( ) {
                                    prevent_default = true;
                                };
                            }
                            var ret_val = listener.call(this, e);
                            return prevent_default ? false : ret_val;
                        }

                        if ( element.addEventListener ) {
                            element.addEventListener(type, handler, useCapture);
                        } else if ( element.attachEvent ) {
                            element.attachEvent("on"+type, handler);
                        } else {
                            element["on"+type] = handler;
                        }

                        var id = listener_id++;
                        registry[id] = {
                            element   : element,
                            type      : type,
                            listener  : listener,
                            useCapture: useCapture,
                            handler   : handler
                        };
                        return id;
                    }



                    function detach ( element, type, listener, useCapture ) {
                        if ( arguments.length === 1 && typeof element === "number" ) {
                            if ( !registry[element] ) return false;
                            var reg    = registry[element];
                            delete registry[element];
                            return detach_aux(reg.element, reg.type, reg.handler, reg.useCapture);
                        } else {
                            if ( !element || typeof element !== "object" ) {
                                throw new TypeError("argument is not an element: " + element);
                            }
                            type = String(type);
                            if ( typeof listener !== "function" ) {
                                throw new TypeError("argument is not s function: " + listener);
                            }
                            useCapture = Boolean(useCapture);
                            var ret_val = false;
                            for ( var i in registry ) {
                                var reg = registry[i];
                                if ( reg.element    === element
                                    && reg.type       === type
                                    && reg.listener   === listener
                                    && reg.useCapture === useCapture )
                                {
                                    delete registry[i];
                                    ret_val = detach_aux(reg.element, reg.type, reg.handler, reg.useCapture) || ret_val;
                                }
                            }
                            return ret_val;
                        }
                    };

                    function detach_aux ( element, type, listener, useCapture ) {
                        return  element.removeEventListener  ?  element.removeEventListener(type, listener, useCapture)  :
                            element.detachEvent          ?  element.detachEvent("on"+type, listener)                 :
                                delete element["on"+type]                                ;
                    }

                    return {
                        detach: detach, attach: attach
                    };
                }();
            }
        }.call(null) ) {
            this.WebBrowser.GUI.Event.detach = detach;
            this.WebBrowser.GUI.Event.attach = attach;
        }
    }).call(null);

    (function(){
        this.GLOBAL = this;
    }).call(null);
    (function(){
        if ( !this.Math || (typeof this.Math != 'object' && typeof this.Math != 'function') ) this.Math = new Object();
        if ( this.Math.ToInteger === undefined ) this.Math.ToInteger = undefined;
        if ( this.Math.ToInt32 === undefined ) this.Math.ToInt32 = undefined;
        if ( this.Math.ToUInt32 === undefined ) this.Math.ToUInt32 = undefined;
        if ( this.Math.ToUInt16 === undefined ) this.Math.ToUInt16 = undefined;
        with ( function(){
            with ( Math ) {

                return function () {
                    var VERSION = '0.0.0';
                    var NAMESPACE;

                    /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Math.ToInteger module.
 *
 * The Initial Developer of the Original Code is
 * Daisuke Maki.
 * Portions created by the Initial Developer are Copyright (C) 2006
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */



                    NAMESPACE = 'Math';



// This module provides functions emulating the integral type
// conversions defined in ECMA-262 3rd.



                    function ToInteger ( n ) {
                        return n < 0 ? ceil(n)
                            : floor(n) || 0;
                    }



                    function ToInt32 ( n ) {
                        return n | 0;
                    }



                    function ToUInt32 ( n ) {
                        return n >>> 0;
                    }



                    function ToUInt16 ( n ) {
                        return n & 0xFFFF;
                    }


                    return {
                        ToUInt16: ToUInt16, ToUInt32: ToUInt32, ToInt32: ToInt32, ToInteger: ToInteger
                    };
                }();
            }
        }.call(null) ) {
            this.Math.ToUInt16 = ToUInt16;
            this.Math.ToUInt32 = ToUInt32;
            this.Math.ToInt32 = ToInt32;
            this.Math.ToInteger = ToInteger;
        }
    }).call(null);
    (function(){
        if ( !this.WebBrowser || (typeof this.WebBrowser != 'object' && typeof this.WebBrowser != 'function') ) this.WebBrowser = new Object();
        if ( !this.WebBrowser.ScriptExecuter || (typeof this.WebBrowser.ScriptExecuter != 'object' && typeof this.WebBrowser.ScriptExecuter != 'function') ) this.WebBrowser.ScriptExecuter = new Object();
        if ( this.WebBrowser.ScriptExecuter.register === undefined ) this.WebBrowser.ScriptExecuter.register = undefined;
        if ( this.WebBrowser.ScriptExecuter.exec === undefined ) this.WebBrowser.ScriptExecuter.exec = undefined;
        with ( function(){
            with ( WebBrowser.ScriptExecuter ) {

                return function () {
                    var VERSION ;
                    var NAMESPACE;


                    NAMESPACE = 'WebBrowser.ScriptExecuter';



                    var executers    = {};
                    var default_type = "text/javascript";



                    function register ( type, exec ) {
                        if ( typeof exec != "function" ) throw new TypeError("function required, but got: " + exec);
                        executers[String(type).toLowerCase()] = exec;
                    }



                    function exec ( ) {
                        var metas = document.getElementsByTagName("META");
                        for ( var i=0;  i < metas.length;  i++ ) {
                            if ( String(metas[i].httpEquiv).match(/^Content-Script-Type$/i) ) {
                                default_type = metas[i].content;
                            }
                        }
                        var scripts = document.getElementsByTagName("SCRIPT");
                        for ( var i=0;  i < scripts.length;  i++ ) {
                            (function( el ){
                                setTimeout(function(){ exec_aux(el); }, 0);
                            })(scripts[i]);
                        }
                    }


                    function exec_aux ( el ) {
                        var mime = parseMIMEType(el.type ? el.type : default_type);
                        if ( executers[mime.type] ) {
                            if ( el.src ) {
                                var req = createXHR();
                                req.open("GET", el.src, true);
                                req.onreadystatechange = function ( ) {
                                    if ( req.readyState == 4 ) rest(req.responseText);
                                };
                                req.send(null);
                            } else {
                                rest(el.innerHTML);
                            }
                        }
                        function rest ( source ) {
                            el.parentNode.removeChild(el);
                            executers[mime.type](source, mime.attr);
                        }
                    }


                    function createXHR ( ) {
                        try {
                            return new XMLHttpRequest();
                        } catch (_){
                            try {
                                return new ActiveXObject("Msxml2.XMLHTTP");
                            } catch (_){
                                return new ActiveXObject("Microsoft.XMLHTTP");
                            }
                        }
                    }


                    var NOT_TSPECIAL  = '[^][()<>@,;:\\\\"/?=\\x00-\\x20]';
                    var TOKEN         = "(?:" + NOT_TSPECIAL + "+)";
                    var MIME_TYPE     = "(?:" + TOKEN + "/" + TOKEN + ")";
                    var QUOTED_STRING = '(?:"[^"]*(?:\\\\.[^"]*)*")';
                    var VALUE         = "(?:" + TOKEN + "|" + QUOTED_STRING + ")";

                    function parseMIMEType ( text ) {
                        text = String(text);
                        var re = new RegExp("^" + MIME_TYPE, "g");
                        re.lastIndex = 0;
                        var result = re.exec(text);
                        if ( !result ) return {type:text.toLowerCase(), attr:{}};
                        var type = result[0].toLowerCase();
                        var attr = {};
                        text = text.substring(re.lastIndex);
                        re = new RegExp("^\\s*;\\s*(" + TOKEN + ")\\s*=\\s*(" + VALUE + ")", "g");
                        re.lastIndex = 0;
                        while ( result = re.exec(text) ) {
                            attr[result[1].toLowerCase()] = result[2];
                            text = text.substring(re.lastIndex);
                            re.lastIndex = 0;
                        }
                        return {type:type, attr:attr};
                    }


                    if ( window.addEventListener ) {
                        window.addEventListener("load", exec, false);
                    } else if ( window.attachEvent ) {
                        window.attachEvent("onload", exec);
                    } else {
                        if ( window.onload ) {
                            var temp = window.onload;
                            window.onload = function ( ) {
                                var r = temp.apply(this, arguments);
                                exec();
                                return r;
                            };
                        } else {
                            window.onload = exec;
                        }
                    }

                    return {
                        register: register, exec: exec
                    };
                }();
            }
        }.call(null) ) {
            this.WebBrowser.ScriptExecuter.register = register;
            this.WebBrowser.ScriptExecuter.exec = exec;
        }
    }).call(null);
    (function(){
        if ( !this.JSON || (typeof this.JSON != 'object' && typeof this.JSON != 'function') ) this.JSON = new Object();
        if ( this.JSON.dump === undefined ) this.JSON.dump = undefined;
        with ( function(){
            with ( JSON ) {

                return function () {
                    var VERSION = '0.0.0';
                    var NAMESPACE;


                    NAMESPACE = 'JSON';




                    var DUMPER = "JSON.dumper";



                    function dump ( data, opts ) {
                        opts = opts || {};
                        var indent = String(opts.indent);
                        if ( !indent.match(/^\s*$/) ) indent = "  ";
                        return dump_main(data, {pretty:opts.pretty, indent:indent, deflate:opts.deflate});
                    }


                    function dump_main ( data, opts ) {
                        switch ( typeof data ) {
                            case "undefined":
                                return opts.deflate ? '(void 0)' : '"undefined"';

                            case "boolean":
                            case "number":
                                return String(data);

                            case "string":
                                return dump_string(data);

                            case "function":
                            case "object":
                                if ( data === null ) {
                                    return "null";
                                } else if ( typeof data[DUMPER] == "function" ){
                                    return data[DUMPER](opts);
                                } else if ( data instanceof Array ) {
                                    var arr = [];
                                    for ( var i=0;  i < data.length;  i++ ) arr[i] = dump_main(data[i], opts);
                                    if ( opts.pretty ) {
                                        return "[\n" + arr.join(",\n").replace(/^/mg, opts.indent) + "\n]";
                                    } else {
                                        return "[" + arr.join(",") + "]";
                                    }
                                } else {
                                    var arr = [];
                                    for ( var i in data ) {
                                        if ( data.hasOwnProperty(i) ) {
                                            arr.push(dump_string(i) + ":" + dump_main(data[i], opts));
                                        }
                                    }
                                    if ( opts.pretty ) {
                                        return "{\n" + arr.join(",\n").replace(/^/mg, opts.indent) + "\n}";
                                    } else {
                                        return "{" + arr.join(",") + "}";
                                    }
                                }
                        }
                    }


                    function dump_string ( str ) {
                        return '"' + str.replace(/[^\u0020-\u0021\u0023-\u005B\u005D-\u007E]/g, function (c){
                            // any ASCII character except '"', '\' and control-character
                            c = c.charCodeAt(0);
                            switch ( c ) {
                                case '"' : return '\\"';
                                case '\\': return '\\\\';
                                case '\b': return '\\b';
                                case '\f': return '\\f';
                                case '\n': return '\\n';
                                case '\r': return '\\r';
                                case '\t': return '\\t';
                                default:
                                    c = c.toString(16);
                                    while ( c.length < 4 ) c = "0" + c;
                                    return "\\u" + c;
                            }
                        }) + '"';
                    }



                    String.prototype[DUMPER] = function ( opts ) {
                        return opts.deflate ? "new String(" + dump_string(this.toString()) + ")"
                            : dump_string(this.toString());
                    };

                    Boolean.prototype[DUMPER] = function ( opts ) {
                        return opts.deflate ? "new Boolean(" + this.toString() + ")"
                            : this.toString();
                    };

                    Number.prototype[DUMPER] = function ( opts ) {
                        return opts.deflate ? "new Number(" + this.toString() + ")"
                            : this.toString();
                    };

                    Date.prototype[DUMPER] = function ( opts ) {
                        return opts.deflate ? "new Date(" + this.valueOf() + ")"
                            : dump_string(this.toString());
                    };

                    RegExp.prototype[DUMPER] = function ( opts ) {
                        return opts.deflate ? this.toString()
                            : dump_string(this.toString());
                    };

                    Function.prototype[DUMPER] = function ( opts ) {
                        return opts.deflate ? this.toString()
                            : dump_string(this.toString());
                    };



                    return {
                        dump: dump
                    };
                }();
            }
        }.call(null) ) {
            this.JSON.dump = dump;
        }
    }).call(null);
    (function(){
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Cons || (typeof this.Data.Cons != 'object' && typeof this.Data.Cons != 'function') ) this.Data.Cons = new Object();
        if ( this.Data.Cons.Cell === undefined ) this.Data.Cons.Cell = undefined;
        if ( this.Data.Cons.Nil === undefined ) this.Data.Cons.Nil = undefined;
        if ( this.Data.Cons.nil === undefined ) this.Data.Cons.nil = undefined;
        if ( this.Data.Cons.cons === undefined ) this.Data.Cons.cons = undefined;
        if ( this.Data.Cons.car === undefined ) this.Data.Cons.car = undefined;
        if ( this.Data.Cons.cdr === undefined ) this.Data.Cons.cdr = undefined;
        with ( function(){
            with ( Data.Cons ) {

                return function () {
                    var VERSION = '0.2.0';
                    var NAMESPACE;

                    /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Data.Cons code.
 *
 * The Initial Developer of the Original Code is
 * Daisuke Maki.
 * Portions created by the Initial Developer are Copyright (C) 2006-2007
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */



                    NAMESPACE = 'Data.Cons';





                    function Cell ( car, cdr ) {
                        this.car = car;
                        this.cdr = cdr;
                    }

                    var proto = Cell.prototype;

                    proto.toString = function ( ) {
                        return "(" + this.car + " . " + this.cdr + ")";
                    };

                    proto.toLocaleString = function ( ) {
                        return "("
                            + (this.car == null ? String(this.car) : this.car.toLocaleString)
                            + " . "
                            + (this.cdr == null ? String(this.cdr) : this.cdr.toLocaleString)
                            + ")";
                    };

                    proto.isNil = function ( ) {
                        return false;
                    };




                    function Nil ( ) {
                        this.car = this;
                        this.cdr = this;
                    }

                    var proto = Nil.prototype = new Cell();
                    proto.constructor = Nil;

                    proto.toString       =
                        proto.toLocaleString = function ( ) {
                            return "nil";
                        };

                    proto.isNil = function ( ) {
                        return true;
                    };




                    function nil ( ) {
                        return new Nil();
                    };



                    function cons ( car, cdr ) {
                        return new Cell(car, cdr);
                    }



                    function car ( cell ) {
                        return cell.car;
                    }



                    function cdr ( cell ) {
                        return cell.cdr;
                    }


                    return {
                        nil: nil, Nil: Nil, car: car, Cell: Cell, cdr: cdr, cons: cons
                    };
                }();
            }
        }.call(null) ) {
            this.Data.Cons.nil = nil;
            this.Data.Cons.Nil = Nil;
            this.Data.Cons.car = car;
            this.Data.Cons.Cell = Cell;
            this.Data.Cons.cdr = cdr;
            this.Data.Cons.cons = cons;
        }
    }).call(null);
    (function(){
        if ( !this.Util || (typeof this.Util != 'object' && typeof this.Util != 'function') ) this.Util = new Object();
        if ( !this.Util.Arrayize || (typeof this.Util.Arrayize != 'object' && typeof this.Util.Arrayize != 'function') ) this.Util.Arrayize = new Object();
        if ( this.Util.Arrayize.arrayize === undefined ) this.Util.Arrayize.arrayize = undefined;
        with ( function(){
            with ( Util.Arrayize ) {

                return function () {
                    var VERSION = '0.0.0';
                    var NAMESPACE;



                    NAMESPACE = 'Util.Arrayize';




                    var slice = Array.prototype.slice;


                    function arrayize ( o ) {
                        if ( !o ) return [];
                        try {
                            return slice.call(o, 0);
                        } catch ( e ) {
                            var r = [];
                            for ( var i=0;  i < o.length;  i++ ) {
                                r[i] = o[i];
                            }
                            return r;
                        }
                    }


                    return {
                        arrayize: arrayize
                    };
                }();
            }
        }.call(null) ) {
            this.Util.Arrayize.arrayize = arrayize;
        }
    }).call(null);
    (function(){
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Functional || (typeof this.Data.Functional != 'object' && typeof this.Data.Functional != 'function') ) this.Data.Functional = new Object();
        if ( !this.Data.Functional.Loop || (typeof this.Data.Functional.Loop != 'object' && typeof this.Data.Functional.Loop != 'function') ) this.Data.Functional.Loop = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Functional || (typeof this.Data.Functional != 'object' && typeof this.Data.Functional != 'function') ) this.Data.Functional = new Object();
        if ( this.Data.Functional.discontinue === undefined ) this.Data.Functional.discontinue = undefined;
        if ( this.Data.Functional.DiscontinueException === undefined ) this.Data.Functional.DiscontinueException = undefined;
        if ( this.Data.Functional.ignore === undefined ) this.Data.Functional.ignore = undefined;
        if ( this.Data.Functional.IgnoreException === undefined ) this.Data.Functional.IgnoreException = undefined;
        if ( this.Data.Functional.return_list === undefined ) this.Data.Functional.return_list = undefined;
        if ( this.Data.Functional.ReturnListException === undefined ) this.Data.Functional.ReturnListException = undefined;
        if ( this.Data.Functional.Loop.EndOfLoopException === undefined ) this.Data.Functional.Loop.EndOfLoopException = undefined;
        if ( this.Data.Functional.Loop.wrap_for_forEach === undefined ) this.Data.Functional.Loop.wrap_for_forEach = undefined;
        if ( this.Data.Functional.Loop.wrap_for_fold === undefined ) this.Data.Functional.Loop.wrap_for_fold = undefined;
        if ( this.Data.Functional.Loop.wrap_for_map === undefined ) this.Data.Functional.Loop.wrap_for_map = undefined;
        with ( function(){
            with ( Data.Functional.Loop ) {
                with ( Data.Functional ) {

                    return function () {
                        var VERSION = '0.5.0';
                        var NAMESPACE;

                        /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Data.Functional code.
 *
 * The Initial Developer of the Original Code is
 * Daisuke Maki.
 * Portions created by the Initial Developer are Copyright (C) 2005-2007
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */






                        NAMESPACE = 'Data.Functional';



                        function discontinue ( /* variable arguments */ ) {
                            throw new DiscontinueException(arguments);
                        }


                        function DiscontinueException ( args ) {
                            this.args = args;
                        }
                        var proto = DiscontinueException.prototype;
                        proto.name    = NAMESPACE + ".DiscontinueException";
                        proto.message = "unusual use of `discontinue' (this should be caught by `forEach' or other iteration-methods).";



                        function ignore ( /* variable arguments */ ) {
                            throw new IgnoreException(arguments);
                        }


                        function IgnoreException ( args ) {
                            this.args = args;
                        }
                        var proto = IgnoreException.prototype;
                        proto.name    = NAMESPACE + ".IgnoreException";
                        proto.message = "unusual use of `ignore' (this should be caught by `forEach' or other iteration-methods).";



                        function return_list ( /* variable arguments */ ) {
                            throw new ReturnListException(arguments);
                        }


                        function ReturnListException ( args ) {
                            this.args = args;
                        }
                        var proto = ReturnListException.prototype;
                        proto.name    = NAMESPACE + ".ReturnListException";
                        proto.message = "unusual use of `return_list' (this should be caught by `forEach' or other iteration-methods).";



                        NAMESPACE = 'Data.Functional.Loop';



                        function EndOfLoopException ( v ) {
                            this.result = v;
                        }
                        var proto = EndOfLoopException.prototype;
                        proto.name    = NAMESPACE + ".EndOfLoopException";
                        proto.message = "this should be caught by `forEach' or other iteration-methods";



                        function wrap_for_forEach ( t, f ) {
                            if ( typeof f != "function" ) throw new TypeError("argument to forEach must be function");
                            return function ( v ) {
                                try {
                                    f.call(t, v);
                                } catch ( e ) {
                                    if ( e instanceof DiscontinueException ) {
                                        throw new EndOfLoopException();
                                    } else if ( e instanceof IgnoreException ) {
                                        // Do nothing.
                                    } else if ( e instanceof ReturnListException ) {
                                        // Do nothing.
                                    } else {
                                        throw e;
                                    }
                                }
                            };
                        }



                        function wrap_for_fold ( t, f, s ) {
                            if ( typeof f != "function" ) throw new TypeError("argument to fold must be function");
                            return function ( v ) {
                                try {
                                    return s = f.call(t, s, v);
                                } catch ( e ) {
                                    if ( e instanceof DiscontinueException ) {
                                        throw new EndOfLoopException(e.args[e.args.length-1]);
                                    } else if ( e instanceof IgnoreException ) {
                                        return s;
                                    } else if ( e instanceof ReturnListException ) {
                                        return s = f.call(t, s, e.args[e.args.length-1]);
                                    } else {
                                        throw e;
                                    }
                                }
                            };
                        }



                        function wrap_for_map ( t, f, a ) {
                            if ( typeof f != "function" ) throw new TypeError("argument to map must be function");
                            if ( typeof a != "function" ) throw new TypeError("the third argument to wrap_for_map must be function");
                            return function ( v ) {
                                try {
                                    a.call(null, f.call(t, v));
                                } catch ( e ) {
                                    if ( e instanceof DiscontinueException ) {
                                        a.apply(null, e.args);
                                        throw new EndOfLoopException();
                                    } else if ( e instanceof IgnoreException ) {
                                        // Do nothing.
                                    } else if ( e instanceof ReturnListException ) {
                                        a.apply(null, e.args);
                                    } else {
                                        throw e;
                                    }
                                }
                            };
                        }

                        return {
                            DiscontinueException: DiscontinueException, wrap_for_forEach: wrap_for_forEach, wrap_for_map: wrap_for_map, ignore: ignore, discontinue: discontinue, ReturnListException: ReturnListException, wrap_for_fold: wrap_for_fold, return_list: return_list, IgnoreException: IgnoreException, EndOfLoopException: EndOfLoopException
                        };
                    }();
                }
            }
        }.call(null) ) {
            this.Data.Functional.DiscontinueException = DiscontinueException;
            this.Data.Functional.Loop.wrap_for_forEach = wrap_for_forEach;
            this.Data.Functional.Loop.wrap_for_map = wrap_for_map;
            this.Data.Functional.ignore = ignore;
            this.Data.Functional.discontinue = discontinue;
            this.Data.Functional.ReturnListException = ReturnListException;
            this.Data.Functional.Loop.wrap_for_fold = wrap_for_fold;
            this.Data.Functional.return_list = return_list;
            this.Data.Functional.IgnoreException = IgnoreException;
            this.Data.Functional.Loop.EndOfLoopException = EndOfLoopException;
        }
    }).call(null);
    (function(){
        if ( !this.Util || (typeof this.Util != 'object' && typeof this.Util != 'function') ) this.Util = new Object();
        if ( !this.Util.Arrayize || (typeof this.Util.Arrayize != 'object' && typeof this.Util.Arrayize != 'function') ) this.Util.Arrayize = new Object();
        with ( function(){
            with ( Util.Arrayize ) {

                return function () {
                    var VERSION = '0.0.0';
                    var NAMESPACE;










                    var null_constructor = function (){};

                    Function.prototype.extend = function extend ( init, props ) {
                        if ( typeof init !== "function" ) throw new TypeError("function is expected: " + init);
                        if ( props == null ) props = {};

                        var SuperClass = this;
                        var SubClass = function ( ) {
                            var self = this;
                            var super_is_called = false;
                            function super_call ( ) {
                                if ( super_is_called ) throw new Error("super-constructor has already been called");
                                super_is_called = true;
                                var ret_val = SuperClass.apply(self, arguments);
                                if ( ret_val instanceof Object ) {
                                    for ( var i in ret_val ) {
                                        if ( ret_val.hasOwnProperty(i) ) self[i] = ret_val[i];
                                    }
                                }
                                return ret_val;
                            }
                            arguments = arrayize(arguments);
                            arguments.unshift(super_call);
                            return init.apply(self, arguments);
                        };

                        null_constructor.prototype = SuperClass.prototype;
                        var proto = SubClass.prototype = new null_constructor;
                        proto.constructor = SubClass;
                        proto.$super = function ( prop ) {
                            if ( !arguments.length ) return SuperClass;
                            var value = SuperClass.prototype[prop];
                            if ( typeof value === "function" ) {
                                return value.bind(this);
                            } else {
                                return value;
                            }
                        };
                        for ( var i in props ) proto[i] = props[i];

                        return SubClass;
                    };


                    return {

                    };
                }();
            }
        }.call(null) ) {
        }
    }).call(null);
    (function(){
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Error || (typeof this.Data.Error != 'object' && typeof this.Data.Error != 'function') ) this.Data.Error = new Object();
        if ( this.Data.Error.Error === undefined ) this.Data.Error.Error = undefined;
        if ( this.Data.Error.Exception === undefined ) this.Data.Error.Exception = undefined;
        with ( function(){
            with ( Data.Error ) {

                return function () {
                    var VERSION = '0.3.0';
                    var NAMESPACE;

                    /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Data.Error module.
 *
 * The Initial Developer of the Original Code is
 * Daisuke Maki.
 * Portions created by the Initial Developer are Copyright (C) 2005-2006
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */


                    NAMESPACE = 'Data.Error';








                    var Error = GLOBAL.Error.extend(
                        function ( $super, message ) {
                            $super(message);
                        },
                        {
                            name    : NAMESPACE + ".Error",
                            message : "something's wrong",
                            toString: function ( ) {
                                var s = String(this.message);
                                s = s  ?  this.name + ": " + s
                                    :  this.name;
                                if ( this.fileName ) {
                                    s += " @" + this.fileName + ":" + this.lineNumber;
                                }
                                return s;
                            }
                        }
                    );



                    var Exception = GLOBAL.Error.extend(
                        function ( $super, message ) {
                            $super(message);
                        },
                        {
                            name    : NAMESPACE + ".Exception",
                            message : "an exception has occurred",
                            toString: function ( ) {
                                var s = String(this.message);
                                s = s  ?  this.name + ": " + s
                                    :  this.name;
                                if ( this.fileName ) {
                                    s += " @" + this.fileName + ":" + this.lineNumber;
                                }
                                return s;
                            }
                        }
                    );


                    return {
                        Error: Error, Exception: Exception
                    };
                }();
            }
        }.call(null) ) {
            this.Data.Error.Error = Error;
            this.Data.Error.Exception = Exception;
        }
    }).call(null);
    (function(){
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Error || (typeof this.Data.Error != 'object' && typeof this.Data.Error != 'function') ) this.Data.Error = new Object();
        if ( this.Data.Error.IllegalStateError === undefined ) this.Data.Error.IllegalStateError = undefined;
        with ( function(){
            with ( Data.Error ) {

                return function () {
                    var VERSION = '0.0.0';
                    var NAMESPACE;

                    /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Data.Error.IllegalStateError module.
 *
 * The Initial Developer of the Original Code is
 * Daisuke Maki.
 * Portions created by the Initial Developer are Copyright (C) 2006
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */




                    NAMESPACE = 'Data.Error';





                    var IllegalStateError = Error.extend(
                        function ( $super, message ) { $super(message); },
                        {
                            name   : NAMESPACE + ".IllegalStateError",
                            message: "illegal state"
                        }
                    );


                    return {
                        IllegalStateError: IllegalStateError
                    };
                }();
            }
        }.call(null) ) {
            this.Data.Error.IllegalStateError = IllegalStateError;
        }
    }).call(null);
    (function(){
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Error || (typeof this.Data.Error != 'object' && typeof this.Data.Error != 'function') ) this.Data.Error = new Object();
        if ( this.Data.Error.UnimplementedMethodError === undefined ) this.Data.Error.UnimplementedMethodError = undefined;
        with ( function(){
            with ( Data.Error ) {

                return function () {
                    var VERSION = '0.3.0';
                    var NAMESPACE;

                    /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Data.Error.UnimplementedMethodError.
 *
 * The Initial Developer of the Original Code is
 * Daisuke Maki.
 * Portions created by the Initial Developer are Copyright (C) 2005-2006
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */


                    NAMESPACE = 'Data.Error';







                    var UnimplementedMethodError = Error.extend(
                        function ( $super, method, invocant, message ) {
                            if ( message !== undefined ) {
                                $super(message);
                            } else {
                                $super("an required method `" + method + "' has not been implemented");
                            }
                            this.method   = method;
                            this.invocant = invocant;
                        },
                        { name: NAMESPACE + ".UnimplementedMethodError" }
                    );


                    return {
                        UnimplementedMethodError: UnimplementedMethodError
                    };
                }();
            }
        }.call(null) ) {
            this.Data.Error.UnimplementedMethodError = UnimplementedMethodError;
        }
    }).call(null);
    (function(){
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Error || (typeof this.Data.Error != 'object' && typeof this.Data.Error != 'function') ) this.Data.Error = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Iterator || (typeof this.Data.Iterator != 'object' && typeof this.Data.Iterator != 'function') ) this.Data.Iterator = new Object();
        if ( this.Data.Iterator.NoSuchElementError === undefined ) this.Data.Iterator.NoSuchElementError = undefined;
        with ( function(){
            with ( Data.Error ) {
                with ( Data.Iterator ) {

                    return function () {
                        var VERSION = '0.2.0';
                        var NAMESPACE;

                        /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Data.Iterator code.
 *
 * The Initial Developer of the Original Code is
 * Daisuke Maki.
 * Portions created by the Initial Developer are Copyright (C) 2006
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */



                        NAMESPACE = 'Data.Iterator';








                        var NoSuchElementError = Error.extend(
                            function ( $super, message ) { $super(message); },
                            {
                                name   : NAMESPACE + ".NoSuchElementError",
                                message: "no such element"
                            }
                        );


                        return {
                            NoSuchElementError: NoSuchElementError
                        };
                    }();
                }
            }
        }.call(null) ) {
            this.Data.Iterator.NoSuchElementError = NoSuchElementError;
        }
    }).call(null);
    (function(){
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Error || (typeof this.Data.Error != 'object' && typeof this.Data.Error != 'function') ) this.Data.Error = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Functional || (typeof this.Data.Functional != 'object' && typeof this.Data.Functional != 'function') ) this.Data.Functional = new Object();
        if ( !this.Data.Functional.Loop || (typeof this.Data.Functional.Loop != 'object' && typeof this.Data.Functional.Loop != 'function') ) this.Data.Functional.Loop = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Functional || (typeof this.Data.Functional != 'object' && typeof this.Data.Functional != 'function') ) this.Data.Functional = new Object();
        if ( this.Data.Functional.Enumerable === undefined ) this.Data.Functional.Enumerable = undefined;
        if ( this.Data.Functional.EmptyEnumerationError === undefined ) this.Data.Functional.EmptyEnumerationError = undefined;
        with ( function(){
            with ( Data.Error ) {
                with ( Data.Functional.Loop ) {
                    with ( Data.Functional ) {

                        return function () {
                            var VERSION = '0.5.0';
                            var NAMESPACE;

                            /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Data.Functional code.
 *
 * The Initial Developer of the Original Code is
 * Daisuke Maki.
 * Portions created by the Initial Developer are Copyright (C) 2005-2007
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */



                            NAMESPACE = 'Data.Functional';












                            function Enumerable ( ) {
                                // This is a kind of abstract class.
                            }

                            var proto = Enumerable.prototype;

                            var obj_name = "[object " + NAMESPACE + ".Enumerable]";


                            proto.toString = function ( ) {
                                return obj_name;
                            };


                            proto.iterator = function ( ) {
                                throw new UnimplementedMethodError("iterator", this);
                            };


                            proto.forEach = function ( f ) {
                                var ret_val;
                                f = wrap_for_forEach(this, f);
                                for ( var it=this.iterator();  !it.isTail();  it=it.next() ) {
                                    try {
                                        f(it.value());
                                    } catch ( e ) {
                                        if ( e instanceof EndOfLoopException ) return;
                                        else                                   throw e;
                                    }
                                }
                            };


                            proto.fold = function ( f, s ) {
                                f = wrap_for_fold(this, f, s);
                                for ( var it=this.iterator();  !it.isTail();  it=it.next() ) {
                                    try {
                                        s = f(it.value());
                                    } catch ( e ) {
                                        if ( e instanceof EndOfLoopException ) return e.result;
                                        else                                   throw e;
                                    }
                                }
                                return s;
                            };


                            proto.fold1 = function ( f ) {
                                var it = this.iterator();
                                if ( it.isTail() ) throw new EmptyEnumerationError();
                                var s = it.value();
                                it = it.next();
                                f = wrap_for_fold(this, f, s);
                                for ( ;  !it.isTail();  it=it.next() ) {
                                    try {
                                        s = f(it.value());
                                    } catch ( e ) {
                                        if ( e instanceof EndOfLoopException ) return e.result;
                                        else                                   throw e;
                                    }
                                }
                                return s;
                            };


                            proto.and = function ( ) {
                                return this.fold(function ( x, y ) {
                                    return y || discontinue(y);
                                }, true);
                            };

                            proto.or = function ( ) {
                                return this.fold(function ( x, y ) {
                                    return y && discontinue(y);
                                }, false);
                            };

                            proto.all = function ( f ) {
                                return this.fold(function ( x, y ) {
                                    y = f.call(this, y);
                                    return y || discontinue(y);
                                }, true);
                            };

                            proto.any = function ( f ) {
                                return this.fold(function ( x, y ) {
                                    y = f.call(this, y);
                                    return y && discontinue(y);
                                }, false);
                            };




                            var EmptyEnumerationError = Error.extend(
                                function ( $super, message ) { $super(message); },
                                {
                                    name   : NAMESPACE + ".EmptyEnumerationError",
                                    message: "empty enumeration"
                                }
                            );


                            return {
                                EmptyEnumerationError: EmptyEnumerationError, Enumerable: Enumerable
                            };
                        }();
                    }
                }
            }
        }.call(null) ) {
            this.Data.Functional.EmptyEnumerationError = EmptyEnumerationError;
            this.Data.Functional.Enumerable = Enumerable;
        }
    }).call(null);
    (function(){
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Error || (typeof this.Data.Error != 'object' && typeof this.Data.Error != 'function') ) this.Data.Error = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Iterator || (typeof this.Data.Iterator != 'object' && typeof this.Data.Iterator != 'function') ) this.Data.Iterator = new Object();
        if ( this.Data.Iterator.Iterator === undefined ) this.Data.Iterator.Iterator = undefined;
        with ( function(){
            with ( Data.Error ) {
                with ( Data.Iterator ) {

                    return function () {
                        var VERSION = '0.2.1';
                        var NAMESPACE;

                        /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Data.Iterator code.
 *
 * The Initial Developer of the Original Code is
 * Daisuke Maki.
 * Portions created by the Initial Developer are Copyright (C) 2006
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */



                        NAMESPACE = 'Data.Iterator';








                        function Iterator ( ) {
                            // This is a kind of abstract class.
                            // Sub-classes should implement appropreate methods.
                        }

                        var proto = Iterator.prototype;

                        var obj_name = "[object " + NAMESPACE + ".Iterator]";


                        proto.toString = function ( ) {
                            return obj_name;
                        };


// Returns true if this iterator points to the tail of a list,
// false othersise.
// The default implementation merely throws UnimplementedMethodError.
// Sub-classes must implement their own version of this method.
                        proto.isTail = function ( ) {
                            throw new UnimplementedMethodError("isTail", this);
                        };


// Returns value of the element which is just after the position
// this iterator points to.
// The default implementation merely throws UnimplementedMethodError.
// Sub-classes must implement their own version of this method,
// which may throws Data.Iterator.NoSuchElementError.
                        proto.value = function ( ) {
                            throw new UnimplementedMethodError("value", this);
                        };


// Returns a new iterator that points to the next position to the
// one which this iterator points to.
// The default implementation merely throws UnimplementedMethodError.
// Sub-classes must implement their own version of this method,
// which may throws Data.Iterator.NoSuchElementError.
                        proto.next = function ( ) {
                            throw new UnimplementedMethodError("next", this);
                        };


// Returns true if and only if this iterator is associated with the
// object specified by the argument, false otherwise.
// The default implementation just returns false.
                        proto.isBoundTo = function ( list ) {
                            return false;
                        };


                        proto.find = function ( f ) {
                            for ( var it=this;  !it.isTail();  it=it.next() ) {
                                if ( f(it.value()) ) break;
                            }
                            return it;
                        };


                        return {
                            Iterator: Iterator
                        };
                    }();
                }
            }
        }.call(null) ) {
            this.Data.Iterator.Iterator = Iterator;
        }
    }).call(null);
    (function(){
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Error || (typeof this.Data.Error != 'object' && typeof this.Data.Error != 'function') ) this.Data.Error = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Functional || (typeof this.Data.Functional != 'object' && typeof this.Data.Functional != 'function') ) this.Data.Functional = new Object();
        if ( !this.Data.Functional.Loop || (typeof this.Data.Functional.Loop != 'object' && typeof this.Data.Functional.Loop != 'function') ) this.Data.Functional.Loop = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Functional || (typeof this.Data.Functional != 'object' && typeof this.Data.Functional != 'function') ) this.Data.Functional = new Object();
        if ( this.Data.Functional.Collection === undefined ) this.Data.Functional.Collection = undefined;
        with ( function(){
            with ( Data.Error ) {
                with ( Data.Functional.Loop ) {
                    with ( Data.Functional ) {

                        return function () {
                            var VERSION = '0.5.0';
                            var NAMESPACE;

                            /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Data.Functional code.
 *
 * The Initial Developer of the Original Code is
 * Daisuke Maki.
 * Portions created by the Initial Developer are Copyright (C) 2005-2007
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */



                            NAMESPACE = 'Data.Functional';












                            function Collection ( ) {
                                // This is kind of abstract class.
                            }

                            var proto = Collection.prototype = new Enumerable();
                            proto.constructor = Collection;

                            var obj_name = "[object " + NAMESPACE + ".Collection]";


                            proto.toString = function ( ) {
                                return obj_name;
                            };


                            proto.toArray = function ( ) {
                                var a = [];
                                this.forEach(function( it ){
                                    a.push(it);
                                });
                                return a;
                            };


                            proto.add = function ( /* variable args */ ) {
                                throw new UnimplementedMethodError("add", this);
                            };


                            proto.addAll = function ( /* variable arguments */ ) {
                                var self    = this;
                                var changed = false;
                                for ( var i=0;  i < arguments.length;  i++ ) {
                                    var c = arguments[i];
                                    if ( c instanceof Collection ) {
                                        c.forEach(function( it ){
                                            changed = self.add(it) || changed;
                                        });
                                    } else if ( c instanceof Array ) {
                                        changed = this.add.apply(this, c) || changed;
                                    } else {
                                        chagned = this.add(c) || changed;
                                    }
                                }
                                return changed;
                            };


                            proto.removeAt = function ( it ) {
                                throw new UnimplementedMethodError("removeAt", this);
                            };


                            proto.isEmpty = function ( ) {
                                return this.iterator().isTail();
                            };


                            proto.empty = function ( ) {
                                var it;
                                while ( !(it=this.iterator()).isTail() ) this.removeAt(it);
                            };


                            proto.size = function ( ) {
                                var i = 0;
                                this.forEach(function(){ ++i; });
                                return i;
                            };


                            proto.emptyCopy = function ( ) {
                                return new this.constructor();
                            };


                            proto.copy = function ( ) {
                                var c = this.emptyCopy();
                                this.forEach(function( it ){
                                    c.add(it);
                                });
                                return c;
                            };


                            proto.map = function ( f ) {
                                var c = this.emptyCopy();
                                f = wrap_for_map(this, f, function ( ) {
                                    c.add.apply(c, arguments);
                                });
                                for ( var it=this.iterator();  !it.isTail();  it=it.next() ) {
                                    try {
                                        f(it.value());
                                    } catch ( e ) {
                                        if ( e instanceof EndOfLoopException ) return c;
                                        else                                   throw e;
                                    }
                                }
                                return c;
                            };


                            proto.filter = function ( f ) {
                                return this.map(function( it ){
                                    if ( f.call(this, it) ) return it;
                                    else                    ignore();
                                });
                            };


                            proto.grep = function ( re ) {
                                if ( !(re instanceof RegExp) ) re = new Regex(re);
                                return this.filter(function(it){
                                    return String(it).match(re);
                                });
                            };



                            return {
                                Collection: Collection
                            };
                        }();
                    }
                }
            }
        }.call(null) ) {
            this.Data.Functional.Collection = Collection;
        }
    }).call(null);
    (function(){
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Error || (typeof this.Data.Error != 'object' && typeof this.Data.Error != 'function') ) this.Data.Error = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Iterator || (typeof this.Data.Iterator != 'object' && typeof this.Data.Iterator != 'function') ) this.Data.Iterator = new Object();
        if ( this.Data.Iterator.BidirectionalIterator === undefined ) this.Data.Iterator.BidirectionalIterator = undefined;
        with ( function(){
            with ( Data.Error ) {
                with ( Data.Iterator ) {

                    return function () {
                        var VERSION = '0.2.0';
                        var NAMESPACE;

                        /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Data.Iterator code.
 *
 * The Initial Developer of the Original Code is
 * Daisuke Maki.
 * Portions created by the Initial Developer are Copyright (C) 2006
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */



                        NAMESPACE = 'Data.Iterator';










                        function BidirectionalIterator ( ) {
                            // This is a kind of abstract class.
                            // Sub-classes should implement appropreate methods.
                        }

                        var proto = BidirectionalIterator.prototype = new Iterator();
                        proto.constructor = BidirectionalIterator;

                        var obj_name = "[object " + NAMESPACE + ".BidirectionalIterator]";


                        proto.toString = function ( ) {
                            return obj_name;
                        };


// Returns true if this iterator points to the head of a list,
// false othersise.
// The default implementation merely throws UnimplementedMethodError.
// Sub-classes must implement their own version of this method.
                        proto.isHead = function ( ) {
                            throw new UnimplementedMethodError("isHead", this);
                        };


// Returns a new iterator that points to the previous position to
// the one which this iterator points to.
// The default implementation merely throws UnimplementedMethodError.
// Sub-classes must implement their own version of this method.
                        proto.previous = function ( ) {
                            throw new UnimplementedMethodError("previous", this);
                        };


                        return {
                            BidirectionalIterator: BidirectionalIterator
                        };
                    }();
                }
            }
        }.call(null) ) {
            this.Data.Iterator.BidirectionalIterator = BidirectionalIterator;
        }
    }).call(null);
    (function(){
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Error || (typeof this.Data.Error != 'object' && typeof this.Data.Error != 'function') ) this.Data.Error = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Iterator || (typeof this.Data.Iterator != 'object' && typeof this.Data.Iterator != 'function') ) this.Data.Iterator = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Functional || (typeof this.Data.Functional != 'object' && typeof this.Data.Functional != 'function') ) this.Data.Functional = new Object();
        if ( this.Data.Functional.Set === undefined ) this.Data.Functional.Set = undefined;
        with ( function(){
            with ( Data.Error ) {
                with ( Data.Iterator ) {
                    with ( Data.Functional ) {

                        return function () {
                            var VERSION = '0.4.0';
                            var NAMESPACE;

                            /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Data.Functional code.
 *
 * The Initial Developer of the Original Code is
 * Daisuke Maki.
 * Portions created by the Initial Developer are Copyright (C) 2005-2007
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */



                            NAMESPACE = 'Data.Functional';














                            function Set ( ) {
                                // This is kind of interface.
                            }

                            var proto = Set.prototype = new Collection();
                            proto.constructor = Set;

                            var obj_name = "[object " + NAMESPACE + ".Set]";


                            proto.toString = function ( ) {
                                return obj_name;
                            };


                            proto.contains = function ( /* variable args */ ) {
                                throw new UnimplementedMethodError("contains", this);
                            };

                            proto.containsAll = function ( /* variable args */ ) {
                                for ( var i=0;  i < arguments.length;  i++ ) {
                                    var e = arguments[i];
                                    if ( e instanceof Array ) {
                                        if ( !this.contains.apply(this, e) ) return false;
                                    } else if ( e instanceof Collection ) {
                                        var self = this;
                                        if ( !e.all(function(it){ return self.contains(it); }) ) return false;
                                    } else {
                                        if ( !this.contains(e) ) return false;
                                    }
                                }
                                return true;
                            };


                            proto.remove = function ( /* variable args */ ) {
                                throw new UnimplementedMethodError("remove", this);
                            };

                            proto.removeAll = function ( /* variable args */ ) {
                                var changed = false;
                                for ( var i=0;  i < arguments.length;  i++ ) {
                                    var e = arguments[i];
                                    if ( e instanceof Array ) {
                                        changed = this.remove.apply(this, e) || changed;
                                    } else if ( e instanceof Collection ) {
                                        var self = this;
                                        e.forEach(function( it ){
                                            changed = self.remove(it) || changed;
                                        });
                                    } else {
                                        changed = this.remove(e) || changed;
                                    }
                                }
                                return changed;
                            };

                            proto.removeAt = function ( it ) {
                                if ( !(it instanceof Iterator) ) throw new TypeError("the argument is not of type Data.Iterator.Iterator");
                                if ( !it.isBoundTo(this)       ) throw new IllegalStateError();
                                var v = it.value();
                                this.remove(v);
                                return v;
                            };


                            proto.retainAll = function ( /* variable args */ ) {
                                var temp = this.emptyCopy();
                                temp.addAll.apply(temp, arguments);
                                return this.removeAll( this.filter(function(it){
                                    return !temp.contains(it);
                                }) );
                            };



                            return {
                                Set: Set
                            };
                        }();
                    }
                }
            }
        }.call(null) ) {
            this.Data.Functional.Set = Set;
        }
    }).call(null);
    (function(){
        if ( !this.Math || (typeof this.Math != 'object' && typeof this.Math != 'function') ) this.Math = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Functional || (typeof this.Data.Functional != 'object' && typeof this.Data.Functional != 'function') ) this.Data.Functional = new Object();
        if ( !this.Data.Functional.Loop || (typeof this.Data.Functional.Loop != 'object' && typeof this.Data.Functional.Loop != 'function') ) this.Data.Functional.Loop = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Functional || (typeof this.Data.Functional != 'object' && typeof this.Data.Functional != 'function') ) this.Data.Functional = new Object();
        if ( this.Data.Functional.List === undefined ) this.Data.Functional.List = undefined;
        with ( function(){
            with ( Math ) {
                with ( Data.Functional.Loop ) {
                    with ( Data.Functional ) {

                        return function () {
                            var VERSION = '0.5.0';
                            var NAMESPACE;

                            /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Data.Functional code.
 *
 * The Initial Developer of the Original Code is
 * Daisuke Maki.
 * Portions created by the Initial Developer are Copyright (C) 2005-2007
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

// This module should not be required directly.
// Require Data.Functional.List instead.



                            NAMESPACE = 'Data.Functional';












                            function List ( ) {
                                // This is a kind of abstract class.
                            }

                            var proto = List.prototype = new Collection();
                            proto.constructor = List;


// Iterator methods.
// Return an iterator pointing to just before the n'th element
// (the first element is the 0th one). If there are only n elements
// in this list, return an iterator pointing to the tail.
// If n is negative, it is treated as size+n, where size is the length
// of this list. Thus, if n is negative, the result of head(n) and
// the one of tail(-n) should be equivalent.
// These methods can throw RangeError.
                            proto.head = function ( n ) {
                                if ( n < 0 ) return this.tail(-n);
                                return nNextFromHead(this.tail(), n);
                            };

                            proto.tail = function ( n ) {
                                if ( n < 0 ) return this.head(-n);
                                return nPreviousFromTail(this.head(), n);
                            };

                            proto.reverseHead = function ( n ) {
                                if ( n < 0 ) return this.reverseTail(-n);
                                return nNextFromHead(this.reverseTail(), n);
                            };

                            proto.reverseTail = function ( n ) {
                                if ( n < 0 ) return this.reverseHead(-n);
                                return nPreviousFromTail(this.reverseHead(), n);
                            };

                            function nNextFromHead ( it, n ) {
                                var q = [];
                                n = ToInteger(n);
                                if ( n == 0 ) {  // simple optimization
                                    while ( !it.isHead() ) it = it.previous();
                                    return it;
                                } else {
                                    while ( n-- > 0 ) {
                                        if ( it.isHead() ) throw new RangeError();
                                        q.push(it);
                                        it = it.previous();
                                    }
                                    while ( !it.isHead() ) {
                                        q.shift();
                                        q.push(it);
                                        it = it.previous();
                                    }
                                    q.push(it);
                                    return q[0];
                                }
                            }

                            function nPreviousFromTail ( it, n ) {
                                var q = [];
                                n = ToInteger(n);
                                if ( n == 0 ) {  // simple optimization
                                    while ( !it.isTail() ) it = it.next();
                                    return it;
                                } else {
                                    while ( n-- > 0 ) {
                                        if ( it.isTail() ) throw new RangeError();
                                        q.push(it);
                                        it = it.next();
                                    }
                                    while ( !it.isTail() ) {
                                        q.shift();
                                        q.push(it);
                                        it = it.next();
                                    }
                                    q.push(it);
                                    return q[0];
                                }
                            }


                            proto.iterator = function ( /* delegate */ ) {
                                return this.head.apply(this, arguments);
                            };

                            proto.add = function ( /* variable args */ ) {
                                if ( arguments.length == 0 ) return false;
                                for ( var i=0;  i < arguments.length;  i++ ) {
                                    this.tail().insert(arguments[i]);
                                }
                                return true;
                            };


// Returns the value indexed by the argument.
// If there is no corresponding value in this list, returns undefined.
// The argument can be either number or iterator.
                            proto.get = function ( it ) {
                                if ( !(it instanceof List.Iterator  &&  it.isBoundTo(this)) ) {
                                    try {
                                        it = this.head(it);
                                    } catch ( e ) {
                                        if ( e instanceof RangeError ) {
                                            return undefined;
                                        } else {
                                            throw e;
                                        }
                                    }
                                }
                                if ( it.isTail() ) return undefined;
                                else               return it.value();
                            };

// Assigns the second argument to the container indexed by the first
// argument.
// The argument can be either number or iterator.
                            proto.set = function ( it, v ) {
                                if ( !(it instanceof List.Iterator  &&  it.isBoundTo(this)) ) {
                                    it = this.head(it);
                                }
                                return it.assign(v);
                            };

// Inserts a new container at the position indexed by the first
// argument, and sets the second argument to the container, then,
// returns the value of the container.
// The argument can be either number or iterator.
// The position which this iterator points to after insertion is
// implementation-dependent.
                            proto.insertAt = function ( it, v ) {
                                if ( !(it instanceof List.Iterator  &&  it.isBoundTo(this)) ) {
                                    it = this.head(it);
                                }
                                return it.insert(v);
                            };

// Removes the container indexed by the argument, then, returns the
// value of the container.
// The argument can be either number or iterator.
// The position which this iterator points to after removal is
// implementation-dependent.
                            proto.removeAt = function ( it ) {
                                if ( !(it instanceof List.Iterator  &&  it.isBoundTo(this)) ) {
                                    it = this.head(it);
                                }
                                return it.remove();
                            };


                            proto.pop = function ( ) {
                                return this.reverseHead().remove();
                            };

                            proto.push = function ( /* variable args */ ) {
                                this.add.apply(this, arguments);
                                return this.size();
                            };

                            proto.shift = function ( ) {
                                return this.head().remove();
                            };

                            proto.unshift = function ( /* variable args */ ) {
                                for ( var i=arguments.length-1;  i >= 0;  i-- ) {
                                    this.head().insert(arguments[i]);
                                }
                                return this.size();
                            };


                            proto.join = function ( /* delegate */ ) {
                                var arr = this.toArray();
                                return arr.join.apply(arr, arguments);
                            };

                            proto.toString = function ( /* delegate */ ) {
                                var arr = this.toArray();
                                return arr.toString.apply(arr, arguments);
                            };

                            proto.toLocaleString = function ( /* delegate */ ) {
                                var arr = this.toArray();
                                return arr.toLocaleString.apply(arr, arguments);
                            };


                            proto.reverse = function ( ) {
                                var r = this.emptyCopy();
                                for ( var it=this.reverseHead();  !it.isTail();  it=it.next() ) {
                                    r.add(it.value());
                                }
                                return r;
                            };

                            proto.slice = function ( start, end ) {
                                if ( !(    start instanceof List.Iterator
                                        &&   end instanceof List.Iterator
                                        && start.isBoundTo(this) && end.isBoundTo(this)
                                        && start.constructor === end.constructor ) )  // one might be reverse-iterator even though the other is iterator.
                                {
                                    try {
                                        start = this.head(start);
                                    } catch ( e ) {
                                        if ( e instanceof RangeError ) {
                                            start = start < 0 ? this.head() : this.tail();
                                        } else {
                                            throw e;
                                        }
                                    }
                                    if ( end === undefined ) {
                                        end = this.tail();
                                    } else {
                                        try {
                                            end = this.head(end);
                                        } catch ( e ) {
                                            if ( e instanceof RangeError ) {
                                                end = end < 0 ? this.head() : this.tail();
                                            } else {
                                                throw e;
                                            }
                                        }
                                    }
                                }
                                var l = this.emptyCopy();
                                if ( start.compareTo(end) >= 0 ) return l;
                                while ( !start.equals(end) ) {
                                    l.add(start.value());
                                    start = start.next();
                                }
                                return l;
                            };

                            proto.concat = function ( /* variable arguments */ ) {
                                var list = this.emptyCopy();
                                arguments[-1] = this;
                                for ( var i=-1;  i < arguments.length;  i++ ) {
                                    var e = arguments[i];
                                    if ( e instanceof List ) {
                                        e.forEach(function(it){
                                            list.add(it)
                                        });
                                    }
                                    else if ( e instanceof Array ) {
                                        for ( var j=0;  j < e.length;  j++ ) list.add(e[j])
                                    }
                                    else {
                                        list.add(e);
                                    }
                                }
                                return list;
                            };


                            proto.foldl = proto.fold;

                            proto.foldl1 = proto.fold1;

                            proto.foldr = function ( f, s ) {
                                var g = wrap_for_fold(this, function(x,y){return f.call(this,y,x);}, s);
                                for ( var it=this.reverseHead();  !it.isTail();  it=it.next() ) {
                                    try {
                                        s = g(it.value());
                                    } catch ( e ) {
                                        if ( e instanceof EndOfLoopException ) return e.result;
                                        else                                   throw e;
                                    }
                                }
                                return s;
                            };

                            proto.foldr1 = function ( f ) {
                                var it = this.reverseHead();
                                if ( it.isTail() ) throw new EmptyEnumerationError();
                                var s = it.value();
                                it = it.next();
                                var g = wrap_for_fold(this, function(x,y){return f.call(this,y,x);}, s);
                                for ( ;  !it.isTail();  it=it.next() ) {
                                    try {
                                        s = g(it.value());
                                    } catch ( e ) {
                                        if ( e instanceof EndOfLoopException ) return e.result;
                                        else                                   throw e;
                                    }
                                }
                                return s;
                            };


                            return {
                                List: List
                            };
                        }();
                    }
                }
            }
        }.call(null) ) {
            this.Data.Functional.List = List;
        }
    }).call(null);
    (function(){
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Error || (typeof this.Data.Error != 'object' && typeof this.Data.Error != 'function') ) this.Data.Error = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Iterator || (typeof this.Data.Iterator != 'object' && typeof this.Data.Iterator != 'function') ) this.Data.Iterator = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Functional || (typeof this.Data.Functional != 'object' && typeof this.Data.Functional != 'function') ) this.Data.Functional = new Object();
        if ( !this.Data.Functional.List || (typeof this.Data.Functional.List != 'object' && typeof this.Data.Functional.List != 'function') ) this.Data.Functional.List = new Object();
        if ( this.Data.Functional.List.Iterator === undefined ) this.Data.Functional.List.Iterator = undefined;
        with ( function(){
            with ( Data.Error ) {
                with ( Data.Iterator ) {
                    with ( Data.Functional.List ) {

                        return function () {
                            var VERSION = '0.5.0';
                            var NAMESPACE;

                            /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Data.Functional code.
 *
 * The Initial Developer of the Original Code is
 * Daisuke Maki.
 * Portions created by the Initial Developer are Copyright (C) 2005-2007
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */



                            NAMESPACE = 'Data.Functional.List';













                            function Iterator ( ) {
                                // This is a kind of abstract class.
                            }

                            var proto = Iterator.prototype = new BidirectionalIterator();
                            proto.constructor = Iterator;

                            var obj_name = "[object " + NAMESPACE + ".Iterator]";


                            proto.toString = function ( ) {
                                return obj_name;
                            };


// Assign the argument to the element which is just after the position
// this iterator points to, then returns the new value of the element,
// which can be defferent from the argument.
// The effect of assignment at the tail of a list should be identical
// to the one of insertion.
// The default implementation merely throws UnimplementedMethodError.
                            proto.assign = function ( v ) {
                                throw new UnimplementedMethodError("assign", this);
                            };


// Inserts a new container at the position which this iterator points
// to and sets the argument to the container, then, returns the value
// of the container, which can be defferent from the argument.
// The position which the iterator points to after insertion is
// implementation-dependent.
// The default implementation merely throws UnimplementedMethodError.
                            proto.insert = function ( v ) {
                                throw new UnimplementedMethodError("insert", this);
                            };


// Removes the container just after the position which this iterator
// points, then, returns the value of the container.
// The position which the iterator points to after removal is
// implementation-dependent.
// The default implementation merely throws UnimplementedMethodError.
                            proto.remove = function ( ) {
                                throw new UnimplementedMethodError("remove", this);
                            };


// Returns true if both this iterator and the argument points to the same position,
// false otherwise.
// The default implementation is based on `compareTo' method.
                            proto.equals = function ( that ) {
                                return this.compareTo(that) === 0;
                            };


// Returns the distance of this iterator and the argument,
// or undefined if the iterators seem to point to defferent list.
// A negative return value means the arguments succeeds this iterator
// and its magnitude represents the distance of them. Thus, this can be
// used as comparison-function.
// The default implementation is based on `next', `equals' and `isTail' method.
                            proto.distance  =
                                proto.compareTo = function ( that ) {
                                    if ( !(that instanceof Iterator) ) return undefined;
                                    for ( var i=0, l=this, r=that;  ;  i--, l=l.next() ) {
                                        if ( l.equals(r) ) return i;
                                        if ( l.isTail() ) break;
                                    }
                                    for ( var i=1, l=that.next(), r=this;  ;  i++, l=l.next() ) {
                                        if ( l.equals(r) ) return i;
                                        if ( l.isTail() ) break;
                                    }
                                    return undefined;
                                };



                            return {
                                Iterator: Iterator
                            };
                        }();
                    }
                }
            }
        }.call(null) ) {
            this.Data.Functional.List.Iterator = Iterator;
        }
    }).call(null);
    (function(){
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Functional || (typeof this.Data.Functional != 'object' && typeof this.Data.Functional != 'function') ) this.Data.Functional = new Object();
        if ( !this.Data.Functional.List || (typeof this.Data.Functional.List != 'object' && typeof this.Data.Functional.List != 'function') ) this.Data.Functional.List = new Object();
        if ( this.Data.Functional.List.ReverseIterator === undefined ) this.Data.Functional.List.ReverseIterator = undefined;
        with ( function(){
            with ( Data.Functional.List ) {

                return function () {
                    var VERSION = '0.4.0';
                    var NAMESPACE;

                    /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Data.Functional code.
 *
 * The Initial Developer of the Original Code is
 * Daisuke Maki.
 * Portions created by the Initial Developer are Copyright (C) 2005-2007
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */



                    NAMESPACE = 'Data.Functional.List';





// This module provides convinient wrapper to construct
// reverse iterator from normal list iterator.



                    function ReverseIterator ( it ) {
                        this._it = it;
                    }

                    var proto = ReverseIterator.prototype = new Iterator();
                    proto.constructor = ReverseIterator;


                    proto.isBoundTo = function ( that ) {
                        return this._it.isBoundTo(that);
                    };

                    proto.isTail = function ( ) {
                        return this._it.isHead();
                    };

                    proto.isHead = function ( ) {
                        return this._it.isTail();
                    };

                    proto.next = function ( ) {
                        return new ReverseIterator(this._it.previous());
                    };

                    proto.previous = function ( ) {
                        return new ReverseIterator(this._it.next());
                    };

                    proto.value = function ( ) {
                        return this._it.previous().value();
                    };

                    proto.assign = function ( v ) {
                        return this._it.previous().assign(v);
                    };

                    proto.insert = function ( v ) {
                        return this._it.insert(v);
                    };

                    proto.remove = function ( ) {
                        return this._it.previous().remove();
                    };

                    proto.equals = function ( that ) {
                        if ( !(that instanceof ReverseIterator) ) return false;
                        return this._it.equal(taht._it);
                    };

                    proto.compareTo = function ( that ) {
                        if ( !(that instanceof ReverseIterator) ) return undefined;
                        var c = this._it.compareTo(that._it);
                        if ( isNaN(d) ) return c;
                        return -c;
                    };

                    proto.distance = function ( that ) {
                        if ( !(that instanceof ReverseIterator) ) return undefined;
                        var d = this._it.distance(that._it);
                        if ( isNaN(d) ) return d;
                        return -d;
                    };


                    return {
                        ReverseIterator: ReverseIterator
                    };
                }();
            }
        }.call(null) ) {
            this.Data.Functional.List.ReverseIterator = ReverseIterator;
        }
    }).call(null);
    (function(){
        with ( function(){

            return function () {
                var VERSION = '0.5.0';
                var NAMESPACE;

                /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Data.Functional code.
 *
 * The Initial Developer of the Original Code is
 * Daisuke Maki.
 * Portions created by the Initial Developer are Copyright (C) 2005-2007
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */




// This is just a alias.
// See "Data.Functional.List.list" for the entity of "Data.Functional.List".



                return {

                };
            }();
        }.call(null) ) {
        }
    }).call(null);
    (function(){
        if ( !this.Math || (typeof this.Math != 'object' && typeof this.Math != 'function') ) this.Math = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Error || (typeof this.Data.Error != 'object' && typeof this.Data.Error != 'function') ) this.Data.Error = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Iterator || (typeof this.Data.Iterator != 'object' && typeof this.Data.Iterator != 'function') ) this.Data.Iterator = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Functional || (typeof this.Data.Functional != 'object' && typeof this.Data.Functional != 'function') ) this.Data.Functional = new Object();
        if ( !this.Data.Functional.Loop || (typeof this.Data.Functional.Loop != 'object' && typeof this.Data.Functional.Loop != 'function') ) this.Data.Functional.Loop = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Functional || (typeof this.Data.Functional != 'object' && typeof this.Data.Functional != 'function') ) this.Data.Functional = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Cons || (typeof this.Data.Cons != 'object' && typeof this.Data.Cons != 'function') ) this.Data.Cons = new Object();
        if ( this.Data.Cons.list === undefined ) this.Data.Cons.list = undefined;
        if ( this.Data.Cons.InsertAtHeadError === undefined ) this.Data.Cons.InsertAtHeadError = undefined;
        if ( this.Data.Cons.RemoveHeadError === undefined ) this.Data.Cons.RemoveHeadError = undefined;
        with ( function(){
            with ( Math ) {
                with ( Data.Error ) {
                    with ( Data.Iterator ) {
                        with ( Data.Functional.Loop ) {
                            with ( Data.Functional ) {
                                with ( Data.Cons ) {

                                    return function () {
                                        var VERSION = '0.2.0';
                                        var NAMESPACE;

                                        /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Data.Cons code.
 *
 * The Initial Developer of the Original Code is
 * Daisuke Maki.
 * Portions created by the Initial Developer are Copyright (C) 2007
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */



                                        NAMESPACE = 'Data.Cons';























                                        var proto = new List();
                                        proto.toString       = Cell.prototype.toString;
                                        proto.toLocaleString = Cell.prototype.toLocaleString;
                                        proto.isNil          = Cell.prototype.isNil;
                                        Cell.prototype = proto;
                                        proto.constructor = Cell;

                                        proto = new Cell();
                                        proto.toString       = Nil.prototype.toString;
                                        proto.toLocaleString = Nil.prototype.toLocaleString;
                                        proto.isNil          = Nil.prototype.isNil;
                                        Nil.prototype = proto;
                                        proto.constructor = Nil;



                                        function list ( /* variable args */ ) {
                                            var head, cell;
                                            head = cell = new Cell(null, new Nil());
                                            for ( var i=0;  i < arguments.length;  i++ ) {
                                                cell = cell.cdr = new Cell(arguments[i], cell.cdr);
                                            }
                                            return head.cdr;
                                        }



                                        proto = Cell.prototype;


                                        proto.iterator =
                                            proto.head     = function ( n ) {
                                                n = ToInteger(n);
                                                if ( n < 0 ) return this.tail(-n);
                                                try {
                                                    for ( var it=new Iterator(this, this, null);  n > 0;  it=it.next(), n-- );
                                                    return it;
                                                } catch ( e ) {
                                                    if ( e instanceof NoSuchElementError ) {
                                                        throw new RangeError();
                                                    } else {
                                                        throw e;
                                                    }
                                                }
                                            };

                                        proto.tail = function ( n ) {
                                            n = ToInteger(n);
                                            if ( n < 0 ) return this.head(-n);
                                            for ( var it=new Iterator(this, this, null);  !it.isTail();  it=it.next() );
                                            try {
                                                for ( ;  n > 0;  it=it.previous(), n-- );
                                                return it;
                                            } catch ( e ) {
                                                if ( e instanceof NoSuchElementError ) {
                                                    throw new RangeError();
                                                } else {
                                                    throw e;
                                                }
                                            }
                                        };

                                        proto.reverseHead = function ( n ) {
                                            return new ReverseIterator(this.tail(n));
                                        };

                                        proto.reverseTail = function ( n ) {
                                            return new ReverseIterator(this.head(n));
                                        };


                                        proto.get = function ( n ) {
                                            if ( n instanceof Iterator || n instanceof ReverseIterator ) {
                                                if ( !n.isBoundTo(this) ) throw new IllegalStateError();
                                                return n.value();
                                            }
                                            n = ToInteger(n);
                                            if ( n < 0 ) return this.reverse().get(-n-1);
                                            var c = this;
                                            while ( n !== 0 ) {
                                                c = c.cdr;
                                                if ( c.isNil() ) return undefined;
                                                n--;
                                            }
                                            return c.car;
                                        };

                                        proto.set = function ( n, v ) {
                                            if ( n instanceof Iterator || n instanceof ReverseIterator ) {
                                                if ( !n.isBoundTo(this) ) throw new IllegalStateError();
                                                return n.assign(v);
                                            }
                                            return this.head(n).assign(v);
                                        };


                                        proto.add = function ( /* variable args */ ) {
                                            if ( arguments.length == 0 ) return false;
                                            if ( this.isNil() ) throw new InsertAtHeadError();
                                            for ( var c=this;  !c.cdr.isNil();  c=c.cdr );
                                            for ( var i=0;  i < arguments.length;  i++ ) {
                                                c = c.cdr = new Cell(arguments[i], new Nil());
                                            }
                                            return true;
                                        };

                                        proto.shift = function ( ) {
                                            throw new RemoveHeadError();
                                        };

                                        proto.unshift = function ( ) {
                                            throw new InsertAtHeadError();
                                        };

                                        proto.pop = function ( ) {
                                            if ( this.isNil() ) return undefined;
                                            if ( this.cdr.isNil() ) throw new RemoveHeadError();
                                            for ( var c=this.cdr;  !c.cdr.cdr.isNil();  c=c.cdr );
                                            var r = c.cdr.car;
                                            c.cdr = c.cdr.cdr;
                                            return r;
                                        };

                                        proto.push = function ( /* variable args */ ) {
                                            if ( arguments.length == 0 ) return this.size();
                                            if ( this.isEmpty() ) throw new InsertAtHeadError();
                                            for ( var l=1, c=this;  !c.cdr.isNil();  l++, c=c.cdr );
                                            for ( var i=0;  i < arguments.length;  i++, l++ ) {
                                                c = c.cdr = new Cell(arguments[i], c.cdr);
                                            }
                                            return l;
                                        };


                                        proto.isEmpty = function ( ) {
                                            return this.isNil();
                                        };

                                        proto.empty = function ( ) {
                                            if ( this.isEmpty() ) return;
                                            throw new RemoveHeadError();
                                        };

                                        proto.size = function ( ) {
                                            for ( var i=0, c=this;  !c.isNil();  i++, c=c.cdr );
                                            return i;
                                        };

                                        proto.copy = function ( ) {
                                            if ( this.isNil() ) return new Nil();
                                            var head, cell;
                                            head = cell = new Cell(this.car, new Nil());
                                            for ( var c=this.cdr;  !c.isNil();  c=c.cdr ) {
                                                cell = cell.cdr = new Cell(c.car, cell.cdr);
                                            }
                                            return head;
                                        };

                                        proto.toArray = function ( ) {
                                            var a = [];
                                            for ( var c=this;  !c.isNil();  c=c.cdr ) a.push(c.car);
                                            return a;
                                        };

                                        proto.reverse = function ( ) {
                                            var r = new Nil();
                                            for ( var c=this;  !c.isNil();  c=c.cdr ) r = new Cell(c.car, r);
                                            return r;
                                        };

                                        proto.concat = function ( /* variable args */ ) {
                                            var head, cell;
                                            head = cell = new Cell(null, new Nil());
                                            arguments[-1] = this;
                                            for ( var i=-1;  i < arguments.length;  i++ ) {
                                                var c = arguments[i];
                                                if ( c instanceof List ) {
                                                    c.forEach(function( it ){
                                                        cell = cell.cdr = new Cell(it, cell.cdr);
                                                    });
                                                } else if ( c instanceof Array ) {
                                                    for ( var j=0;  j < c.length;  j++ ) {
                                                        cell = cell.cdr = new Cell(c[j], cell.cdr);
                                                    }
                                                } else {
                                                    cell = cell.cdr = new Cell(c, cell.cdr);
                                                }
                                            }
                                            return head.cdr;
                                        };

                                        proto.slice = function ( start, end ) {
                                            if ( !( (   start instanceof Iterator        && end instanceof Iterator
                                                    || start instanceof ReverseIterator && end instanceof ReverseIterator )
                                                    && start.isBoundTo(this) && end.isBoundTo(this) ) )
                                            {   try {
                                                start = this.head(start);
                                            } catch ( e ) {
                                                if ( e instanceof RangeError ) {
                                                    start = start < 0 ? this.head() : this.tail();
                                                } else {
                                                    throw e;
                                                }
                                            }
                                                if ( end === undefined ) {
                                                    end = this.tail();
                                                } else {
                                                    try {
                                                        end = this.head(end);
                                                    } catch ( e ) {
                                                        if ( e instanceof RangeError ) {
                                                            end = end < 0 ? this.head() : this.tail();
                                                        } else {
                                                            throw e;
                                                        }
                                                    }
                                                }
                                            }
                                            if ( start.compareTo(end) >= 0 ) return new Nil();
                                            var head, cell;
                                            head = cell = new Cell(null, new Nil());
                                            while ( !start.equals(end) ) {
                                                cell = cell.cdr = new Cell(start.value(), cell.cdr);
                                                start = start.next();
                                            }
                                            return head.cdr;
                                        }


                                        proto.forEach = function ( f ) {
                                            f = wrap_for_forEach(this, f);
                                            for ( var c=this;  !c.isNil();  c=c.cdr ) {
                                                try {
                                                    f(c.car);
                                                } catch ( e ) {
                                                    if ( e instanceof EndOfLoopException ) {
                                                        return;
                                                    } else {
                                                        throw e;
                                                    }
                                                }
                                            }
                                        };

                                        proto.fold  =
                                            proto.foldl = function ( f, s ) {
                                                f = wrap_for_fold(this, f, s);
                                                for ( var c=this;  !c.isNil();  c=c.cdr ) {
                                                    try {
                                                        s = f(c.car);
                                                    } catch ( e ) {
                                                        if ( e instanceof EndOfLoopException ) {
                                                            return e.result;
                                                        } else {
                                                            throw e;
                                                        }
                                                    }
                                                }
                                                return s;
                                            };

                                        proto.fold1  =
                                            proto.foldl1 = function ( f ) {
                                                if ( this.isEmpty() ) throw new EmptyEnumerationError();
                                                var s = this.car;
                                                f = wrap_for_fold(this, f, s);
                                                for ( var c=this.cdr;  !c.isNil();  c=c.cdr ) {
                                                    try {
                                                        s = f(c.car);
                                                    } catch ( e ) {
                                                        if ( e instanceof EndOfLoopException ) {
                                                            return e.result;
                                                        } else {
                                                            throw e;
                                                        }
                                                    }
                                                }
                                                return s;
                                            };

                                        proto.foldr = function ( f, s ) {
                                            return this.reverse().foldl(function(x,y){return f.call(this,y,x);}, s);
                                        };

                                        proto.foldr1 = function ( f ) {
                                            return this.reverse().foldl1(function(x,y){return f.call(this,y,x);});
                                        };

                                        proto.map = function ( f ) {
                                            if ( this.isNil() ) return new Nil();
                                            var head, cell;
                                            head = cell = new Cell(null, new Nil());
                                            f = wrap_for_map(this, f, function(){
                                                for ( var i=0;  i < arguments.length;  i++ ) {
                                                    cell = cell.cdr = new Cell(arguments[i], cell.cdr);
                                                }
                                            });
                                            for ( var c=this;  !c.isNil();  c=c.cdr ) {
                                                try {
                                                    f(c.car);
                                                } catch ( e ) {
                                                    if ( e instanceof EndOfLoopException ) {
                                                        return head.cdr;
                                                    } else {
                                                        throw e;
                                                    }
                                                }
                                            }
                                            return head.cdr;
                                        }



                                        function Iterator ( head, cell, prev ) {
                                            this._head = head;
                                            this._cell = cell;
                                            this._prev = prev;
                                        }

                                        var proto = Iterator.prototype = new List.Iterator();
                                        proto.constructor = Iterator;

                                        proto.isBoundTo = function ( that ) {
                                            return this._head === that;
                                        };

                                        proto.isHead = function ( ) {
                                            return this._head === this._cell;
                                        };

                                        proto.isTail = function ( ) {
                                            return this._cell.isNil();
                                        };

                                        proto.value = function ( ) {
                                            return this._cell.car;
                                        };

                                        proto.assign = function ( v ) {
                                            if ( this.isTail() ) this.insert(v);
                                            else                 this._cell.car = v;
                                            return v;
                                        };

                                        proto.insert = function ( v ) {
                                            if ( this.isHead() ) throw new InsertAtHeadError();
                                            this._cell = this._prev._cell.cdr = new Cell(v, this._cell.cdr);
                                            return v;
                                        };

                                        proto.remove = function ( ) {
                                            if ( this.isHead() ) throw new RemoveHeadError();
                                            if ( this.isTail() ) throw new IllegalStateError("can't remove at tail");
                                            var r = this._cell.car;
                                            this._cell = this._prev._cell.cdr = this._cell.cdr;
                                            return r;
                                        };

                                        proto.next = function ( ) {
                                            if ( this.isTail() ) throw new NoSuchElementError("no next element");
                                            return new Iterator(this._head, this._cell.cdr, this);
                                        };

                                        proto.previous = function ( ) {
                                            if ( this.isHead() ) throw new NoSuchElementError("no previous element");
                                            return this._prev;
                                        };

                                        proto.equals = function ( that ) {
                                            return that instanceof Iterator
                                                && that.isBoundTo(this._head)
                                                && this._cell === that._cell;
                                        };

                                        proto.compareTo =
                                            proto.distance  = function ( that ) {
                                                if ( !(that instanceof Iterator && that.isBoundTo(this._head)) ) return undefined;
                                                for ( var i=0, l=this._cell, r=that._cell;  !l.isNil();  i++, l=l.cdr ) {
                                                    if ( l === r ) return -i;
                                                }
                                                for ( var i=1, l=that._cell.cdr, r=this._cell;  !l.isNil();  i++, l=l.cdr ) {
                                                    if ( l === r ) return i;
                                                }
                                                return void 0;
                                            };


                                        function ReverseIterator ( ) {
                                            return List.ReverseIterator.apply(this, arguments);
                                        }

                                        var proto = ReverseIterator.prototype = new List.ReverseIterator();
                                        proto.constructor = ReverseIterator;




                                        var InsertAtHeadError = Error.extend(
                                            function ( $super, message ) { $super(message); },
                                            {
                                                name   : NAMESPACE + ".InsertAtHeadError",
                                                message: "can't insert at head of cons-list"
                                            }
                                        );


                                        var RemoveHeadError = Error.extend(
                                            function ( $super, message ) { $super(message); },
                                            {
                                                name   : NAMESPACE + ".RemoveHeadError",
                                                message: "can't remove head of cons-list"
                                            }
                                        );


                                        return {
                                            InsertAtHeadError: InsertAtHeadError, RemoveHeadError: RemoveHeadError, list: list
                                        };
                                    }();
                                }
                            }
                        }
                    }
                }
            }
        }.call(null) ) {
            this.Data.Cons.InsertAtHeadError = InsertAtHeadError;
            this.Data.Cons.RemoveHeadError = RemoveHeadError;
            this.Data.Cons.list = list;
        }
    }).call(null);
    (function(){
        if ( !this.Math || (typeof this.Math != 'object' && typeof this.Math != 'function') ) this.Math = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Error || (typeof this.Data.Error != 'object' && typeof this.Data.Error != 'function') ) this.Data.Error = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Functional || (typeof this.Data.Functional != 'object' && typeof this.Data.Functional != 'function') ) this.Data.Functional = new Object();
        if ( !this.Data.Functional.Loop || (typeof this.Data.Functional.Loop != 'object' && typeof this.Data.Functional.Loop != 'function') ) this.Data.Functional.Loop = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Functional || (typeof this.Data.Functional != 'object' && typeof this.Data.Functional != 'function') ) this.Data.Functional = new Object();
        with ( function(){
            with ( Math ) {
                with ( Data.Error ) {
                    with ( Data.Functional.Loop ) {
                        with ( Data.Functional ) {

                            return function () {
                                var VERSION = '0.5.0';
                                var NAMESPACE;

                                /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Data.Functional code.
 *
 * The Initial Developer of the Original Code is
 * Daisuke Maki.
 * Portions created by the Initial Developer are Copyright (C) 2005-2007
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */


















                                var proto = Array.prototype;

                                for ( var i in List.prototype ) {
                                    if ( typeof proto[i] != "function" ) proto[i] = List.prototype[i];
                                }


                                proto.head = function ( n ) {
                                    if ( n < 0 ) return this.tail(-n);
                                    n = ToInteger(n);
                                    if ( n > this.length ) throw new RangeError();
                                    return new Iterator(this, n);
                                };

                                proto.tail = function ( n ) {
                                    if ( n < 0 ) return this.head(-n);
                                    n = ToInteger(n);
                                    if ( n > this.length ) throw new RangeError();
                                    return new Iterator(this, this.length-n);
                                };

                                proto.iterator = proto.head;

                                proto.reverseHead = function ( n ) {
                                    if ( n < 0 ) return this.reverseTail(-n);
                                    n = ToInteger(n);
                                    if ( n > this.length ) throw new RangeError();
                                    return new ReverseIterator(this, n);
                                };

                                proto.reverseTail = function ( n ) {
                                    if ( n < 0 ) return this.reverseHead(-n);
                                    n = ToInteger(n);
                                    if ( n > this.length ) throw new RangeError();
                                    return new ReverseIterator(this, this.length-n);
                                };


                                proto.add = function ( /* variable args */ ) {
                                    this.push.apply(this, arguments);
                                    return true;
                                };

                                proto.get = function ( it ) {
                                    if ( it instanceof Iterator || it instanceof ReverseIterator ) {
                                        if ( it.isBoundTo(this) ) return it.value();
                                        throw new IllegalStateError();
                                    }
                                    it = ToInteger(n);
                                    if ( it < 0 ) it += this.length;
                                    return this[it];
                                };

                                proto.set = function ( it, v ) {
                                    if ( it instanceof Iterator || it instanceof ReverseIterator ) {
                                        if ( it.isBoundTo(this) ) return it.assign(v);
                                        throw new IllegalStateError();
                                    }
                                    var n = ToInteger(it);
                                    if ( n < 0            ) n += this.length;
                                    if ( n < 0            ) throw new RangeError("`" + it + "' is too small.");
                                    if ( n >= this.length ) throw new RangeError("`" + it + "' is too large.");
                                    return this[n] = v;
                                };

                                proto.insertAt = function ( it, v ) {
                                    if ( it instanceof Iterator || it instanceof ReverseIterator ) {
                                        if ( it.isBoundTo(this) ) return it.insert(v);
                                        throw new IllegalStateError();
                                    }
                                    var n = ToInteger(it);
                                    if ( n < 0            ) n += this.length;
                                    if ( n < 0            ) throw new RangeError("`" + it + "' is too small.");
                                    if ( n >= this.length ) throw new RangeError("`" + it + "' is too large.");
                                    this.splice(n, 0, v);
                                    return v;
                                };

                                proto.removeAt = function ( it ) {
                                    if ( it instanceof Iterator || it instanceof ReverseIterator ) {
                                        if ( it.isBoundTo(this) ) return it.remove();
                                        throw new IllegalStateError();
                                    }
                                    var n = ToInteger(it);
                                    if ( n < 0            ) n += this.length;
                                    if ( n < 0            ) throw new RangeError("`" + it + "' is too small.");
                                    if ( n >= this.length ) throw new RangeError("`" + it + "' is too large.");
                                    return this.splice(n, 1)[0];
                                };


                                proto.isEmpty = function ( ) {
                                    return this.length == 0;
                                };

                                proto.empty = function ( ) {
                                    this.length = 0;
                                };

                                proto.size = function ( ) {
                                    return this.length;
                                };

                                proto.copy    =
                                    proto.toArray = function ( ) {
                                        var a = [];
                                        for ( var i=0;  i < this.length;  i++ ) a[i] = this[i];
                                        return a;
                                    };


                                proto.forEach = function ( f ) {
                                    f = wrap_for_forEach(this, f);
                                    for ( var i=0;  i < this.length;  i++ ) {
                                        try {
                                            f(this[i]);
                                        } catch ( e ) {
                                            if ( e instanceof EndOfLoopException ) {
                                                return;
                                            } else {
                                                throw e;
                                            }
                                        }
                                    }
                                };

                                proto.fold  =
                                    proto.foldl = function ( f, s ) {
                                        f = wrap_for_fold(this, f, s);
                                        for ( var i=0;  i < this.length;  i++ ) {
                                            try {
                                                s = f(this[i]);
                                            } catch ( e ) {
                                                if ( e instanceof EndOfLoopException ) {
                                                    return e.result;
                                                } else {
                                                    throw e;
                                                }
                                            }
                                        }
                                        return s;
                                    };

                                proto.fold1  =
                                    proto.foldl1 = function ( f ) {
                                        if ( this.length == 0 ) throw new EmptyEnumerationError();
                                        var s = this[0];
                                        f = wrap_for_fold(this, f, s);
                                        for ( var i=1;  i < this.length;  i++ ) {
                                            try {
                                                s = f(this[i]);
                                            } catch ( e ) {
                                                if ( e instanceof EndOfLoopException ) {
                                                    return e.result;
                                                } else {
                                                    throw e;
                                                }
                                            }
                                        }
                                        return s;
                                    };

                                proto.foldr = function ( f, s ) {
                                    var g = wrap_for_fold(this, function(x,y){return f.call(this,y,x);}, s);
                                    for ( var i=this.length-1;  i >= 0;  i-- ) {
                                        try {
                                            s = f(this[i]);
                                        } catch ( e ) {
                                            if ( e instanceof EndOfLoopException ) {
                                                return e.result;
                                            } else {
                                                throw e;
                                            }
                                        }
                                    }
                                    return s;
                                };

                                proto.foldr1 = function ( f ) {
                                    if ( this.length == 0 ) throw new EmptyEnumerationError();
                                    var s = this[this.length-1];
                                    var g = wrap_for_fold(this, function(x,y){return f.call(this,y,x);}, s);
                                    for ( var i=this.length-2;  i >= 0;  i-- ) {
                                        try {
                                            s = g(this[i]);
                                        } catch ( e ) {
                                            if ( e instanceof EndOfLoopException ) {
                                                return e.result;
                                            } else {
                                                throw e;
                                            }
                                        }
                                    }
                                    return s;
                                };

                                proto.map = function ( f ) {
                                    var a = [];
                                    f = wrap_for_map(this, f, function(){
                                        a.push.apply(a, arguments);
                                    });
                                    for ( var i=0;  i < this.length;  i++ ) {
                                        try {
                                            f(this[i]);
                                        } catch ( e ) {
                                            if ( e instanceof EndOfLoopException ) return a;
                                            else                                   throw e;
                                        }
                                    }
                                    return a;
                                };


// Re-define concat and slice
                                var original_concat = proto.concat;
                                proto.concat = function ( /* variable argumentes */ ) {
                                    for ( var i=0;  i < arguments.length;  i++ ) {
                                        var v = arguments[i];
                                        if ( v instanceof List ) arguments[i] = v.toArray();
                                    }
                                    return original_concat.apply(this, arguments);
                                };

                                var original_slice = proto.slice;
                                proto.slice = function ( start, end ) {
                                    if (   (   start instanceof Iterator        && end instanceof Iterator
                                            || start instanceof ReverseIterator && end instanceof ReverseIterator )
                                        && start.isBoundTo(this) && end.isBoundTo(this)  )
                                    {
                                        if ( start.compareTo(end) >= 0 ) return [];
                                        var s = [];
                                        do {
                                            s.push(start.value());
                                            start = start.next();
                                        } while ( !start.equals(end) );
                                        return s;
                                    } else {
                                        return original_slice.apply(this, arguments);
                                    }
                                };



                                function Iterator ( a, n ) {
                                    this._arr = a;
                                    this._pos = n;
                                }

                                var proto = Iterator.prototype = new List.Iterator();
                                proto.constructor = Iterator;

                                proto.isBoundTo = function ( that ) {
                                    return this._arr === that;
                                };

                                proto.isHead = function ( ) {
                                    return ToInteger(this._pos) <= 0
                                        || this._arr.length == 0;
                                };

                                proto.isTail = function ( ) {
                                    return ToInteger(this._pos) >= this._arr.length
                                        || this._arr.length == 0;
                                };

                                proto.value = function ( ) {
                                    if ( this.isTail() ) return undefined;
                                    if ( this.isHead() ) return this._arr[0];
                                    else                 return this._arr[ToInteger(this._pos)];
                                };

                                proto.assign = function ( v ) {
                                    if ( this.isTail() ) return this.insert();
                                    if ( this.isHead() ) return this._arr[0] = v;
                                    else                 return this._arr[ToInteger(this._pos)] = v;
                                };

                                proto.insert = function ( v ) {
                                    var i = ToInteger(this._pos);
                                    if ( i <= 0 ) i = 0;
                                    else          i = min(i, this._arr.length);
                                    return this._arr.insertAt(i, v);
                                };

                                proto.remove = function ( ) {
                                    if      ( this.isTail() ) throw new IllegalStateError("can't remove at the tail of list");
                                    else if ( this.isHead() ) return this._arr.aplice(0, 1)[0];
                                    else                      return this._arr.splice(this._pos, 1)[0];
                                };

                                proto.next = function ( ) {
                                    if ( this.isTail() ) throw new NoSuchElement("no next element");
                                    if ( this.isHead() ) return new this.constructor(this._arr, 1);
                                    else                 return new this.constructor(this._arr, this._pos+1);
                                };

                                proto.previous = function ( ) {
                                    if ( this.isHead() ) throw new NoSuchElement("no previous element");
                                    if ( this.isTail() ) return new this.constructor(this._arr, this._arr.length-1);
                                    else                 return new this.constructor(this._arr, this._pos-1);
                                };

                                proto.compareTo =
                                    proto.distance  = function ( that ) {
                                        if ( !(that instanceof this.constructor) ) return undefined;
                                        if ( this._arr !== that._arr             ) return undefined;
                                        var s = this._arr.length;
                                        var l = ToInteger(this._pos);
                                        var r = ToInteger(that._pos);
                                        if ( l <= 0  &&  r <= 0
                                            || l >= s  &&  r >= s ) return 0;
                                        return l - r;
                                    };


                                function ReverseIterator ( a, n ) {
                                    Iterator.apply(this, arguments);
                                }

                                var proto = ReverseIterator.prototype = new List.Iterator();

                                for ( var i in Iterator.prototype ) {
                                    if ( Iterator.prototype.hasOwnProperty(i)
                                        && typeof Iterator.prototype[i] == "function" )
                                    {
                                        proto[i] = Iterator.prototype[i];
                                    }
                                }

                                proto.constructor = ReverseIterator;

                                proto.value = function ( ) {
                                    if ( this.isTail() ) return undefined;
                                    if ( this.isHead() ) return this._arr[this._arr.length-1];
                                    else                 return this._arr[this._arr.length-1-ToInteger(this._pos)];
                                };

                                proto.assign = function ( v ) {
                                    if ( this.isTail() ) this.insert(v);
                                    if ( this.isHead() ) return this._arr[this._arr.length-1] = v;
                                    else                 return this._arr[this._arr.length-1-ToInteger(this._pos)] = v;
                                };

                                proto.insert = function ( v ) {
                                    var i = ToInteger(this._pos);
                                    if ( i <= 0 ) i = 0;
                                    else          i = min(i, this._arr.length);
                                    return this._arr.insertAt(this._arr.length-i, v);
                                };

                                proto.remove = function ( ) {
                                    if ( this.isTail() ) throw new IllegalStateError("can't remove at the tail of list");
                                    if ( this.isHead() ) return this._arr.splice(this._arr.length-1, 1)[0];
                                    else                 return this._arr.splice(this._arr.length-1-ToInteger(this._pos), 1)[0];
                                };


                                return {

                                };
                            }();
                        }
                    }
                }
            }
        }.call(null) ) {
        }
    }).call(null);
    (function(){
        if ( !this.Math || (typeof this.Math != 'object' && typeof this.Math != 'function') ) this.Math = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Error || (typeof this.Data.Error != 'object' && typeof this.Data.Error != 'function') ) this.Data.Error = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Iterator || (typeof this.Data.Iterator != 'object' && typeof this.Data.Iterator != 'function') ) this.Data.Iterator = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Functional || (typeof this.Data.Functional != 'object' && typeof this.Data.Functional != 'function') ) this.Data.Functional = new Object();
        if ( !this.Data.Functional.Loop || (typeof this.Data.Functional.Loop != 'object' && typeof this.Data.Functional.Loop != 'function') ) this.Data.Functional.Loop = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Functional || (typeof this.Data.Functional != 'object' && typeof this.Data.Functional != 'function') ) this.Data.Functional = new Object();
        if ( this.Data.LinkedList === undefined ) this.Data.LinkedList = undefined;
        with ( function(){
            with ( Math ) {
                with ( Data.Error ) {
                    with ( Data.Iterator ) {
                        with ( Data.Functional.Loop ) {
                            with ( Data.Functional ) {
                                with ( Data ) {

                                    return function () {
                                        var VERSION = '0.3.1';
                                        var NAMESPACE;

                                        /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Data.LinkedList module.
 *
 * The Initial Developer of the Original Code is
 * Daisuke Maki.
 * Portions created by the Initial Developer are Copyright (C) 2005-2007
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */



                                        NAMESPACE = 'Data';




















                                        function LinkedList ( /* variable arguments */ ) {
                                            this._value   = undefined;
                                            this._prev    = this;
                                            this._next    = this;
                                            this._removed = false;
                                            this.add.apply(this, arguments);
                                        }

                                        LinkedList.fromCollection = function ( /* variable args */ ) {
                                            var l = new LinkedList();
                                            l.addAll.apply(l, arguments);
                                            return l;
                                        };


                                        function makeContainer ( v ) {
                                            return { _value: v, _removed: false };
                                        }


                                        var proto = LinkedList.prototype = new List();
                                        proto.constructor = LinkedList;


                                        function nForward ( top, c, n ) {
                                            if ( n == 0 ) return c;
                                            c = c._next;
                                            while ( --n > 0 ) {
                                                if ( c === top ) throw new RangeError();
                                                c = c._next;
                                            }
                                            return c;
                                        }

                                        function nBackward ( top, c, n ) {
                                            if ( n == 0 ) return c;
                                            c = c._prev;
                                            while ( --n > 0 ) {
                                                if ( c === top ) throw new RangeError();
                                                c = c._prev;
                                            }
                                            return c;
                                        }


                                        proto.head = function ( n ) {
                                            if ( n < 0 ) return this.tail(-n);
                                            return new Iterator( this, nForward(this, this._next, ToInteger(n)) );
                                        };

                                        proto.tail = function ( n ) {
                                            if ( n < 0 ) return this.head(-n);
                                            return new Iterator( this, nBackward(this, this, ToInteger(n)) );
                                        };

                                        proto.reverseHead = function ( n ) {
                                            if ( n < 0 ) return this.reverseTail(-n);
                                            return new ReverseIterator( this, nBackward(this, this._prev, ToInteger(n)) );
                                        };

                                        proto.reverseTail = function ( n ) {
                                            if ( n < 0 ) return this.reverseHead(-n);
                                            return new ReverseIterator( this, nBackward(this, this, ToInteger(n)) );
                                        };

                                        proto.iterator = proto.head;


                                        proto.add = function ( /* variable args */ ) {
                                            if ( !arguments.length ) return false;
                                            var it = new Iterator(this, this);
                                            for ( var i=0;  i < arguments.length;  i++ ) it.insert(arguments[i]);
                                            return true;
                                        };

                                        proto.pop = function ( ) {
                                            return (new Iterator(this, this._prev)).remove();
                                        };

                                        proto.shift = function ( ) {
                                            return (new Iterator(this, this._next)).remove();
                                        };

                                        proto.unshift = function ( /* variable arguments */ ) {
                                            var it = new Iterator(this, this._next);
                                            for ( var i=0;  i < arguments.length;  i++ ) it.insert(arguments[i]);
                                            return this.size();
                                        };


                                        proto.isEmpty = function ( ) {
                                            return this._next === this;
                                        };

                                        proto.empty = function ( ) {
                                            this._prev = this._next = this;
                                        };

                                        proto.size = function ( ) {
                                            for ( var i=0, c=this._next;  c !== this;  ++i, c=c._next );
                                            return i;
                                        };

                                        proto.copy = function ( ) {
                                            var l = this.emptyCopy();
                                            for ( var c=this._next;  c !== this;  c=c._next ) l.add(c._value);
                                            return l;
                                        };

                                        proto.toArray = function ( ) {
                                            var a = [];
                                            for ( var c=this._next;  c !== this;  c=c._next ) a.push(c._value);
                                            return a;
                                        };


                                        proto.forEach = function ( f ) {
                                            f = wrap_for_forEach(this, f);
                                            for ( var c=this._next;  c !== this;  c=c._next ) {
                                                try {
                                                    f(c._value);
                                                } catch ( e ) {
                                                    if ( e instanceof EndOfLoopException ) {
                                                        return;
                                                    } else {
                                                        throw e;
                                                    }
                                                }
                                            }
                                        }

                                        proto.fold  =
                                            proto.foldl = function ( f, s ) {
                                                f = wrap_for_fold(this, f, s);
                                                for ( var c=this._next;  c !== this;  c=c._next ) {
                                                    try {
                                                        s = f(c._value);
                                                    } catch ( e ) {
                                                        if ( e instanceof EndOfLoopException ) {
                                                            return e.result;
                                                        } else {
                                                            throw e;
                                                        }
                                                    }
                                                }
                                                return s;
                                            };

                                        proto.fold1  =
                                            proto.foldl1 = function ( f ) {
                                                if ( this.isEmpty() ) throw new EmptyEnumerationError();
                                                var s = this._next._value;
                                                f = wrap_for_fold(this, f, s);
                                                for ( var c=this._next._next;  c !== this;  c=c._next ) {
                                                    try {
                                                        s = f(c._value);
                                                    } catch ( e ) {
                                                        if ( e instanceof EndOfLoopException ) {
                                                            return e.result;
                                                        } else {
                                                            throw e;
                                                        }
                                                    }
                                                }
                                                return s;
                                            };

                                        proto.foldr = function ( f, s ) {
                                            var g = wrap_for_fold(this, function(x,y){return f.call(this,y,x);}, s);
                                            for ( var c=this._prev;  c !== this;  c=c._prev ) {
                                                try {
                                                    s = f(c._value);
                                                } catch ( e ) {
                                                    if ( e instanceof EndOfLoopException ) {
                                                        return e.result;
                                                    } else {
                                                        throw e;
                                                    }
                                                }
                                            }
                                            return s;
                                        };

                                        proto.foldr1 = function ( f ) {
                                            if ( this.isEmpty() ) throw new EmptyEnumerationError();
                                            var s = this._prev._value;
                                            var g = wrap_for_fold(this, function(x,y){return f.call(this,y,x);}, s);
                                            for ( var c=this._prev._prev;  c !== this;  c=c._prev ) {
                                                try {
                                                    s = g(c._value);
                                                } catch ( e ) {
                                                    if ( e instanceof EndOfLoopException ) {
                                                        return e.result;
                                                    } else {
                                                        throw e;
                                                    }
                                                }
                                            }
                                            return s;
                                        };

                                        proto.map = function ( f ) {
                                            var l = new LinkedList();
                                            f = wrap_for_map(this, f, function(){
                                                l.add.apply(l, arguments);
                                            });
                                            for ( var c=this._next;  c !== this;  c=c._next ) {
                                                try {
                                                    f(c._value);
                                                } catch ( e ) {
                                                    if ( e instanceof EndOfLoopException ) return l;
                                                    else                                   throw e;
                                                }
                                            }
                                            return l;
                                        };



// comparison function about containers
                                        function comp ( top, l, r ) {
                                            if ( l === r ) return 0;
                                            do {
                                                l = l._next;
                                                if ( l === r ) return -1;
                                            } while ( l !== top );
                                            return 1;
                                        }

// distance function about containers
                                        function dist ( top, l, r ) {
                                            for ( var i=0, it=l;  it !== top;  i--, it=it._next ) {
                                                if ( it === r ) return i;
                                            }
                                            for ( var i=1, it=r._next;  it !== top;  i++, it=it._next ) {
                                                if ( it === l ) return i;
                                            }
                                            return undefined;
                                        }


                                        function Iterator ( l, c ) {
                                            this._top = l;  // LinkedList object which this iterator belongs to.
                                            this._pos = c;  // Current position; abstractly iterator points to just before this container
                                        }

                                        var proto = Iterator.prototype = new List.Iterator();
                                        proto.constructor = Iterator;

                                        function validate ( it ) {
                                            while ( it._pos._removed ) {
                                                it._pos = it._pos._next;
                                            }
                                        }

                                        proto.isBoundTo = function ( that ) {
                                            return this._top === that;
                                        };

                                        proto.equals = function ( that ) {
                                            if ( !(that instanceof Iterator && that.isBoundTo(this._top)) ) return false;
                                            validate(this);
                                            validate(that);
                                            return  this._pos === that._pos;
                                        };

                                        proto.compareTo = function ( that ) {
                                            if ( !(that instanceof Iterator && that.isBoundTo(this._top)) ) return undefined;
                                            validate(this);
                                            validate(that);
                                            return comp(this._top, this._pos, that._pos);
                                        };

                                        proto.distance = function ( that ) {
                                            if ( !(that instanceof Iterator && that.isBoundTo(this._top)) ) return undefined;
                                            validate(this);
                                            validate(that);
                                            return dist(this._top, this._pos, that._pos);
                                        };

                                        proto.isHead = function ( ) {
                                            validate(this);
                                            return this._pos === this._top._next;
                                        };

                                        proto.isTail = function ( ) {
                                            validate(this);
                                            return this._pos === this._top;
                                        };

                                        proto.next = function ( ) {
                                            if ( this.isTail() ) throw new NoSuchElementError("no next element");
                                            return new Iterator(this._top, this._pos._next);
                                        };

                                        proto.previous = function ( ) {
                                            if ( this.isHead() ) throw new NoSuchElementError("no previous element");
                                            return new Iterator(this._top, this._pos._prev);
                                        };

                                        proto.value = function ( ) {
                                            validate(this);
                                            return this._pos._value;
                                        };

                                        proto.assign = function ( v ) {
                                            if ( this.isTail() ) return this.insert(v);
                                            else                 return this._pos._value = v;
                                        };

                                        proto.insert = function ( v ) {
                                            validate(this);
                                            var c = makeContainer(v);
                                            c._prev = this._pos._prev;
                                            c._next = this._pos;
                                            this._pos._prev = this._pos._prev._next = c;
                                            return v;
                                        };

                                        proto.remove = function ( ) {
                                            if ( this.isTail() ) throw new IllegalStateError("can't remove at the tail of list");
                                            this._pos._prev._next = this._pos._next;
                                            this._pos._next._prev = this._pos._prev;
                                            this._pos._removed = true;
                                            return this._pos._value;
                                        };



                                        function ReverseIterator ( l, c ) {
                                            this._top = l;  // LinkedList object which this iterator belongs to.
                                            this._pos = c;  // Current position; abstractly iterator points to just before this container
                                        }

                                        var proto = ReverseIterator.prototype = new List.Iterator();
                                        for ( var i in Iterator.prototype ) proto[i] = Iterator.prototype[i];
                                        proto.constructor = ReverseIterator;

                                        function rvalidate ( it ) {
                                            while ( it._pos._removed ) {
                                                it._pos = it._pos._prev;
                                            }
                                        }

                                        proto.isBoundTo = Iterator.prototype.isBoundTo;

                                        proto.equals = function ( that ) {
                                            if ( !(that instanceof Iterator && that.isBoundTo(this._top)) ) return false;
                                            rvalidate(this);
                                            rvalidate(that);
                                            return  this._pos === that._pos;
                                        };

                                        proto.compareTo = function ( that ) {
                                            if ( !(that instanceof Iterator && that.isBoundTo(this._top)) ) return undefined;
                                            rvalidate(this);
                                            rvalidate(that);
                                            return -comp(this._top, this._pos, that._pos);
                                        };

                                        proto.distance = function ( that ) {
                                            if ( !(that instanceof Iterator && that.isBoundTo(this._top)) ) return undefined;
                                            rvalidate(this);
                                            rvalidate(that);
                                            var d = dist(this._top, this._pos, that._pos);
                                            return isNaN(d) ? d : -d;
                                        };

                                        proto.isHead = function ( ) {
                                            rvalidate(this);
                                            return this._pos === this._top._prev;
                                        };

                                        proto.isTail = function ( ) {
                                            rvalidate(this);
                                            return this._pos === this._top;
                                        };

                                        proto.next = function ( ) {
                                            if ( this.isTail() ) throw new NoSuchElementError("no next element");
                                            return new ReverseIterator(this._top, this._pos._prev);
                                        };

                                        proto.previous = function ( ) {
                                            if ( this.isHead() ) throw new NoSuchElementError("no previous element");
                                            return new ReverseIterator(this._top, this._pos._next);
                                        };

                                        proto.value = function ( ) {
                                            rvalidate(this);
                                            return this._pos._value;
                                        };

                                        proto.assign = Iterator.prototype.assign;

                                        proto.insert = function ( v ) {
                                            rvalidate(this);
                                            var c = makeContainer(v);
                                            c._next = this._pos._next;
                                            c._prev = this._pos;
                                            this._pos._next = this._pos._next._prev = c;
                                            return v;
                                        };

                                        proto.remove = Iterator.prototype.remove;


                                        return {
                                            LinkedList: LinkedList
                                        };
                                    }();
                                }
                            }
                        }
                    }
                }
            }
        }.call(null) ) {
            this.Data.LinkedList = LinkedList;
        }
    }).call(null);
    (function(){
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Error || (typeof this.Data.Error != 'object' && typeof this.Data.Error != 'function') ) this.Data.Error = new Object();
        if ( !this.Concurrent || (typeof this.Concurrent != 'object' && typeof this.Concurrent != 'function') ) this.Concurrent = new Object();
        if ( this.Concurrent.Thread === undefined ) this.Concurrent.Thread = undefined;
        with ( function(){
            with ( Data.Error ) {
                with ( Concurrent ) {

                    return function () {
                        var VERSION = '0.1.0';
                        var NAMESPACE;

                        /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Concurrent.Thread code.
 *
 * The Initial Developer of the Original Code is
 * Daisuke Maki.
 * Portions created by the Initial Developer are Copyright (C) 2006-2007
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */



                        NAMESPACE = 'Concurrent';








                        var current_thread = null;  // Retains the current thread.


                        function NoContinuationException ( r ) {
                            this.ret_val = r;
                        }

                        function initial_continuation_procedure ( ret_val ) {
                            throw new NoContinuationException(ret_val);
                        }

                        function NoExceptionHandlerException ( e ) {
                            this.thrown = e;
                        }

                        function initial_exception_handler ( e ) {
                            throw new NoExceptionHandlerException(e);
                        }

                        var initial_continuation = {
                            this_val : null,
                            procedure: initial_continuation_procedure,
                            exception: {
                                this_val : null,
                                procedure: initial_exception_handler
                            }
                        };
// Cyclic reference ensures that at least one exceptinal continuation always exists.
                        initial_continuation.exception.exception = initial_continuation.exception;




                        function Thread ( ) {
                            throw new Error("Thread cannot be instantiated directly.");
                        }

                        function THREAD ( t ) {
                            this._triplet      = t;  // {continuation:{...}, timeout:int|undefined, ret_val:any}
                            this._is_ended     = 0;  // 0:running, -1:throw, 1:return
                            this._join_thread  = null;
                            this._joined_list  = new Data.LinkedList();
                            this._timerID      = undefined;
                            standBy.call(this, 0);
                        }

                        var proto = THREAD.prototype = Thread.prototype;

                        +function(){
                            var name = "[object " + NAMESPACE + ".Thread]"
                            proto.toString = function ( ) {
                                return name;
                            };
                        }();


// Cancel timeout event.
                        function cancel ( ) {
                            if ( this._timerID ) {
                                clearTimeout(this._timerID);
                                this._timerID = undefined;
                            }
                        }

// Reserve execution of the next step after t msec.
                        function standBy ( t ) {
                            cancel.call(this);
                            var self = this;
                            this._timerID = setTimeout(
                                function(){ doNext.call(self); },
                                Number(t) || 2  // some version of IE occationally fails to
                                // context-switch with timeout interval less than 2.
                            );
                        }

// Cut "join" link.
                        function unjoin ( ) {
                            if ( this._join_thread ) {
                                var self = this;
                                var it = this._join_thread._joined_list.head().find(function( it ){
                                    return it === self;
                                });
                                it.remove();
                                this._join_thread = null;
                            }
                        }


                        Thread.TIME_SLICE = 20;

                        function doNext ( ) {
                            cancel.call(this);
                            var triplet = this._triplet;
                            this._triplet = null;
                            try {
                                current_thread = this;
                                var limit = (new Date).valueOf() + Thread.TIME_SLICE;
                                do {
                                    try {
                                        triplet = triplet.continuation.procedure.call(
                                            triplet.continuation.this_val, triplet.ret_val
                                        );
                                    } catch ( e ) {
                                        if ( e instanceof NoContinuationException ) {
                                            this._is_ended = 1;
                                            this._result   = e.ret_val;
                                            while ( !this._joined_list.isEmpty() ) {
                                                var it = this._joined_list.head().value();
                                                unjoin.call(it);
                                                it._triplet.ret_val = e.ret_val;
                                                standBy.call(it);
                                            }
                                            this._joined_list = null;
                                            return;
                                        } else if ( e instanceof NoExceptionHandlerException ) {
                                            e = e.thrown;
                                            var joined_list   = this._joined_list;
                                            this._joined_list = null;
                                            this._is_ended    = -1;
                                            this._result      = e;
                                            if ( !joined_list.isEmpty() ) {
                                                while ( !joined_list.isEmpty() ) {
                                                    joined_list.head().value().notify(e);  // "notify" implies "unjoin".
                                                }
                                            } else if ( !(e instanceof KillException) ) {
                                                throw e;
                                            }
                                            return;
                                        } else {
                                            triplet.continuation = triplet.continuation.exception;
                                            triplet.ret_val      = e;
                                        }
                                    }
                                } while ( triplet.timeout === undefined && (new Date).valueOf() < limit );
                            } finally {
                                current_thread = null;
                            }
                            this._triplet = triplet;
                            if ( triplet.timeout < 0 ) { /* Do nothing. */                   }
                            else                       { standBy.call(this, triplet.timeout); }
                        }


                        proto.notify = function ( e ) {
                            if ( current_thread === this ) throw e;
                            if ( this._is_ended ) throw new NotAliveError();
                            cancel.call(this);
                            unjoin.call(this);
                            this._triplet.continuation = this._triplet.continuation.exception;
                            this._triplet.ret_val = e;
                            standBy.call(this);
                            return e;
                        };

                        proto.kill = function ( s ) {
                            return this.notify( arguments.length ? new KillException(s) : new KillException() );
                        };

                        proto.join = function ( ) {
                            throw new Error("can't `join' in non-compiled functions");
                        };

                        proto.join.$Concurrent_Thread_compiled = function ( this_val, args, cont ) {
                            //!TODO: check cyclic-join
                            if ( this_val._is_ended > 0 ) {  // this thread has already ended normally
                                return { continuation:cont, ret_val:this_val._result, timeout:undefined };
                            } else if ( this_val._is_ended < 0 ) {  // this thread has already ended by exception
                                throw this_val._result;
                            } else {
                                this_val._joined_list.add(current_thread);
                                current_thread._join_thread = this_val;
                                return { continuation:cont, timeout:-1 };
                            }
                        };



                        Thread.create = function ( f /* , ... */ ) {
                            if ( typeof f != "function" ) throw new TypeError("can't create new thread from non-function value");
                            if ( typeof f.$Concurrent_Thread_compiled !== "function" ) f = this.compile(f);
                            return f.async(null, Array.prototype.slice.call(arguments, 1, arguments.length));
                        };


                        Thread.self = function ( ) {
                            return current_thread;
                        };


                        Thread.sleep = function ( ) {
                            throw new Error("can't `sleep' in non-compiled functions");
                        };

                        Thread.sleep.$Concurrent_Thread_compiled = function ( this_val, args, cont ) {
                            return { continuation: cont,
                                ret_val     : undefined,
                                timeout     : args[0] > 0 ? args[0] : 0 };
                        };


                        Thread.stop = function ( ) {
                            throw new Error("can't `stop' in non-compiled functions");
                        };

                        Thread.stop.$Concurrent_Thread_compiled = function ( this_val, args, cont ) {
                            return { continuation: cont,
                                ret_val     : undefined,
                                timeout     : -1        };
                        };


                        Thread.yield = function ( ) {
                            throw new Error("can't `yield' in non-compiled functions");
                        };

                        Thread.yield.$Concurrent_Thread_compiled = function ( this_val, args, cont ) {
                            return { continuation: cont,
                                ret_val     : undefined,
                                timeout     : 0         };
                        };


                        var KillException = Thread.KillException = Exception.extend(
                            function ( $super, message ) { $super(message); },
                            {
                                name   : NAMESPACE + ".Thread.KillException",
                                message: "thread killed"
                            }
                        );

                        var NotAliveError = Thread.NotAliveError = Error.extend(
                            function ( $super, message ) { $super(message); },
                            {
                                name   : NAMESPACE + ".Thread.NotAliveError",
                                message: "thread not alive"
                            }
                        );



// Extends Function object.
                        var proto = Function.prototype;

                        proto.apply.$Concurrent_Thread_compiled = function ( this_val, args, cont ) {
                            if ( typeof this_val.$Concurrent_Thread_compiled == "function" ) {
                                return this_val.$Concurrent_Thread_compiled(args[0], args[1], cont);
                            } else {
                                return { continuation: cont,
                                    ret_val     : this_val.apply(args[0], args[1]) };
                            }
                        };

                        proto.call.$Concurrent_Thread_compiled = function ( this_val, args, cont ) {
                            if ( typeof this_val.$Concurrent_Thread_compiled == "function" ) {
                                return this_val.$Concurrent_Thread_compiled(args[0], Array.prototype.slice.call(args, 1, args.length), cont);
                            } else {
                                return { continuation: cont,
                                    ret_val     : this_val.apply(args[0], Array.prototype.slice.call(args, 1, args.length)) };
                            }
                        };

                        proto.async = function ( this_val, args ) {
                            if ( typeof this.$Concurrent_Thread_compiled != "function" ) throw new Error("this is not a compiled function");
                            if ( args === void 0 ) args = [];  // IE6 does not allow null or undefined-value as the second argument of Function.prototype.apply. That does not conform to ECMA262-3!
                            return new THREAD(
                                this.$Concurrent_Thread_compiled(
                                    this_val,
                                    args,
                                    initial_continuation
                                )
                            );
                        };


                        return {
                            Thread: Thread
                        };
                    }();
                }
            }
        }.call(null) ) {
            this.Concurrent.Thread = Thread;
        }
    }).call(null);
    (function(){
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Cons || (typeof this.Data.Cons != 'object' && typeof this.Data.Cons != 'function') ) this.Data.Cons = new Object();
        if ( !this.Data.Cons.Util || (typeof this.Data.Cons.Util != 'object' && typeof this.Data.Cons.Util != 'function') ) this.Data.Cons.Util = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Error || (typeof this.Data.Error != 'object' && typeof this.Data.Error != 'function') ) this.Data.Error = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Cons || (typeof this.Data.Cons != 'object' && typeof this.Data.Cons != 'function') ) this.Data.Cons = new Object();
        if ( this.Data.Cons.Util.last === undefined ) this.Data.Cons.Util.last = undefined;
        if ( this.Data.Cons.Util.adder === undefined ) this.Data.Cons.Util.adder = undefined;
        if ( this.Data.Cons.Util.concat === undefined ) this.Data.Cons.Util.concat = undefined;
        with ( function(){
            with ( Data.Error ) {
                with ( Data.Cons ) {
                    with ( Data.Cons.Util ) {

                        return function () {
                            var VERSION = '0.0.0';
                            var NAMESPACE;

                            /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Data.Cons code.
 *
 * The Initial Developer of the Original Code is
 * Daisuke Maki.
 * Portions created by the Initial Developer are Copyright (C) 2007
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */



                            NAMESPACE = 'Data.Cons.Util';











                            function last ( c ) {
                                if ( !(c instanceof Cell) ) throw new TypeError("argument is not cons-list");
                                if ( c.isNil() ) return c;
                                if ( !(c.cdr instanceof Cell) ) throw new TypeError("argument is not cons-list");
                                while ( !c.cdr.isNil() ) {
                                    c = c.cdr;
                                    if ( !(c.cdr instanceof Cell) ) throw new TypeError("argument is not cons-list");
                                }
                                return c;
                            }



                            function adder ( c ) {
                                c = last(c);
                                if ( c.isNil() ) throw new IllegalStateError("can't append to nil");
                                return function ( /* variable arguments */ ) {
                                    c = last(c);
                                    for ( var i=0;  i < arguments.length;  i++ ) {
                                        c = c.cdr = new Cell(arguments[i], c.cdr);
                                    }
                                };
                            }



                            function concat ( /* variable arguments */ ) {
                                if ( arguments.length == 0 ) return nil();
                                var head = arguments[0];
                                var cell = last(head);
                                for ( var i=1;  i < arguments.length;  i++ ) {
                                    cell.cdr = arguments[i];
                                    cell = last(cell);
                                }
                                return head;
                            }


                            return {
                                adder: adder, concat: concat, last: last
                            };
                        }();
                    }
                }
            }
        }.call(null) ) {
            this.Data.Cons.Util.adder = adder;
            this.Data.Cons.Util.concat = concat;
            this.Data.Cons.Util.last = last;
        }
    }).call(null);
    (function(){
        if ( !this.Concurrent || (typeof this.Concurrent != 'object' && typeof this.Concurrent != 'function') ) this.Concurrent = new Object();
        if ( !this.Concurrent.Thread || (typeof this.Concurrent.Thread != 'object' && typeof this.Concurrent.Thread != 'function') ) this.Concurrent.Thread = new Object();
        if ( !this.Concurrent.Thread.Compiler || (typeof this.Concurrent.Thread.Compiler != 'object' && typeof this.Concurrent.Thread.Compiler != 'function') ) this.Concurrent.Thread.Compiler = new Object();
        if ( !this.Concurrent.Thread.Compiler.Kit || (typeof this.Concurrent.Thread.Compiler.Kit != 'object' && typeof this.Concurrent.Thread.Compiler.Kit != 'function') ) this.Concurrent.Thread.Compiler.Kit = new Object();
        if ( this.Concurrent.Thread.Compiler.Kit.printTrees === undefined ) this.Concurrent.Thread.Compiler.Kit.printTrees = undefined;
        if ( this.Concurrent.Thread.Compiler.Kit.codeBug === undefined ) this.Concurrent.Thread.Compiler.Kit.codeBug = undefined;
        with ( function(){
            with ( Concurrent.Thread.Compiler.Kit ) {

                return function () {
                    var VERSION = '0.0.0';
                    var NAMESPACE;

                    /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Rhino code, released
 * May 6, 1999.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1997-1999
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Igor Bukanov, igor@fastmail.fm
 *   Daisuke Maki
 *
 * Alternatively, the contents of this file may be used under the terms of
 * the GNU General Public License Version 2 or later (the "GPL"), in which
 * case the provisions of the GPL are applicable instead of those above. If
 * you wish to allow use of your version of this file only under the terms of
 * the GPL and not to allow others to use your version of this file under the
 * MPL, indicate your decision by deleting the provisions above and replacing
 * them with the notice and other provisions required by the GPL. If you do
 * not delete the provisions above, a recipient may use your version of this
 * file under either the MPL or the GPL.
 *
 * ***** END LICENSE BLOCK ***** */

                    /**
                     * This file is based on the file Kit.java in Rhino 1.6R5.
                     */




                    NAMESPACE = 'Concurrent.Thread.Compiler.Kit';








                    var printTrees = false;  // debug flag



                    function codeBug ( /* variable arguments */ ) {
                        var str = "";
                        for ( var i=0;  i < arguments.length;  i++ ) str += arguments[i];
                        var e = new Data.Error.IllegalStateError("FAILED ASSERTION: " + str);
                        var s = e.toString();
                        if ( e.stack ) s += "\n----------\n" + e.stack;
                        alert(s);
                        throw e;
                    }


                    return {
                        printTrees: printTrees, codeBug: codeBug
                    };
                }();
            }
        }.call(null) ) {
            this.Concurrent.Thread.Compiler.Kit.printTrees = printTrees;
            this.Concurrent.Thread.Compiler.Kit.codeBug = codeBug;
        }
    }).call(null);
    (function(){
        if ( !this.Concurrent || (typeof this.Concurrent != 'object' && typeof this.Concurrent != 'function') ) this.Concurrent = new Object();
        if ( !this.Concurrent.Thread || (typeof this.Concurrent.Thread != 'object' && typeof this.Concurrent.Thread != 'function') ) this.Concurrent.Thread = new Object();
        if ( !this.Concurrent.Thread.Compiler || (typeof this.Concurrent.Thread.Compiler != 'object' && typeof this.Concurrent.Thread.Compiler != 'function') ) this.Concurrent.Thread.Compiler = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Error || (typeof this.Data.Error != 'object' && typeof this.Data.Error != 'function') ) this.Data.Error = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Iterator || (typeof this.Data.Iterator != 'object' && typeof this.Data.Iterator != 'function') ) this.Data.Iterator = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Functional || (typeof this.Data.Functional != 'object' && typeof this.Data.Functional != 'function') ) this.Data.Functional = new Object();
        if ( this.Concurrent.Thread.Compiler.IdentifierSet === undefined ) this.Concurrent.Thread.Compiler.IdentifierSet = undefined;
        with ( function(){
            with ( Data.Error ) {
                with ( Data.Iterator ) {
                    with ( Data.Functional ) {
                        with ( Concurrent.Thread.Compiler ) {

                            return function () {
                                var VERSION ;
                                var NAMESPACE;

                                /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Concurrent.Thread code.
 *
 * The Initial Developer of the Original Code is
 * Daisuke Maki.
 * Portions created by the Initial Developer are Copyright (C) 2006-2007
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */


                                NAMESPACE = 'Concurrent.Thread.Compiler';













                                var MIN_INT = Math.pow(-2, 53);


                                function IdentifierSet ( ) {
                                    this._set      = {};
                                    this._state_no = MIN_INT;
                                }

                                var proto = IdentifierSet.prototype = new Set();
                                proto.constructor = IdentifierSet;


                                var hasOwnProperty = Object.prototype.hasOwnProperty;

                                proto.contains = function ( /* variable arguments */ ) {
                                    for ( var i=0;  i < arguments.length;  i++ ) {
                                        var id = arguments[i];
                                        if ( !(id instanceof Identifier) ) throw new TypeError("arguments[" + i + "] is not of type Identifier");
                                        // Because "hasOwnProperty" itself can be used as identifier,
                                        // we need to avoid "this._set.hasOwnProperty".
                                        if ( !hasOwnProperty.call(this._set, id.valueOf()) ) return false;
                                    }
                                    return true;
                                };


                                proto.add = function ( /* variable arguments */ ) {
                                    var changed = false;
                                    for ( var i=0;  i < arguments.length;  i++ ) {
                                        var id = arguments[i];
                                        if ( !(id instanceof Identifier) ) throw new TypeError("arguments[" + i + "] is not of type Identifier");
                                        var p = id.valueOf();
                                        if ( this._set[p] !== id ) {
                                            this._set[p] = id;
                                            this._state_no++;
                                            changed = true;
                                        }
                                    }
                                    return changed;
                                };


                                proto.remove = function ( /* variable arguments */ ) {
                                    var changed = false;
                                    for ( var i=0;  i < arguments.length;  i++ ) {
                                        var id = arguments[i];
                                        if ( !(id instanceof Identifier) ) throw new TypeError("argument is not of type Identifier");
                                        var p = id.valueOf();
                                        if ( hasOwnProperty.call(this._set, p) ) {
                                            delete this._set[p];
                                            this._state_no++;
                                            changed = true;
                                        }
                                    }
                                    return changed;
                                };


                                proto.toArray = function ( ) {
                                    var arr = [];
                                    for ( var i in this._set ) {
                                        if ( hasOwnProperty.call(this._set, i) ) arr.push(this._set[i]);
                                    }
                                    return arr;
                                };


                                proto.iterator = function ( ) {
                                    return new IdIterator(this, this.toArray(), 0);
                                };



                                function IdIterator ( parent, elems, index ) {
                                    this._parent = parent;
                                    this._elems  = elems;
                                    this._index  = index;
                                    this._state_no = parent._state_no;
                                }

                                var proto = IdIterator.prototype = new Iterator();
                                proto.constructor = IdIterator;

                                proto.isBoundTo = function ( o ) {
                                    return this._parent === o;
                                };

                                proto.isTail = function ( ) {
                                    if ( this._state_no !== this._parent._state_no ) throw new IllegalStateError("parent IdentifierSet object's state has been changed");
                                    return this._index >= this._elems.length;
                                };

                                proto.next = function ( ) {
                                    if ( this._state_no !== this._parent._state_no ) throw new IllegalStateError("parent IdentifierSet object's state has been changed");
                                    if ( this.isTail() ) throw new NoSuchElementError("no more element after the tail");
                                    return new IdIterator(this._parent, this._elems, this._index+1);
                                };

                                proto.value = function ( ) {
                                    if ( this._state_no !== this._parent._state_no ) throw new IllegalStateError("parent IdentifierSet object's state has been changed");
                                    return this._elems[this._index];
                                };

                                return {
                                    IdentifierSet: IdentifierSet
                                };
                            }();
                        }
                    }
                }
            }
        }.call(null) ) {
            this.Concurrent.Thread.Compiler.IdentifierSet = IdentifierSet;
        }
    }).call(null);
    (function(){
        if ( !this.Concurrent || (typeof this.Concurrent != 'object' && typeof this.Concurrent != 'function') ) this.Concurrent = new Object();
        if ( !this.Concurrent.Thread || (typeof this.Concurrent.Thread != 'object' && typeof this.Concurrent.Thread != 'function') ) this.Concurrent.Thread = new Object();
        if ( !this.Concurrent.Thread.Continuation || (typeof this.Concurrent.Thread.Continuation != 'object' && typeof this.Concurrent.Thread.Continuation != 'function') ) this.Concurrent.Thread.Continuation = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Error || (typeof this.Data.Error != 'object' && typeof this.Data.Error != 'function') ) this.Data.Error = new Object();
        if ( this.Concurrent.Thread.Continuation.callcc === undefined ) this.Concurrent.Thread.Continuation.callcc = undefined;
        if ( this.Concurrent.Thread.Continuation.getCC === undefined ) this.Concurrent.Thread.Continuation.getCC = undefined;
        if ( this.Concurrent.Thread.Continuation.currentContinuation === undefined ) this.Concurrent.Thread.Continuation.currentContinuation = undefined;
        if ( this.Concurrent.Thread.Continuation.ContinuationCalledException === undefined ) this.Concurrent.Thread.Continuation.ContinuationCalledException = undefined;
        with ( function(){
            with ( Data.Error ) {
                with ( Concurrent.Thread.Continuation ) {

                    return function () {
                        var VERSION = '0.0.0';
                        var NAMESPACE;

                        /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Concurrent.Thread code.
 *
 * The Initial Developer of the Original Code is
 * Daisuke Maki.
 * Portions created by the Initial Developer are Copyright (C) 2008
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */



                        NAMESPACE = 'Concurrent.Thread.Continuation';










                        function callcc ( ) {
                            throw new Error("can't call `" + NAMESPACE + ".callcc' in non-threaded functions");
                        }

                        callcc.$Concurrent_Thread_compiled = function ( $this, $args, $cont ) {
                            function continuation ( ) {
                                throw new Error("can't call any captured continuation in non-threaded functions");
                            }
                            continuation.$Concurrent_Thread_compiled = function ( $this, $args, _ ) {
                                return { continuation: $cont ,
                                    timeout     : void 0,
                                    ret_val     : $args[0] };
                            };
                            var f = $args[0];
                            return f && typeof f.$Concurrent_Thread_compiled === "function"
                                ?  f.$Concurrent_Thread_compiled(null, [continuation], $cont)
                                :  {continuation:$cont, ret_val:f(continuation), timeout:void 0};
                        };



                        function getCC ( ) {
                            throw new Error("can't call `" + NAMESPACE + ".getCC' in non-threaded functions");
                        }

                        getCC.$Concurrent_Thread_compiled = function ( $this, $args, $cont ) {
                            function continuation ( ) {
                                throw new Error("can't call any captured continuation in non-threaded functions");
                            }
                            continuation.$Concurrent_Thread_compiled = function ( $this, $args, _ ) {
                                return { continuation: $cont ,
                                    timeout     : void 0,
                                    ret_val     : $args[0] };
                            };
                            return {continuation:$cont, ret_val:continuation, timeout:void 0};
                        };



                        function currentContinuation ( ) {
                            throw new Error("can't call `" + NAMESPACE + ".currentContinuation' in non-threaded functions");
                        }

                        currentContinuation.$Concurrent_Thread_compiled = function ( $this, $args, $cont ) {
                            function continuation ( ) {
                                throw new Error("can't call any captured continuation in non-threaded functions");
                            }
                            continuation.$Concurrent_Thread_compiled = function ( $this, $args, _ ) {
                                return { continuation: $cont.exception,
                                    timeout     : void 0          ,
                                    ret_val     : new ContinuationCalledException($args) };
                            };
                            return { continuation: $cont ,
                                timeout     : void 0,
                                ret_val     : continuation };
                        };



                        var ContinuationCalledException = Exception.extend(
                            function ( $super, args ) {
                                $super("continuation called");
                                this.args = args;
                            },
                            { name: NAMESPACE + ".ContinuationCalledException" }
                        );

                        return {
                            ContinuationCalledException: ContinuationCalledException, callcc: callcc, getCC: getCC, currentContinuation: currentContinuation
                        };
                    }();
                }
            }
        }.call(null) ) {
            this.Concurrent.Thread.Continuation.ContinuationCalledException = ContinuationCalledException;
            this.Concurrent.Thread.Continuation.callcc = callcc;
            this.Concurrent.Thread.Continuation.getCC = getCC;
            this.Concurrent.Thread.Continuation.currentContinuation = currentContinuation;
        }
    }).call(null);
    (function(){
        if ( !this.Concurrent || (typeof this.Concurrent != 'object' && typeof this.Concurrent != 'function') ) this.Concurrent = new Object();
        if ( !this.Concurrent.Thread || (typeof this.Concurrent.Thread != 'object' && typeof this.Concurrent.Thread != 'function') ) this.Concurrent.Thread = new Object();
        if ( !this.Concurrent.Thread.Compiler || (typeof this.Concurrent.Thread.Compiler != 'object' && typeof this.Concurrent.Thread.Compiler != 'function') ) this.Concurrent.Thread.Compiler = new Object();
        if ( this.Concurrent.Thread.Compiler.ErrorReporter === undefined ) this.Concurrent.Thread.Compiler.ErrorReporter = undefined;
        with ( function(){
            with ( Concurrent.Thread.Compiler ) {

                return function () {
                    var VERSION ;
                    var NAMESPACE;

                    /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Rhino code, released
 * May 6, 1999.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1997-1999
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Norris Boyd
 *   Daisuke Maki
 *
 * Alternatively, the contents of this file may be used under the terms of
 * the GNU General Public License Version 2 or later (the "GPL"), in which
 * case the provisions of the GPL are applicable instead of those above. If
 * you wish to allow use of your version of this file only under the terms of
 * the GPL and not to allow others to use your version of this file under the
 * MPL, indicate your decision by deleting the provisions above and replacing
 * them with the notice and other provisions required by the GPL. If you do
 * not delete the provisions above, a recipient may use your version of this
 * file under either the MPL or the GPL.
 *
 * ***** END LICENSE BLOCK ***** */

                    /**
                     * This file is based on the file ErrorReporter.java in Rhino 1.6R5.
                     */

// API class


                    NAMESPACE = 'Concurrent.Thread.Compiler';



                    /**
                     * This is interface defines a protocol for the reporting of
                     * errors during JavaScript translation or execution.
                     *
                     * @author Norris Boyd
                     */


                    function ErrorReporter ( ) {
                        // This is kind of abstract class.
                        // It provides null-implementations for the methods as default.
                    }

                    var proto = ErrorReporter.prototype;


                    /**
                     * Report a warning.
                     *
                     * The implementing class may choose to ignore the warning
                     * if it desires.
                     *
                     * @param message a String describing the warning
                     * @param line the line number associated with the warning
                     * @param lineSource the text of the line (may be null)
                     * @param lineOffset the offset into lineSource where problem was detected
                     */
                    proto.warning = function ( message, line, lineSource, lineOffset ) { };


                    /**
                     * Report an error.
                     *
                     * The implementing class is free to throw an exception if
                     * it desires.
                     *
                     * If execution has not yet begun, the JavaScript engine is
                     * free to find additional errors rather than terminating
                     * the translation. It will not execute a script that had
                     * errors, however.
                     *
                     * @param message a String describing the error
                     * @param line the line number associated with the error
                     * @param lineSource the text of the line (may be null)
                     * @param lineOffset the offset into lineSource where problem was detected
                     */
                    proto.error   = function ( message, line, lineSource, lineOffset ) { };


                    return {
                        ErrorReporter: ErrorReporter
                    };
                }();
            }
        }.call(null) ) {
            this.Concurrent.Thread.Compiler.ErrorReporter = ErrorReporter;
        }
    }).call(null);
    (function(){
        if ( !this.Concurrent || (typeof this.Concurrent != 'object' && typeof this.Concurrent != 'function') ) this.Concurrent = new Object();
        if ( !this.Concurrent.Thread || (typeof this.Concurrent.Thread != 'object' && typeof this.Concurrent.Thread != 'function') ) this.Concurrent.Thread = new Object();
        if ( !this.Concurrent.Thread.Compiler || (typeof this.Concurrent.Thread.Compiler != 'object' && typeof this.Concurrent.Thread.Compiler != 'function') ) this.Concurrent.Thread.Compiler = new Object();
        if ( this.Concurrent.Thread.Compiler.isAlpha === undefined ) this.Concurrent.Thread.Compiler.isAlpha = undefined;
        if ( this.Concurrent.Thread.Compiler.isDigit === undefined ) this.Concurrent.Thread.Compiler.isDigit = undefined;
        if ( this.Concurrent.Thread.Compiler.isHexDigit === undefined ) this.Concurrent.Thread.Compiler.isHexDigit = undefined;
        if ( this.Concurrent.Thread.Compiler.isLineTerminator === undefined ) this.Concurrent.Thread.Compiler.isLineTerminator = undefined;
        if ( this.Concurrent.Thread.Compiler.isSpace === undefined ) this.Concurrent.Thread.Compiler.isSpace = undefined;
        if ( this.Concurrent.Thread.Compiler.isFormatChar === undefined ) this.Concurrent.Thread.Compiler.isFormatChar = undefined;
        if ( this.Concurrent.Thread.Compiler.isIdentifierStart === undefined ) this.Concurrent.Thread.Compiler.isIdentifierStart = undefined;
        if ( this.Concurrent.Thread.Compiler.isIdentifierPart === undefined ) this.Concurrent.Thread.Compiler.isIdentifierPart = undefined;
        with ( function(){
            with ( Concurrent.Thread.Compiler ) {

                return function () {
                    var VERSION = '0.0.0';
                    var NAMESPACE;

                    /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Concurrent.Thread code.
 *
 * The Initial Developer of the Original Code is
 * Daisuke Maki.
 * Portions created by the Initial Developer are Copyright (C) 2006-2007
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */



                    NAMESPACE = 'Concurrent.Thread.Compiler';





                    function isAlpha ( c )
                    {
                        c = c.charCodeAt(0);
                        // #generated# Last update: Tue, 01 Aug 2006 16:31:50 +0900
                        return c <= 0x5A ?
                            0x41 <= c :
                            0x61 <= c && c <= 0x7A;
                        // #/generated#
                    }



                    function isDigit ( c )
                    {
                        c = c.charCodeAt(0);
                        // #generated# Last update: Tue, 01 Aug 2006 21:02:15 +0900
                        return 0x30 <= c && c <= 0x39;
                        // #/generated#
                    }



                    function isHexDigit  ( c )
                    {
                        c = c.charCodeAt(0);
                        // #generated# Last update: Tue, 01 Aug 2006 15:49:52 +0900
                        return c <= 0x46 ?
                            c <= 0x39 ?
                                0x30 <= c :
                                0x41 <= c :
                            0x61 <= c && c <= 0x66;
                        // #/generated#
                    }



                    function isLineTerminator ( c ) {
                        switch ( c.charCodeAt(0) ) {
                            case 0x000A:  // Line Feed           <LF>
                            case 0x000D:  // Carriage Return     <CR>
                            case 0x2028:  // Line separator      <LS>
                            case 0x2029:  // Paragraph separator <PS>
                                return true;
                            default:
                                return false;
                        }
                    }



                    function isSpace ( c )
                    {
                        c = c.charCodeAt(0);
                        if ( c <= 255 ) {
                            switch ( c ) {
                                case 0x0009:  // Tab            <TAB>
                                case 0x000B:  // Vertical Tab   <VT>
                                case 0x000C:  // Form Feed      <FF>
                                case 0x0020:  // Space          <SP>
                                case 0x00A0:  // No-break space <NBSP>
                                    return true;
                                default:
                                    return false;
                            }
                        }
                        else {
                            // the following code is derived from the Unicode category Zs based on:
                            // http://www.unicode.org/Public/UNIDATA/extracted/DerivedGeneralCategory.txt
                            // #generated# Last update: Tue, 01 Aug 2006 01:57:18 +0900
                            return c <= 0x180E ?
                                c <= 0xA0 ?
                                    c <= 0x20 ?
                                        0x20 <= c :
                                        0xA0 <= c :
                                    c <= 0x1680 ?
                                        0x1680 <= c :
                                        0x180E <= c :
                                c <= 0x202F ?
                                    c <= 0x200A ?
                                        0x2000 <= c :
                                        0x202F <= c :
                                    c <= 0x205F ?
                                        0x205F <= c :
                                        c === 0x3000;
                            // #/generated#
                        }
                    }



                    function isFormatChar ( c )
                    {
                        c = c.charCodeAt(0);
                        if ( c <= 127 ) return false;  // optimization for ASCII characters
                        // the following code is derived from the Unicode category Cf based on:
                        // http://www.unicode.org/Public/UNIDATA/extracted/DerivedGeneralCategory.txt
                        // #generated# Last update: Tue, 01 Aug 2006 01:50:39 +0900
                        return c <= 0x202E ?
                            c <= 0x70F ?
                                c <= 0x603 ?
                                    c <= 0xAD ?
                                        0xAD <= c :
                                        0x600 <= c :
                                    c <= 0x6DD ?
                                        0x6DD <= c :
                                        0x70F <= c :
                                c <= 0x200F ?
                                    c <= 0x17B5 ?
                                        0x17B4 <= c :
                                        0x200B <= c :
                                    0x202A <= c :
                            c <= 0xFFFB ?
                                c <= 0x206F ?
                                    c <= 0x2063 ?
                                        0x2060 <= c :
                                        0x206A <= c :
                                    c <= 0xFEFF ?
                                        0xFEFF <= c :
                                        0xFFF9 <= c :
                                c <= 0xE0001 ?
                                    c <= 0x1D17A ?
                                        0x1D173 <= c :
                                        0xE0001 <= c :
                                    0xE0020 <= c && c <= 0xE007F;
                        // #/generated#
                    }



                    function isIdentifierStart ( c ) {
                        var c = c.charCodeAt(0);
                        switch ( c ) {
                            case 0x24:  // '$'
                            case 0x5F:  // '_'
                                return true;
                        }
                        // the following code is derived from the Unicode category Lu, Ll, Lt, Lm, Lo, and Nl based on:
                        // http://www.unicode.org/Public/UNIDATA/extracted/DerivedGeneralCategory.txt
                        // #generated# Last update: Tue, 01 Aug 2006 01:47:30 +0900
                        return c <= 0x1731 ?
                            c <= 0xB95 ?
                                c <= 0x961 ?
                                    c <= 0x587 ?
                                        c <= 0x37D ?
                                            c <= 0xD6 ?
                                                c <= 0xAA ?
                                                    c <= 0x7A ?
                                                        c <= 0x5A ?
                                                            0x41 <= c :
                                                            0x61 <= c :
                                                        0xAA <= c :
                                                    c <= 0xBA ?
                                                        c <= 0xB5 ?
                                                            0xB5 <= c :
                                                            0xBA <= c :
                                                        0xC0 <= c :
                                                c <= 0x2D1 ?
                                                    c <= 0x2C1 ?
                                                        c <= 0xF6 ?
                                                            0xD8 <= c :
                                                            0xF8 <= c :
                                                        0x2C6 <= c :
                                                    c <= 0x2EE ?
                                                        c <= 0x2E4 ?
                                                            0x2E0 <= c :
                                                            0x2EE <= c :
                                                        0x37A <= c :
                                            c <= 0x3F5 ?
                                                c <= 0x38C ?
                                                    c <= 0x38A ?
                                                        c <= 0x386 ?
                                                            0x386 <= c :
                                                            0x388 <= c :
                                                        0x38C <= c :
                                                    c <= 0x3CE ?
                                                        c <= 0x3A1 ?
                                                            0x38E <= c :
                                                            0x3A3 <= c :
                                                        0x3D0 <= c :
                                                c <= 0x556 ?
                                                    c <= 0x513 ?
                                                        c <= 0x481 ?
                                                            0x3F7 <= c :
                                                            0x48A <= c :
                                                        0x531 <= c :
                                                    c <= 0x559 ?
                                                        0x559 <= c :
                                                        0x561 <= c :
                                        c <= 0x710 ?
                                            c <= 0x6D3 ?
                                                c <= 0x63A ?
                                                    c <= 0x5F2 ?
                                                        c <= 0x5EA ?
                                                            0x5D0 <= c :
                                                            0x5F0 <= c :
                                                        0x621 <= c :
                                                    c <= 0x66F ?
                                                        c <= 0x64A ?
                                                            0x640 <= c :
                                                            0x66E <= c :
                                                        0x671 <= c :
                                                c <= 0x6EF ?
                                                    c <= 0x6E6 ?
                                                        c <= 0x6D5 ?
                                                            0x6D5 <= c :
                                                            0x6E5 <= c :
                                                        0x6EE <= c :
                                                    c <= 0x6FF ?
                                                        c <= 0x6FC ?
                                                            0x6FA <= c :
                                                            0x6FF <= c :
                                                        0x710 <= c :
                                            c <= 0x7F5 ?
                                                c <= 0x7A5 ?
                                                    c <= 0x76D ?
                                                        c <= 0x72F ?
                                                            0x712 <= c :
                                                            0x74D <= c :
                                                        0x780 <= c :
                                                    c <= 0x7EA ?
                                                        c <= 0x7B1 ?
                                                            0x7B1 <= c :
                                                            0x7CA <= c :
                                                        0x7F4 <= c :
                                                c <= 0x93D ?
                                                    c <= 0x939 ?
                                                        c <= 0x7FA ?
                                                            0x7FA <= c :
                                                            0x904 <= c :
                                                        0x93D <= c :
                                                    c <= 0x950 ?
                                                        0x950 <= c :
                                                        0x958 <= c :
                                    c <= 0xA8D ?
                                        c <= 0x9F1 ?
                                            c <= 0x9B2 ?
                                                c <= 0x990 ?
                                                    c <= 0x98C ?
                                                        c <= 0x97F ?
                                                            0x97B <= c :
                                                            0x985 <= c :
                                                        0x98F <= c :
                                                    c <= 0x9B0 ?
                                                        c <= 0x9A8 ?
                                                            0x993 <= c :
                                                            0x9AA <= c :
                                                        0x9B2 <= c :
                                                c <= 0x9CE ?
                                                    c <= 0x9BD ?
                                                        c <= 0x9B9 ?
                                                            0x9B6 <= c :
                                                            0x9BD <= c :
                                                        0x9CE <= c :
                                                    c <= 0x9E1 ?
                                                        c <= 0x9DD ?
                                                            0x9DC <= c :
                                                            0x9DF <= c :
                                                        0x9F0 <= c :
                                            c <= 0xA36 ?
                                                c <= 0xA28 ?
                                                    c <= 0xA10 ?
                                                        c <= 0xA0A ?
                                                            0xA05 <= c :
                                                            0xA0F <= c :
                                                        0xA13 <= c :
                                                    c <= 0xA33 ?
                                                        c <= 0xA30 ?
                                                            0xA2A <= c :
                                                            0xA32 <= c :
                                                        0xA35 <= c :
                                                c <= 0xA5E ?
                                                    c <= 0xA5C ?
                                                        c <= 0xA39 ?
                                                            0xA38 <= c :
                                                            0xA59 <= c :
                                                        0xA5E <= c :
                                                    c <= 0xA74 ?
                                                        0xA72 <= c :
                                                        0xA85 <= c :
                                        c <= 0xB28 ?
                                            c <= 0xABD ?
                                                c <= 0xAB0 ?
                                                    c <= 0xAA8 ?
                                                        c <= 0xA91 ?
                                                            0xA8F <= c :
                                                            0xA93 <= c :
                                                        0xAAA <= c :
                                                    c <= 0xAB9 ?
                                                        c <= 0xAB3 ?
                                                            0xAB2 <= c :
                                                            0xAB5 <= c :
                                                        0xABD <= c :
                                                c <= 0xB0C ?
                                                    c <= 0xAE1 ?
                                                        c <= 0xAD0 ?
                                                            0xAD0 <= c :
                                                            0xAE0 <= c :
                                                        0xB05 <= c :
                                                    c <= 0xB10 ?
                                                        0xB0F <= c :
                                                        0xB13 <= c :
                                            c <= 0xB61 ?
                                                c <= 0xB39 ?
                                                    c <= 0xB33 ?
                                                        c <= 0xB30 ?
                                                            0xB2A <= c :
                                                            0xB32 <= c :
                                                        0xB35 <= c :
                                                    c <= 0xB5D ?
                                                        c <= 0xB3D ?
                                                            0xB3D <= c :
                                                            0xB5C <= c :
                                                        0xB5F <= c :
                                                c <= 0xB8A ?
                                                    c <= 0xB83 ?
                                                        c <= 0xB71 ?
                                                            0xB71 <= c :
                                                            0xB83 <= c :
                                                        0xB85 <= c :
                                                    c <= 0xB90 ?
                                                        0xB8E <= c :
                                                        0xB92 <= c :
                                c <= 0xEB0 ?
                                    c <= 0xD28 ?
                                        c <= 0xC61 ?
                                            c <= 0xBB9 ?
                                                c <= 0xB9F ?
                                                    c <= 0xB9C ?
                                                        c <= 0xB9A ?
                                                            0xB99 <= c :
                                                            0xB9C <= c :
                                                        0xB9E <= c :
                                                    c <= 0xBAA ?
                                                        c <= 0xBA4 ?
                                                            0xBA3 <= c :
                                                            0xBA8 <= c :
                                                        0xBAE <= c :
                                                c <= 0xC28 ?
                                                    c <= 0xC10 ?
                                                        c <= 0xC0C ?
                                                            0xC05 <= c :
                                                            0xC0E <= c :
                                                        0xC12 <= c :
                                                    c <= 0xC39 ?
                                                        c <= 0xC33 ?
                                                            0xC2A <= c :
                                                            0xC35 <= c :
                                                        0xC60 <= c :
                                            c <= 0xCBD ?
                                                c <= 0xCA8 ?
                                                    c <= 0xC90 ?
                                                        c <= 0xC8C ?
                                                            0xC85 <= c :
                                                            0xC8E <= c :
                                                        0xC92 <= c :
                                                    c <= 0xCB9 ?
                                                        c <= 0xCB3 ?
                                                            0xCAA <= c :
                                                            0xCB5 <= c :
                                                        0xCBD <= c :
                                                c <= 0xD0C ?
                                                    c <= 0xCE1 ?
                                                        c <= 0xCDE ?
                                                            0xCDE <= c :
                                                            0xCE0 <= c :
                                                        0xD05 <= c :
                                                    c <= 0xD10 ?
                                                        0xD0E <= c :
                                                        0xD12 <= c :
                                        c <= 0xE82 ?
                                            c <= 0xDBD ?
                                                c <= 0xD96 ?
                                                    c <= 0xD61 ?
                                                        c <= 0xD39 ?
                                                            0xD2A <= c :
                                                            0xD60 <= c :
                                                        0xD85 <= c :
                                                    c <= 0xDBB ?
                                                        c <= 0xDB1 ?
                                                            0xD9A <= c :
                                                            0xDB3 <= c :
                                                        0xDBD <= c :
                                                c <= 0xE33 ?
                                                    c <= 0xE30 ?
                                                        c <= 0xDC6 ?
                                                            0xDC0 <= c :
                                                            0xE01 <= c :
                                                        0xE32 <= c :
                                                    c <= 0xE46 ?
                                                        0xE40 <= c :
                                                        0xE81 <= c :
                                            c <= 0xE9F ?
                                                c <= 0xE8A ?
                                                    c <= 0xE88 ?
                                                        c <= 0xE84 ?
                                                            0xE84 <= c :
                                                            0xE87 <= c :
                                                        0xE8A <= c :
                                                    c <= 0xE97 ?
                                                        c <= 0xE8D ?
                                                            0xE8D <= c :
                                                            0xE94 <= c :
                                                        0xE99 <= c :
                                                c <= 0xEA7 ?
                                                    c <= 0xEA5 ?
                                                        c <= 0xEA3 ?
                                                            0xEA1 <= c :
                                                            0xEA5 <= c :
                                                        0xEA7 <= c :
                                                    c <= 0xEAB ?
                                                        0xEAA <= c :
                                                        0xEAD <= c :
                                    c <= 0x1258 ?
                                        c <= 0x102A ?
                                            c <= 0xF00 ?
                                                c <= 0xEC4 ?
                                                    c <= 0xEBD ?
                                                        c <= 0xEB3 ?
                                                            0xEB2 <= c :
                                                            0xEBD <= c :
                                                        0xEC0 <= c :
                                                    c <= 0xEDD ?
                                                        c <= 0xEC6 ?
                                                            0xEC6 <= c :
                                                            0xEDC <= c :
                                                        0xF00 <= c :
                                                c <= 0xF8B ?
                                                    c <= 0xF6A ?
                                                        c <= 0xF47 ?
                                                            0xF40 <= c :
                                                            0xF49 <= c :
                                                        0xF88 <= c :
                                                    c <= 0x1027 ?
                                                        c <= 0x1021 ?
                                                            0x1000 <= c :
                                                            0x1023 <= c :
                                                        0x1029 <= c :
                                            c <= 0x11A2 ?
                                                c <= 0x10FA ?
                                                    c <= 0x10C5 ?
                                                        c <= 0x1055 ?
                                                            0x1050 <= c :
                                                            0x10A0 <= c :
                                                        0x10D0 <= c :
                                                    c <= 0x1159 ?
                                                        c <= 0x10FC ?
                                                            0x10FC <= c :
                                                            0x1100 <= c :
                                                        0x115F <= c :
                                                c <= 0x124D ?
                                                    c <= 0x1248 ?
                                                        c <= 0x11F9 ?
                                                            0x11A8 <= c :
                                                            0x1200 <= c :
                                                        0x124A <= c :
                                                    c <= 0x1256 ?
                                                        0x1250 <= c :
                                                        0x1258 <= c :
                                        c <= 0x1315 ?
                                            c <= 0x12BE ?
                                                c <= 0x128D ?
                                                    c <= 0x1288 ?
                                                        c <= 0x125D ?
                                                            0x125A <= c :
                                                            0x1260 <= c :
                                                        0x128A <= c :
                                                    c <= 0x12B5 ?
                                                        c <= 0x12B0 ?
                                                            0x1290 <= c :
                                                            0x12B2 <= c :
                                                        0x12B8 <= c :
                                                c <= 0x12D6 ?
                                                    c <= 0x12C5 ?
                                                        c <= 0x12C0 ?
                                                            0x12C0 <= c :
                                                            0x12C2 <= c :
                                                        0x12C8 <= c :
                                                    c <= 0x1310 ?
                                                        0x12D8 <= c :
                                                        0x1312 <= c :
                                            c <= 0x169A ?
                                                c <= 0x13F4 ?
                                                    c <= 0x138F ?
                                                        c <= 0x135A ?
                                                            0x1318 <= c :
                                                            0x1380 <= c :
                                                        0x13A0 <= c :
                                                    c <= 0x1676 ?
                                                        c <= 0x166C ?
                                                            0x1401 <= c :
                                                            0x166F <= c :
                                                        0x1681 <= c :
                                                c <= 0x170C ?
                                                    c <= 0x16F0 ?
                                                        c <= 0x16EA ?
                                                            0x16A0 <= c :
                                                            0x16EE <= c :
                                                        0x1700 <= c :
                                                    c <= 0x1711 ?
                                                        0x170E <= c :
                                                        0x1720 <= c :
                            c <= 0xA805 ?
                                c <= 0x2115 ?
                                    c <= 0x1F4D ?
                                        c <= 0x19A9 ?
                                            c <= 0x17DC ?
                                                c <= 0x1770 ?
                                                    c <= 0x176C ?
                                                        c <= 0x1751 ?
                                                            0x1740 <= c :
                                                            0x1760 <= c :
                                                        0x176E <= c :
                                                    c <= 0x17D7 ?
                                                        c <= 0x17B3 ?
                                                            0x1780 <= c :
                                                            0x17D7 <= c :
                                                        0x17DC <= c :
                                                c <= 0x191C ?
                                                    c <= 0x18A8 ?
                                                        c <= 0x1877 ?
                                                            0x1820 <= c :
                                                            0x1880 <= c :
                                                        0x1900 <= c :
                                                    c <= 0x1974 ?
                                                        c <= 0x196D ?
                                                            0x1950 <= c :
                                                            0x1970 <= c :
                                                        0x1980 <= c :
                                            c <= 0x1E9B ?
                                                c <= 0x1B33 ?
                                                    c <= 0x1A16 ?
                                                        c <= 0x19C7 ?
                                                            0x19C1 <= c :
                                                            0x1A00 <= c :
                                                        0x1B05 <= c :
                                                    c <= 0x1DBF ?
                                                        c <= 0x1B4B ?
                                                            0x1B45 <= c :
                                                            0x1D00 <= c :
                                                        0x1E00 <= c :
                                                c <= 0x1F1D ?
                                                    c <= 0x1F15 ?
                                                        c <= 0x1EF9 ?
                                                            0x1EA0 <= c :
                                                            0x1F00 <= c :
                                                        0x1F18 <= c :
                                                    c <= 0x1F45 ?
                                                        0x1F20 <= c :
                                                        0x1F48 <= c :
                                        c <= 0x1FD3 ?
                                            c <= 0x1FB4 ?
                                                c <= 0x1F5B ?
                                                    c <= 0x1F59 ?
                                                        c <= 0x1F57 ?
                                                            0x1F50 <= c :
                                                            0x1F59 <= c :
                                                        0x1F5B <= c :
                                                    c <= 0x1F7D ?
                                                        c <= 0x1F5D ?
                                                            0x1F5D <= c :
                                                            0x1F5F <= c :
                                                        0x1F80 <= c :
                                                c <= 0x1FC4 ?
                                                    c <= 0x1FBE ?
                                                        c <= 0x1FBC ?
                                                            0x1FB6 <= c :
                                                            0x1FBE <= c :
                                                        0x1FC2 <= c :
                                                    c <= 0x1FCC ?
                                                        0x1FC6 <= c :
                                                        0x1FD0 <= c :
                                            c <= 0x207F ?
                                                c <= 0x1FF4 ?
                                                    c <= 0x1FEC ?
                                                        c <= 0x1FDB ?
                                                            0x1FD6 <= c :
                                                            0x1FE0 <= c :
                                                        0x1FF2 <= c :
                                                    c <= 0x2071 ?
                                                        c <= 0x1FFC ?
                                                            0x1FF6 <= c :
                                                            0x2071 <= c :
                                                        0x207F <= c :
                                                c <= 0x2107 ?
                                                    c <= 0x2102 ?
                                                        c <= 0x2094 ?
                                                            0x2090 <= c :
                                                            0x2102 <= c :
                                                        0x2107 <= c :
                                                    c <= 0x2113 ?
                                                        0x210A <= c :
                                                        0x2115 <= c :
                                    c <= 0x2DBE ?
                                        c <= 0x2C5E ?
                                            c <= 0x2139 ?
                                                c <= 0x2126 ?
                                                    c <= 0x2124 ?
                                                        c <= 0x211D ?
                                                            0x2119 <= c :
                                                            0x2124 <= c :
                                                        0x2126 <= c :
                                                    c <= 0x212D ?
                                                        c <= 0x2128 ?
                                                            0x2128 <= c :
                                                            0x212A <= c :
                                                        0x212F <= c :
                                                c <= 0x214E ?
                                                    c <= 0x2149 ?
                                                        c <= 0x213F ?
                                                            0x213C <= c :
                                                            0x2145 <= c :
                                                        0x214E <= c :
                                                    c <= 0x2C2E ?
                                                        c <= 0x2184 ?
                                                            0x2160 <= c :
                                                            0x2C00 <= c :
                                                        0x2C30 <= c :
                                            c <= 0x2D6F ?
                                                c <= 0x2CE4 ?
                                                    c <= 0x2C77 ?
                                                        c <= 0x2C6C ?
                                                            0x2C60 <= c :
                                                            0x2C74 <= c :
                                                        0x2C80 <= c :
                                                    c <= 0x2D65 ?
                                                        c <= 0x2D25 ?
                                                            0x2D00 <= c :
                                                            0x2D30 <= c :
                                                        0x2D6F <= c :
                                                c <= 0x2DAE ?
                                                    c <= 0x2DA6 ?
                                                        c <= 0x2D96 ?
                                                            0x2D80 <= c :
                                                            0x2DA0 <= c :
                                                        0x2DA8 <= c :
                                                    c <= 0x2DB6 ?
                                                        0x2DB0 <= c :
                                                        0x2DB8 <= c :
                                        c <= 0x30FA ?
                                            c <= 0x3029 ?
                                                c <= 0x2DD6 ?
                                                    c <= 0x2DCE ?
                                                        c <= 0x2DC6 ?
                                                            0x2DC0 <= c :
                                                            0x2DC8 <= c :
                                                        0x2DD0 <= c :
                                                    c <= 0x3007 ?
                                                        c <= 0x2DDE ?
                                                            0x2DD8 <= c :
                                                            0x3005 <= c :
                                                        0x3021 <= c :
                                                c <= 0x3096 ?
                                                    c <= 0x303C ?
                                                        c <= 0x3035 ?
                                                            0x3031 <= c :
                                                            0x3038 <= c :
                                                        0x3041 <= c :
                                                    c <= 0x309F ?
                                                        0x309D <= c :
                                                        0x30A1 <= c :
                                            c <= 0x4DB5 ?
                                                c <= 0x318E ?
                                                    c <= 0x312C ?
                                                        c <= 0x30FF ?
                                                            0x30FC <= c :
                                                            0x3105 <= c :
                                                        0x3131 <= c :
                                                    c <= 0x31FF ?
                                                        c <= 0x31B7 ?
                                                            0x31A0 <= c :
                                                            0x31F0 <= c :
                                                        0x3400 <= c :
                                                c <= 0xA71A ?
                                                    c <= 0xA48C ?
                                                        c <= 0x9FBB ?
                                                            0x4E00 <= c :
                                                            0xA000 <= c :
                                                        0xA717 <= c :
                                                    c <= 0xA801 ?
                                                        0xA800 <= c :
                                                        0xA803 <= c :
                                c <= 0x1049D ?
                                    c <= 0xFEFC ?
                                        c <= 0xFB36 ?
                                            c <= 0xFA6A ?
                                                c <= 0xA873 ?
                                                    c <= 0xA822 ?
                                                        c <= 0xA80A ?
                                                            0xA807 <= c :
                                                            0xA80C <= c :
                                                        0xA840 <= c :
                                                    c <= 0xFA2D ?
                                                        c <= 0xD7A3 ?
                                                            0xAC00 <= c :
                                                            0xF900 <= c :
                                                        0xFA30 <= c :
                                                c <= 0xFB17 ?
                                                    c <= 0xFB06 ?
                                                        c <= 0xFAD9 ?
                                                            0xFA70 <= c :
                                                            0xFB00 <= c :
                                                        0xFB13 <= c :
                                                    c <= 0xFB28 ?
                                                        c <= 0xFB1D ?
                                                            0xFB1D <= c :
                                                            0xFB1F <= c :
                                                        0xFB2A <= c :
                                            c <= 0xFD3D ?
                                                c <= 0xFB41 ?
                                                    c <= 0xFB3E ?
                                                        c <= 0xFB3C ?
                                                            0xFB38 <= c :
                                                            0xFB3E <= c :
                                                        0xFB40 <= c :
                                                    c <= 0xFBB1 ?
                                                        c <= 0xFB44 ?
                                                            0xFB43 <= c :
                                                            0xFB46 <= c :
                                                        0xFBD3 <= c :
                                                c <= 0xFDFB ?
                                                    c <= 0xFDC7 ?
                                                        c <= 0xFD8F ?
                                                            0xFD50 <= c :
                                                            0xFD92 <= c :
                                                        0xFDF0 <= c :
                                                    c <= 0xFE74 ?
                                                        0xFE70 <= c :
                                                        0xFE76 <= c :
                                        c <= 0x1003D ?
                                            c <= 0xFFD7 ?
                                                c <= 0xFFBE ?
                                                    c <= 0xFF5A ?
                                                        c <= 0xFF3A ?
                                                            0xFF21 <= c :
                                                            0xFF41 <= c :
                                                        0xFF66 <= c :
                                                    c <= 0xFFCF ?
                                                        c <= 0xFFC7 ?
                                                            0xFFC2 <= c :
                                                            0xFFCA <= c :
                                                        0xFFD2 <= c :
                                                c <= 0x10026 ?
                                                    c <= 0x1000B ?
                                                        c <= 0xFFDC ?
                                                            0xFFDA <= c :
                                                            0x10000 <= c :
                                                        0x1000D <= c :
                                                    c <= 0x1003A ?
                                                        0x10028 <= c :
                                                        0x1003C <= c :
                                            c <= 0x1034A ?
                                                c <= 0x100FA ?
                                                    c <= 0x1005D ?
                                                        c <= 0x1004D ?
                                                            0x1003F <= c :
                                                            0x10050 <= c :
                                                        0x10080 <= c :
                                                    c <= 0x1031E ?
                                                        c <= 0x10174 ?
                                                            0x10140 <= c :
                                                            0x10300 <= c :
                                                        0x10330 <= c :
                                                c <= 0x103CF ?
                                                    c <= 0x103C3 ?
                                                        c <= 0x1039D ?
                                                            0x10380 <= c :
                                                            0x103A0 <= c :
                                                        0x103C8 <= c :
                                                    c <= 0x103D5 ?
                                                        0x103D1 <= c :
                                                        0x10400 <= c :
                                    c <= 0x1D505 ?
                                        c <= 0x1236E ?
                                            c <= 0x1083F ?
                                                c <= 0x10835 ?
                                                    c <= 0x10808 ?
                                                        c <= 0x10805 ?
                                                            0x10800 <= c :
                                                            0x10808 <= c :
                                                        0x1080A <= c :
                                                    c <= 0x1083C ?
                                                        c <= 0x10838 ?
                                                            0x10837 <= c :
                                                            0x1083C <= c :
                                                        0x1083F <= c :
                                                c <= 0x10A13 ?
                                                    c <= 0x10A00 ?
                                                        c <= 0x10915 ?
                                                            0x10900 <= c :
                                                            0x10A00 <= c :
                                                        0x10A10 <= c :
                                                    c <= 0x10A33 ?
                                                        c <= 0x10A17 ?
                                                            0x10A15 <= c :
                                                            0x10A19 <= c :
                                                        0x12000 <= c :
                                            c <= 0x1D4A6 ?
                                                c <= 0x1D49C ?
                                                    c <= 0x1D454 ?
                                                        c <= 0x12462 ?
                                                            0x12400 <= c :
                                                            0x1D400 <= c :
                                                        0x1D456 <= c :
                                                    c <= 0x1D4A2 ?
                                                        c <= 0x1D49F ?
                                                            0x1D49E <= c :
                                                            0x1D4A2 <= c :
                                                        0x1D4A5 <= c :
                                                c <= 0x1D4BB ?
                                                    c <= 0x1D4B9 ?
                                                        c <= 0x1D4AC ?
                                                            0x1D4A9 <= c :
                                                            0x1D4AE <= c :
                                                        0x1D4BB <= c :
                                                    c <= 0x1D4C3 ?
                                                        0x1D4BD <= c :
                                                        0x1D4C5 <= c :
                                        c <= 0x1D6DA ?
                                            c <= 0x1D544 ?
                                                c <= 0x1D51C ?
                                                    c <= 0x1D514 ?
                                                        c <= 0x1D50A ?
                                                            0x1D507 <= c :
                                                            0x1D50D <= c :
                                                        0x1D516 <= c :
                                                    c <= 0x1D53E ?
                                                        c <= 0x1D539 ?
                                                            0x1D51E <= c :
                                                            0x1D53B <= c :
                                                        0x1D540 <= c :
                                                c <= 0x1D6A5 ?
                                                    c <= 0x1D550 ?
                                                        c <= 0x1D546 ?
                                                            0x1D546 <= c :
                                                            0x1D54A <= c :
                                                        0x1D552 <= c :
                                                    c <= 0x1D6C0 ?
                                                        0x1D6A8 <= c :
                                                        0x1D6C2 <= c :
                                            c <= 0x1D788 ?
                                                c <= 0x1D734 ?
                                                    c <= 0x1D714 ?
                                                        c <= 0x1D6FA ?
                                                            0x1D6DC <= c :
                                                            0x1D6FC <= c :
                                                        0x1D716 <= c :
                                                    c <= 0x1D76E ?
                                                        c <= 0x1D74E ?
                                                            0x1D736 <= c :
                                                            0x1D750 <= c :
                                                        0x1D770 <= c :
                                                c <= 0x1D7CB ?
                                                    c <= 0x1D7C2 ?
                                                        c <= 0x1D7A8 ?
                                                            0x1D78A <= c :
                                                            0x1D7AA <= c :
                                                        0x1D7C4 <= c :
                                                    c <= 0x2A6D6 ?
                                                        0x20000 <= c :
                                                        0x2F800 <= c && c <= 0x2FA1D;
                        // #/generated#
                    }



                    function isIdentifierPart ( c ) {
                        var c = c.charCodeAt(0);
                        switch ( c ) {
                            case 0x24:  // '$'
                            case 0x5F:  // '_'
                                return true;
                        }
                        // the following code is derived from the Unicode category Lu, Ll, Lt, Lm, Lo, Nl, Mn, Mc, Nd, and Pc based on:
                        // http://www.unicode.org/Public/UNIDATA/extracted/DerivedGeneralCategory.txt
                        // #generated# Last update: Tue, 01 Aug 2006 02:00:01 +0900
                        return c <= 0x12B0 ?
                            c <= 0xB90 ?
                                c <= 0x990 ?
                                    c <= 0x5BF ?
                                        c <= 0x37D ?
                                            c <= 0xD6 ?
                                                c <= 0x7A ?
                                                    c <= 0x5A ?
                                                        c <= 0x39 ?
                                                            0x30 <= c :
                                                            0x41 <= c :
                                                        c <= 0x5F ?
                                                            0x5F <= c :
                                                            0x61 <= c :
                                                    c <= 0xB5 ?
                                                        c <= 0xAA ?
                                                            0xAA <= c :
                                                            0xB5 <= c :
                                                        c <= 0xBA ?
                                                            0xBA <= c :
                                                            0xC0 <= c :
                                                c <= 0x2E4 ?
                                                    c <= 0x2C1 ?
                                                        c <= 0xF6 ?
                                                            0xD8 <= c :
                                                            0xF8 <= c :
                                                        c <= 0x2D1 ?
                                                            0x2C6 <= c :
                                                            0x2E0 <= c :
                                                    c <= 0x36F ?
                                                        c <= 0x2EE ?
                                                            0x2EE <= c :
                                                            0x300 <= c :
                                                        0x37A <= c :
                                            c <= 0x481 ?
                                                c <= 0x3A1 ?
                                                    c <= 0x38A ?
                                                        c <= 0x386 ?
                                                            0x386 <= c :
                                                            0x388 <= c :
                                                        c <= 0x38C ?
                                                            0x38C <= c :
                                                            0x38E <= c :
                                                    c <= 0x3F5 ?
                                                        c <= 0x3CE ?
                                                            0x3A3 <= c :
                                                            0x3D0 <= c :
                                                        0x3F7 <= c :
                                                c <= 0x559 ?
                                                    c <= 0x513 ?
                                                        c <= 0x486 ?
                                                            0x483 <= c :
                                                            0x48A <= c :
                                                        c <= 0x556 ?
                                                            0x531 <= c :
                                                            0x559 <= c :
                                                    c <= 0x5BD ?
                                                        c <= 0x587 ?
                                                            0x561 <= c :
                                                            0x591 <= c :
                                                        0x5BF <= c :
                                        c <= 0x6FF ?
                                            c <= 0x63A ?
                                                c <= 0x5EA ?
                                                    c <= 0x5C5 ?
                                                        c <= 0x5C2 ?
                                                            0x5C1 <= c :
                                                            0x5C4 <= c :
                                                        c <= 0x5C7 ?
                                                            0x5C7 <= c :
                                                            0x5D0 <= c :
                                                    c <= 0x615 ?
                                                        c <= 0x5F2 ?
                                                            0x5F0 <= c :
                                                            0x610 <= c :
                                                        0x621 <= c :
                                                c <= 0x6DC ?
                                                    c <= 0x669 ?
                                                        c <= 0x65E ?
                                                            0x640 <= c :
                                                            0x660 <= c :
                                                        c <= 0x6D3 ?
                                                            0x66E <= c :
                                                            0x6D5 <= c :
                                                    c <= 0x6FC ?
                                                        c <= 0x6E8 ?
                                                            0x6DF <= c :
                                                            0x6EA <= c :
                                                        0x6FF <= c :
                                            c <= 0x94D ?
                                                c <= 0x7F5 ?
                                                    c <= 0x76D ?
                                                        c <= 0x74A ?
                                                            0x710 <= c :
                                                            0x74D <= c :
                                                        c <= 0x7B1 ?
                                                            0x780 <= c :
                                                            0x7C0 <= c :
                                                    c <= 0x939 ?
                                                        c <= 0x7FA ?
                                                            0x7FA <= c :
                                                            0x901 <= c :
                                                        0x93C <= c :
                                                c <= 0x97F ?
                                                    c <= 0x963 ?
                                                        c <= 0x954 ?
                                                            0x950 <= c :
                                                            0x958 <= c :
                                                        c <= 0x96F ?
                                                            0x966 <= c :
                                                            0x97B <= c :
                                                    c <= 0x98C ?
                                                        c <= 0x983 ?
                                                            0x981 <= c :
                                                            0x985 <= c :
                                                        0x98F <= c :
                                    c <= 0xA91 ?
                                        c <= 0xA28 ?
                                            c <= 0x9D7 ?
                                                c <= 0x9B9 ?
                                                    c <= 0x9B0 ?
                                                        c <= 0x9A8 ?
                                                            0x993 <= c :
                                                            0x9AA <= c :
                                                        c <= 0x9B2 ?
                                                            0x9B2 <= c :
                                                            0x9B6 <= c :
                                                    c <= 0x9C8 ?
                                                        c <= 0x9C4 ?
                                                            0x9BC <= c :
                                                            0x9C7 <= c :
                                                        c <= 0x9CE ?
                                                            0x9CB <= c :
                                                            0x9D7 <= c :
                                                c <= 0xA03 ?
                                                    c <= 0x9E3 ?
                                                        c <= 0x9DD ?
                                                            0x9DC <= c :
                                                            0x9DF <= c :
                                                        c <= 0x9F1 ?
                                                            0x9E6 <= c :
                                                            0xA01 <= c :
                                                    c <= 0xA10 ?
                                                        c <= 0xA0A ?
                                                            0xA05 <= c :
                                                            0xA0F <= c :
                                                        0xA13 <= c :
                                            c <= 0xA48 ?
                                                c <= 0xA39 ?
                                                    c <= 0xA33 ?
                                                        c <= 0xA30 ?
                                                            0xA2A <= c :
                                                            0xA32 <= c :
                                                        c <= 0xA36 ?
                                                            0xA35 <= c :
                                                            0xA38 <= c :
                                                    c <= 0xA42 ?
                                                        c <= 0xA3C ?
                                                            0xA3C <= c :
                                                            0xA3E <= c :
                                                        0xA47 <= c :
                                                c <= 0xA74 ?
                                                    c <= 0xA5C ?
                                                        c <= 0xA4D ?
                                                            0xA4B <= c :
                                                            0xA59 <= c :
                                                        c <= 0xA5E ?
                                                            0xA5E <= c :
                                                            0xA66 <= c :
                                                    c <= 0xA8D ?
                                                        c <= 0xA83 ?
                                                            0xA81 <= c :
                                                            0xA85 <= c :
                                                        0xA8F <= c :
                                        c <= 0xB28 ?
                                            c <= 0xACD ?
                                                c <= 0xAB9 ?
                                                    c <= 0xAB0 ?
                                                        c <= 0xAA8 ?
                                                            0xA93 <= c :
                                                            0xAAA <= c :
                                                        c <= 0xAB3 ?
                                                            0xAB2 <= c :
                                                            0xAB5 <= c :
                                                    c <= 0xAC9 ?
                                                        c <= 0xAC5 ?
                                                            0xABC <= c :
                                                            0xAC7 <= c :
                                                        0xACB <= c :
                                                c <= 0xB03 ?
                                                    c <= 0xAE3 ?
                                                        c <= 0xAD0 ?
                                                            0xAD0 <= c :
                                                            0xAE0 <= c :
                                                        c <= 0xAEF ?
                                                            0xAE6 <= c :
                                                            0xB01 <= c :
                                                    c <= 0xB10 ?
                                                        c <= 0xB0C ?
                                                            0xB05 <= c :
                                                            0xB0F <= c :
                                                        0xB13 <= c :
                                            c <= 0xB57 ?
                                                c <= 0xB43 ?
                                                    c <= 0xB33 ?
                                                        c <= 0xB30 ?
                                                            0xB2A <= c :
                                                            0xB32 <= c :
                                                        c <= 0xB39 ?
                                                            0xB35 <= c :
                                                            0xB3C <= c :
                                                    c <= 0xB4D ?
                                                        c <= 0xB48 ?
                                                            0xB47 <= c :
                                                            0xB4B <= c :
                                                        0xB56 <= c :
                                                c <= 0xB71 ?
                                                    c <= 0xB61 ?
                                                        c <= 0xB5D ?
                                                            0xB5C <= c :
                                                            0xB5F <= c :
                                                        c <= 0xB6F ?
                                                            0xB66 <= c :
                                                            0xB71 <= c :
                                                    c <= 0xB8A ?
                                                        c <= 0xB83 ?
                                                            0xB82 <= c :
                                                            0xB85 <= c :
                                                        0xB8E <= c :
                                c <= 0xDD6 ?
                                    c <= 0xCB3 ?
                                        c <= 0xC10 ?
                                            c <= 0xBC2 ?
                                                c <= 0xB9F ?
                                                    c <= 0xB9A ?
                                                        c <= 0xB95 ?
                                                            0xB92 <= c :
                                                            0xB99 <= c :
                                                        c <= 0xB9C ?
                                                            0xB9C <= c :
                                                            0xB9E <= c :
                                                    c <= 0xBAA ?
                                                        c <= 0xBA4 ?
                                                            0xBA3 <= c :
                                                            0xBA8 <= c :
                                                        c <= 0xBB9 ?
                                                            0xBAE <= c :
                                                            0xBBE <= c :
                                                c <= 0xBEF ?
                                                    c <= 0xBCD ?
                                                        c <= 0xBC8 ?
                                                            0xBC6 <= c :
                                                            0xBCA <= c :
                                                        c <= 0xBD7 ?
                                                            0xBD7 <= c :
                                                            0xBE6 <= c :
                                                    c <= 0xC0C ?
                                                        c <= 0xC03 ?
                                                            0xC01 <= c :
                                                            0xC05 <= c :
                                                        0xC0E <= c :
                                            c <= 0xC56 ?
                                                c <= 0xC44 ?
                                                    c <= 0xC33 ?
                                                        c <= 0xC28 ?
                                                            0xC12 <= c :
                                                            0xC2A <= c :
                                                        c <= 0xC39 ?
                                                            0xC35 <= c :
                                                            0xC3E <= c :
                                                    c <= 0xC4D ?
                                                        c <= 0xC48 ?
                                                            0xC46 <= c :
                                                            0xC4A <= c :
                                                        0xC55 <= c :
                                                c <= 0xC8C ?
                                                    c <= 0xC6F ?
                                                        c <= 0xC61 ?
                                                            0xC60 <= c :
                                                            0xC66 <= c :
                                                        c <= 0xC83 ?
                                                            0xC82 <= c :
                                                            0xC85 <= c :
                                                    c <= 0xCA8 ?
                                                        c <= 0xC90 ?
                                                            0xC8E <= c :
                                                            0xC92 <= c :
                                                        0xCAA <= c :
                                        c <= 0xD43 ?
                                            c <= 0xCE3 ?
                                                c <= 0xCCD ?
                                                    c <= 0xCC4 ?
                                                        c <= 0xCB9 ?
                                                            0xCB5 <= c :
                                                            0xCBC <= c :
                                                        c <= 0xCC8 ?
                                                            0xCC6 <= c :
                                                            0xCCA <= c :
                                                    c <= 0xCDE ?
                                                        c <= 0xCD6 ?
                                                            0xCD5 <= c :
                                                            0xCDE <= c :
                                                        0xCE0 <= c :
                                                c <= 0xD10 ?
                                                    c <= 0xD03 ?
                                                        c <= 0xCEF ?
                                                            0xCE6 <= c :
                                                            0xD02 <= c :
                                                        c <= 0xD0C ?
                                                            0xD05 <= c :
                                                            0xD0E <= c :
                                                    c <= 0xD39 ?
                                                        c <= 0xD28 ?
                                                            0xD12 <= c :
                                                            0xD2A <= c :
                                                        0xD3E <= c :
                                            c <= 0xD96 ?
                                                c <= 0xD61 ?
                                                    c <= 0xD4D ?
                                                        c <= 0xD48 ?
                                                            0xD46 <= c :
                                                            0xD4A <= c :
                                                        c <= 0xD57 ?
                                                            0xD57 <= c :
                                                            0xD60 <= c :
                                                    c <= 0xD83 ?
                                                        c <= 0xD6F ?
                                                            0xD66 <= c :
                                                            0xD82 <= c :
                                                        0xD85 <= c :
                                                c <= 0xDC6 ?
                                                    c <= 0xDBB ?
                                                        c <= 0xDB1 ?
                                                            0xD9A <= c :
                                                            0xDB3 <= c :
                                                        c <= 0xDBD ?
                                                            0xDBD <= c :
                                                            0xDC0 <= c :
                                                    c <= 0xDD4 ?
                                                        c <= 0xDCA ?
                                                            0xDCA <= c :
                                                            0xDCF <= c :
                                                        0xDD6 <= c :
                                    c <= 0xF39 ?
                                        c <= 0xEA7 ?
                                            c <= 0xE88 ?
                                                c <= 0xE4E ?
                                                    c <= 0xDF3 ?
                                                        c <= 0xDDF ?
                                                            0xDD8 <= c :
                                                            0xDF2 <= c :
                                                        c <= 0xE3A ?
                                                            0xE01 <= c :
                                                            0xE40 <= c :
                                                    c <= 0xE82 ?
                                                        c <= 0xE59 ?
                                                            0xE50 <= c :
                                                            0xE81 <= c :
                                                        c <= 0xE84 ?
                                                            0xE84 <= c :
                                                            0xE87 <= c :
                                                c <= 0xE9F ?
                                                    c <= 0xE8D ?
                                                        c <= 0xE8A ?
                                                            0xE8A <= c :
                                                            0xE8D <= c :
                                                        c <= 0xE97 ?
                                                            0xE94 <= c :
                                                            0xE99 <= c :
                                                    c <= 0xEA5 ?
                                                        c <= 0xEA3 ?
                                                            0xEA1 <= c :
                                                            0xEA5 <= c :
                                                        0xEA7 <= c :
                                            c <= 0xED9 ?
                                                c <= 0xEC4 ?
                                                    c <= 0xEB9 ?
                                                        c <= 0xEAB ?
                                                            0xEAA <= c :
                                                            0xEAD <= c :
                                                        c <= 0xEBD ?
                                                            0xEBB <= c :
                                                            0xEC0 <= c :
                                                    c <= 0xECD ?
                                                        c <= 0xEC6 ?
                                                            0xEC6 <= c :
                                                            0xEC8 <= c :
                                                        0xED0 <= c :
                                                c <= 0xF29 ?
                                                    c <= 0xF00 ?
                                                        c <= 0xEDD ?
                                                            0xEDC <= c :
                                                            0xF00 <= c :
                                                        c <= 0xF19 ?
                                                            0xF18 <= c :
                                                            0xF20 <= c :
                                                    c <= 0xF37 ?
                                                        c <= 0xF35 ?
                                                            0xF35 <= c :
                                                            0xF37 <= c :
                                                        0xF39 <= c :
                                        c <= 0x1059 ?
                                            c <= 0xFC6 ?
                                                c <= 0xF8B ?
                                                    c <= 0xF6A ?
                                                        c <= 0xF47 ?
                                                            0xF3E <= c :
                                                            0xF49 <= c :
                                                        c <= 0xF84 ?
                                                            0xF71 <= c :
                                                            0xF86 <= c :
                                                    c <= 0xFBC ?
                                                        c <= 0xF97 ?
                                                            0xF90 <= c :
                                                            0xF99 <= c :
                                                        0xFC6 <= c :
                                                c <= 0x1032 ?
                                                    c <= 0x1027 ?
                                                        c <= 0x1021 ?
                                                            0x1000 <= c :
                                                            0x1023 <= c :
                                                        c <= 0x102A ?
                                                            0x1029 <= c :
                                                            0x102C <= c :
                                                    c <= 0x1049 ?
                                                        c <= 0x1039 ?
                                                            0x1036 <= c :
                                                            0x1040 <= c :
                                                        0x1050 <= c :
                                            c <= 0x1248 ?
                                                c <= 0x1159 ?
                                                    c <= 0x10FA ?
                                                        c <= 0x10C5 ?
                                                            0x10A0 <= c :
                                                            0x10D0 <= c :
                                                        c <= 0x10FC ?
                                                            0x10FC <= c :
                                                            0x1100 <= c :
                                                    c <= 0x11F9 ?
                                                        c <= 0x11A2 ?
                                                            0x115F <= c :
                                                            0x11A8 <= c :
                                                        0x1200 <= c :
                                                c <= 0x125D ?
                                                    c <= 0x1256 ?
                                                        c <= 0x124D ?
                                                            0x124A <= c :
                                                            0x1250 <= c :
                                                        c <= 0x1258 ?
                                                            0x1258 <= c :
                                                            0x125A <= c :
                                                    c <= 0x128D ?
                                                        c <= 0x1288 ?
                                                            0x1260 <= c :
                                                            0x128A <= c :
                                                        0x1290 <= c :
                            c <= 0x30FF ?
                                c <= 0x1FB4 ?
                                    c <= 0x180D ?
                                        c <= 0x16EA ?
                                            c <= 0x135A ?
                                                c <= 0x12C5 ?
                                                    c <= 0x12BE ?
                                                        c <= 0x12B5 ?
                                                            0x12B2 <= c :
                                                            0x12B8 <= c :
                                                        c <= 0x12C0 ?
                                                            0x12C0 <= c :
                                                            0x12C2 <= c :
                                                    c <= 0x1310 ?
                                                        c <= 0x12D6 ?
                                                            0x12C8 <= c :
                                                            0x12D8 <= c :
                                                        c <= 0x1315 ?
                                                            0x1312 <= c :
                                                            0x1318 <= c :
                                                c <= 0x166C ?
                                                    c <= 0x138F ?
                                                        c <= 0x135F ?
                                                            0x135F <= c :
                                                            0x1380 <= c :
                                                        c <= 0x13F4 ?
                                                            0x13A0 <= c :
                                                            0x1401 <= c :
                                                    c <= 0x169A ?
                                                        c <= 0x1676 ?
                                                            0x166F <= c :
                                                            0x1681 <= c :
                                                        0x16A0 <= c :
                                            c <= 0x1770 ?
                                                c <= 0x1734 ?
                                                    c <= 0x170C ?
                                                        c <= 0x16F0 ?
                                                            0x16EE <= c :
                                                            0x1700 <= c :
                                                        c <= 0x1714 ?
                                                            0x170E <= c :
                                                            0x1720 <= c :
                                                    c <= 0x176C ?
                                                        c <= 0x1753 ?
                                                            0x1740 <= c :
                                                            0x1760 <= c :
                                                        0x176E <= c :
                                                c <= 0x17D7 ?
                                                    c <= 0x17B3 ?
                                                        c <= 0x1773 ?
                                                            0x1772 <= c :
                                                            0x1780 <= c :
                                                        c <= 0x17D3 ?
                                                            0x17B6 <= c :
                                                            0x17D7 <= c :
                                                    c <= 0x17E9 ?
                                                        c <= 0x17DD ?
                                                            0x17DC <= c :
                                                            0x17E0 <= c :
                                                        0x180B <= c :
                                        c <= 0x1B59 ?
                                            c <= 0x196D ?
                                                c <= 0x191C ?
                                                    c <= 0x1877 ?
                                                        c <= 0x1819 ?
                                                            0x1810 <= c :
                                                            0x1820 <= c :
                                                        c <= 0x18A9 ?
                                                            0x1880 <= c :
                                                            0x1900 <= c :
                                                    c <= 0x193B ?
                                                        c <= 0x192B ?
                                                            0x1920 <= c :
                                                            0x1930 <= c :
                                                        0x1946 <= c :
                                                c <= 0x19D9 ?
                                                    c <= 0x19A9 ?
                                                        c <= 0x1974 ?
                                                            0x1970 <= c :
                                                            0x1980 <= c :
                                                        c <= 0x19C9 ?
                                                            0x19B0 <= c :
                                                            0x19D0 <= c :
                                                    c <= 0x1B4B ?
                                                        c <= 0x1A1B ?
                                                            0x1A00 <= c :
                                                            0x1B00 <= c :
                                                        0x1B50 <= c :
                                            c <= 0x1F45 ?
                                                c <= 0x1EF9 ?
                                                    c <= 0x1DCA ?
                                                        c <= 0x1B73 ?
                                                            0x1B6B <= c :
                                                            0x1D00 <= c :
                                                        c <= 0x1E9B ?
                                                            0x1DFE <= c :
                                                            0x1EA0 <= c :
                                                    c <= 0x1F1D ?
                                                        c <= 0x1F15 ?
                                                            0x1F00 <= c :
                                                            0x1F18 <= c :
                                                        0x1F20 <= c :
                                                c <= 0x1F5B ?
                                                    c <= 0x1F57 ?
                                                        c <= 0x1F4D ?
                                                            0x1F48 <= c :
                                                            0x1F50 <= c :
                                                        c <= 0x1F59 ?
                                                            0x1F59 <= c :
                                                            0x1F5B <= c :
                                                    c <= 0x1F7D ?
                                                        c <= 0x1F5D ?
                                                            0x1F5D <= c :
                                                            0x1F5F <= c :
                                                        0x1F80 <= c :
                                    c <= 0x2149 ?
                                        c <= 0x20DC ?
                                            c <= 0x1FF4 ?
                                                c <= 0x1FCC ?
                                                    c <= 0x1FBE ?
                                                        c <= 0x1FBC ?
                                                            0x1FB6 <= c :
                                                            0x1FBE <= c :
                                                        c <= 0x1FC4 ?
                                                            0x1FC2 <= c :
                                                            0x1FC6 <= c :
                                                    c <= 0x1FDB ?
                                                        c <= 0x1FD3 ?
                                                            0x1FD0 <= c :
                                                            0x1FD6 <= c :
                                                        c <= 0x1FEC ?
                                                            0x1FE0 <= c :
                                                            0x1FF2 <= c :
                                                c <= 0x2071 ?
                                                    c <= 0x2040 ?
                                                        c <= 0x1FFC ?
                                                            0x1FF6 <= c :
                                                            0x203F <= c :
                                                        c <= 0x2054 ?
                                                            0x2054 <= c :
                                                            0x2071 <= c :
                                                    c <= 0x2094 ?
                                                        c <= 0x207F ?
                                                            0x207F <= c :
                                                            0x2090 <= c :
                                                        0x20D0 <= c :
                                            c <= 0x211D ?
                                                c <= 0x2107 ?
                                                    c <= 0x20EF ?
                                                        c <= 0x20E1 ?
                                                            0x20E1 <= c :
                                                            0x20E5 <= c :
                                                        c <= 0x2102 ?
                                                            0x2102 <= c :
                                                            0x2107 <= c :
                                                    c <= 0x2115 ?
                                                        c <= 0x2113 ?
                                                            0x210A <= c :
                                                            0x2115 <= c :
                                                        0x2119 <= c :
                                                c <= 0x212D ?
                                                    c <= 0x2126 ?
                                                        c <= 0x2124 ?
                                                            0x2124 <= c :
                                                            0x2126 <= c :
                                                        c <= 0x2128 ?
                                                            0x2128 <= c :
                                                            0x212A <= c :
                                                    c <= 0x213F ?
                                                        c <= 0x2139 ?
                                                            0x212F <= c :
                                                            0x213C <= c :
                                                        0x2145 <= c :
                                        c <= 0x2DB6 ?
                                            c <= 0x2CE4 ?
                                                c <= 0x2C5E ?
                                                    c <= 0x2184 ?
                                                        c <= 0x214E ?
                                                            0x214E <= c :
                                                            0x2160 <= c :
                                                        c <= 0x2C2E ?
                                                            0x2C00 <= c :
                                                            0x2C30 <= c :
                                                    c <= 0x2C77 ?
                                                        c <= 0x2C6C ?
                                                            0x2C60 <= c :
                                                            0x2C74 <= c :
                                                        0x2C80 <= c :
                                                c <= 0x2D96 ?
                                                    c <= 0x2D65 ?
                                                        c <= 0x2D25 ?
                                                            0x2D00 <= c :
                                                            0x2D30 <= c :
                                                        c <= 0x2D6F ?
                                                            0x2D6F <= c :
                                                            0x2D80 <= c :
                                                    c <= 0x2DAE ?
                                                        c <= 0x2DA6 ?
                                                            0x2DA0 <= c :
                                                            0x2DA8 <= c :
                                                        0x2DB0 <= c :
                                            c <= 0x302F ?
                                                c <= 0x2DD6 ?
                                                    c <= 0x2DC6 ?
                                                        c <= 0x2DBE ?
                                                            0x2DB8 <= c :
                                                            0x2DC0 <= c :
                                                        c <= 0x2DCE ?
                                                            0x2DC8 <= c :
                                                            0x2DD0 <= c :
                                                    c <= 0x3007 ?
                                                        c <= 0x2DDE ?
                                                            0x2DD8 <= c :
                                                            0x3005 <= c :
                                                        0x3021 <= c :
                                                c <= 0x309A ?
                                                    c <= 0x303C ?
                                                        c <= 0x3035 ?
                                                            0x3031 <= c :
                                                            0x3038 <= c :
                                                        c <= 0x3096 ?
                                                            0x3041 <= c :
                                                            0x3099 <= c :
                                                    c <= 0x30FA ?
                                                        c <= 0x309F ?
                                                            0x309D <= c :
                                                            0x30A1 <= c :
                                                        0x30FC <= c :
                                c <= 0x1049D ?
                                    c <= 0xFE23 ?
                                        c <= 0xFB06 ?
                                            c <= 0xA71A ?
                                                c <= 0x31FF ?
                                                    c <= 0x318E ?
                                                        c <= 0x312C ?
                                                            0x3105 <= c :
                                                            0x3131 <= c :
                                                        c <= 0x31B7 ?
                                                            0x31A0 <= c :
                                                            0x31F0 <= c :
                                                    c <= 0x9FBB ?
                                                        c <= 0x4DB5 ?
                                                            0x3400 <= c :
                                                            0x4E00 <= c :
                                                        c <= 0xA48C ?
                                                            0xA000 <= c :
                                                            0xA717 <= c :
                                                c <= 0xFA2D ?
                                                    c <= 0xA873 ?
                                                        c <= 0xA827 ?
                                                            0xA800 <= c :
                                                            0xA840 <= c :
                                                        c <= 0xD7A3 ?
                                                            0xAC00 <= c :
                                                            0xF900 <= c :
                                                    c <= 0xFAD9 ?
                                                        c <= 0xFA6A ?
                                                            0xFA30 <= c :
                                                            0xFA70 <= c :
                                                        0xFB00 <= c :
                                            c <= 0xFB44 ?
                                                c <= 0xFB3C ?
                                                    c <= 0xFB28 ?
                                                        c <= 0xFB17 ?
                                                            0xFB13 <= c :
                                                            0xFB1D <= c :
                                                        c <= 0xFB36 ?
                                                            0xFB2A <= c :
                                                            0xFB38 <= c :
                                                    c <= 0xFB41 ?
                                                        c <= 0xFB3E ?
                                                            0xFB3E <= c :
                                                            0xFB40 <= c :
                                                        0xFB43 <= c :
                                                c <= 0xFDC7 ?
                                                    c <= 0xFD3D ?
                                                        c <= 0xFBB1 ?
                                                            0xFB46 <= c :
                                                            0xFBD3 <= c :
                                                        c <= 0xFD8F ?
                                                            0xFD50 <= c :
                                                            0xFD92 <= c :
                                                    c <= 0xFE0F ?
                                                        c <= 0xFDFB ?
                                                            0xFDF0 <= c :
                                                            0xFE00 <= c :
                                                        0xFE20 <= c :
                                        c <= 0x1000B ?
                                            c <= 0xFF3F ?
                                                c <= 0xFEFC ?
                                                    c <= 0xFE4F ?
                                                        c <= 0xFE34 ?
                                                            0xFE33 <= c :
                                                            0xFE4D <= c :
                                                        c <= 0xFE74 ?
                                                            0xFE70 <= c :
                                                            0xFE76 <= c :
                                                    c <= 0xFF3A ?
                                                        c <= 0xFF19 ?
                                                            0xFF10 <= c :
                                                            0xFF21 <= c :
                                                        0xFF3F <= c :
                                                c <= 0xFFCF ?
                                                    c <= 0xFFBE ?
                                                        c <= 0xFF5A ?
                                                            0xFF41 <= c :
                                                            0xFF66 <= c :
                                                        c <= 0xFFC7 ?
                                                            0xFFC2 <= c :
                                                            0xFFCA <= c :
                                                    c <= 0xFFDC ?
                                                        c <= 0xFFD7 ?
                                                            0xFFD2 <= c :
                                                            0xFFDA <= c :
                                                        0x10000 <= c :
                                            c <= 0x10174 ?
                                                c <= 0x1004D ?
                                                    c <= 0x1003A ?
                                                        c <= 0x10026 ?
                                                            0x1000D <= c :
                                                            0x10028 <= c :
                                                        c <= 0x1003D ?
                                                            0x1003C <= c :
                                                            0x1003F <= c :
                                                    c <= 0x100FA ?
                                                        c <= 0x1005D ?
                                                            0x10050 <= c :
                                                            0x10080 <= c :
                                                        0x10140 <= c :
                                                c <= 0x103C3 ?
                                                    c <= 0x1034A ?
                                                        c <= 0x1031E ?
                                                            0x10300 <= c :
                                                            0x10330 <= c :
                                                        c <= 0x1039D ?
                                                            0x10380 <= c :
                                                            0x103A0 <= c :
                                                    c <= 0x103D5 ?
                                                        c <= 0x103CF ?
                                                            0x103C8 <= c :
                                                            0x103D1 <= c :
                                                        0x10400 <= c :
                                    c <= 0x1D4AC ?
                                        c <= 0x10A3F ?
                                            c <= 0x10915 ?
                                                c <= 0x10835 ?
                                                    c <= 0x10805 ?
                                                        c <= 0x104A9 ?
                                                            0x104A0 <= c :
                                                            0x10800 <= c :
                                                        c <= 0x10808 ?
                                                            0x10808 <= c :
                                                            0x1080A <= c :
                                                    c <= 0x1083C ?
                                                        c <= 0x10838 ?
                                                            0x10837 <= c :
                                                            0x1083C <= c :
                                                        c <= 0x1083F ?
                                                            0x1083F <= c :
                                                            0x10900 <= c :
                                                c <= 0x10A17 ?
                                                    c <= 0x10A06 ?
                                                        c <= 0x10A03 ?
                                                            0x10A00 <= c :
                                                            0x10A05 <= c :
                                                        c <= 0x10A13 ?
                                                            0x10A0C <= c :
                                                            0x10A15 <= c :
                                                    c <= 0x10A3A ?
                                                        c <= 0x10A33 ?
                                                            0x10A19 <= c :
                                                            0x10A38 <= c :
                                                        0x10A3F <= c :
                                            c <= 0x1D1AD ?
                                                c <= 0x1D172 ?
                                                    c <= 0x12462 ?
                                                        c <= 0x1236E ?
                                                            0x12000 <= c :
                                                            0x12400 <= c :
                                                        c <= 0x1D169 ?
                                                            0x1D165 <= c :
                                                            0x1D16D <= c :
                                                    c <= 0x1D18B ?
                                                        c <= 0x1D182 ?
                                                            0x1D17B <= c :
                                                            0x1D185 <= c :
                                                        0x1D1AA <= c :
                                                c <= 0x1D49F ?
                                                    c <= 0x1D454 ?
                                                        c <= 0x1D244 ?
                                                            0x1D242 <= c :
                                                            0x1D400 <= c :
                                                        c <= 0x1D49C ?
                                                            0x1D456 <= c :
                                                            0x1D49E <= c :
                                                    c <= 0x1D4A6 ?
                                                        c <= 0x1D4A2 ?
                                                            0x1D4A2 <= c :
                                                            0x1D4A5 <= c :
                                                        0x1D4A9 <= c :
                                        c <= 0x1D6C0 ?
                                            c <= 0x1D51C ?
                                                c <= 0x1D505 ?
                                                    c <= 0x1D4BB ?
                                                        c <= 0x1D4B9 ?
                                                            0x1D4AE <= c :
                                                            0x1D4BB <= c :
                                                        c <= 0x1D4C3 ?
                                                            0x1D4BD <= c :
                                                            0x1D4C5 <= c :
                                                    c <= 0x1D514 ?
                                                        c <= 0x1D50A ?
                                                            0x1D507 <= c :
                                                            0x1D50D <= c :
                                                        0x1D516 <= c :
                                                c <= 0x1D546 ?
                                                    c <= 0x1D53E ?
                                                        c <= 0x1D539 ?
                                                            0x1D51E <= c :
                                                            0x1D53B <= c :
                                                        c <= 0x1D544 ?
                                                            0x1D540 <= c :
                                                            0x1D546 <= c :
                                                    c <= 0x1D6A5 ?
                                                        c <= 0x1D550 ?
                                                            0x1D54A <= c :
                                                            0x1D552 <= c :
                                                        0x1D6A8 <= c :
                                            c <= 0x1D788 ?
                                                c <= 0x1D734 ?
                                                    c <= 0x1D6FA ?
                                                        c <= 0x1D6DA ?
                                                            0x1D6C2 <= c :
                                                            0x1D6DC <= c :
                                                        c <= 0x1D714 ?
                                                            0x1D6FC <= c :
                                                            0x1D716 <= c :
                                                    c <= 0x1D76E ?
                                                        c <= 0x1D74E ?
                                                            0x1D736 <= c :
                                                            0x1D750 <= c :
                                                        0x1D770 <= c :
                                                c <= 0x1D7FF ?
                                                    c <= 0x1D7C2 ?
                                                        c <= 0x1D7A8 ?
                                                            0x1D78A <= c :
                                                            0x1D7AA <= c :
                                                        c <= 0x1D7CB ?
                                                            0x1D7C4 <= c :
                                                            0x1D7CE <= c :
                                                    c <= 0x2FA1D ?
                                                        c <= 0x2A6D6 ?
                                                            0x20000 <= c :
                                                            0x2F800 <= c :
                                                        0xE0100 <= c && c <= 0xE01EF;
                        // #/generated#
                    }


                    return {
                        isDigit: isDigit, isIdentifierStart: isIdentifierStart, isHexDigit: isHexDigit, isAlpha: isAlpha, isSpace: isSpace, isLineTerminator: isLineTerminator, isFormatChar: isFormatChar, isIdentifierPart: isIdentifierPart
                    };
                }();
            }
        }.call(null) ) {
            this.Concurrent.Thread.Compiler.isDigit = isDigit;
            this.Concurrent.Thread.Compiler.isIdentifierStart = isIdentifierStart;
            this.Concurrent.Thread.Compiler.isHexDigit = isHexDigit;
            this.Concurrent.Thread.Compiler.isAlpha = isAlpha;
            this.Concurrent.Thread.Compiler.isSpace = isSpace;
            this.Concurrent.Thread.Compiler.isLineTerminator = isLineTerminator;
            this.Concurrent.Thread.Compiler.isFormatChar = isFormatChar;
            this.Concurrent.Thread.Compiler.isIdentifierPart = isIdentifierPart;
        }
    }).call(null);
    (function(){
        if ( !this.Concurrent || (typeof this.Concurrent != 'object' && typeof this.Concurrent != 'function') ) this.Concurrent = new Object();
        if ( !this.Concurrent.Thread || (typeof this.Concurrent.Thread != 'object' && typeof this.Concurrent.Thread != 'function') ) this.Concurrent.Thread = new Object();
        if ( !this.Concurrent.Thread.Http || (typeof this.Concurrent.Thread.Http != 'object' && typeof this.Concurrent.Thread.Http != 'function') ) this.Concurrent.Thread.Http = new Object();
        if ( this.Concurrent.Thread.Http.send === undefined ) this.Concurrent.Thread.Http.send = undefined;
        if ( this.Concurrent.Thread.Http.get === undefined ) this.Concurrent.Thread.Http.get = undefined;
        if ( this.Concurrent.Thread.Http.post === undefined ) this.Concurrent.Thread.Http.post = undefined;
        with ( function(){
            with ( Concurrent.Thread.Http ) {

                return function () {
                    var VERSION = '0.0.0';
                    var NAMESPACE;

                    /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Concurrent.Thread code.
 *
 * The Initial Developer of the Original Code is
 * Daisuke Maki.
 * Portions created by the Initial Developer are Copyright (C) 2006-2007
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */



                    NAMESPACE = 'Concurrent.Thread.Http';




                    var createXMLHttpRequest;  // Set up according to environment.
                    try {
                        new XMLHttpRequest();
                        createXMLHttpRequest = function ( ) {
                            return new XMLHttpRequest();
                        };
                    } catch ( e ) {
                        try {
                            // MSXML3 or later
                            new ActiveXObject("Msxml2.XMLHTTP");
                            createXMLHttpRequest = function ( ) {
                                return new ActiveXObject("Msxml2.XMLHTTP");
                            };
                        } catch ( e ) {
                            try {
                                // MSXML up to 2
                                new ActiveXObject("Microsoft.XMLHTTP");
                                createXMLHttpRequest = function ( ) {
                                    return new ActiveXObject("Microsoft.XMLHTTP");
                                };
                            } catch ( e ) {
                                throw new Error(NAMESPACE + ": can't load XMLHttpRequest object");
                            }
                        }
                    }



                    function send ( method, url, body, headers ) {
                        throw new Error(NAMESPACE + ".send is unusable in non-compiled function");
                    }

                    var LoadedException = {};

                    send.$Concurrent_Thread_compiled = function ( $this, $args, $cont ) {
                        var method=$args[0], url=$args[1], body=$args[2], headers=$args[3];
                        if ( !headers || !(headers instanceof Array) ) headers = [];
                        var req = createXMLHttpRequest();
                        req.open(method, url, true);
                        for ( var i=0;  i < headers.length;  i+=2 ) {
                            req.setRequestHeader(headers[i], headers[i+1]);
                        }
                        var self = Concurrent.Thread.self();
                        var loaded    = false;
                        var cache_hit = true;
                        req.onreadystatechange = function ( ) {
                            if ( req.readyState == 4 ) {
                                loaded = true;
                                if ( !cache_hit ) self.notify(LoadedException);
                            }
                        };
                        req.send(body);  // Firefox occasionally causes "onload" event here. Maybe, it occurs in case of cache-hit.
                        cache_hit = false;
                        if ( loaded ) {
                            return {
                                continuation: $cont,
                                ret_val     : req,
                                timeout     : undefined
                            };
                        } else {
                            var ex_handler = {
                                procedure: function ( e ) {
                                    if ( e === LoadedException ) {
                                        return {
                                            continuation: $cont,
                                            ret_val     : req,
                                            timeout     : undefined
                                        };
                                    } else {
                                        try{ req.abort(); }catch(_){}  // IE less than 7 does not support "abort".
                                        return {
                                            continuation: $cont.exception,
                                            ret_val     : e,
                                            timeout     : undefined
                                        };
                                    }
                                },
                                this_val : null
                            };
                            ex_handler.exception = ex_handler;  // Cyclic reference assures to abort request.
                            return {
                                timeout     : -1,
                                continuation: {
                                    procedure: null,
                                    this_val : null,
                                    exception: ex_handler
                                }
                            };
                        }
                    };



                    function get ( url, headers ) {
                        throw new Error(NAMESPACE + ".get is unusable in non-compiled function");
                    }

                    get.$Concurrent_Thread_compiled = function ($this, $args, $cont) {
                        return send.$Concurrent_Thread_compiled(
                            null,
                            ["GET", $args[0], $args[1], null],
                            $cont
                        );
                    }



                    function post ( url, body, headers ) {
                        throw new Error(NAMESPACE + ".post is unusable in non-compiled function");
                    }

                    post.$Concurrent_Thread_compiled = function ( $this, $args, $cont ) {
                        var url=$args[0], body=$args[1], headers=$args[2];
                        if ( typeof body == "object" ) {
                            var vals = [];
                            for ( var i in body ) {
                                if ( body.hasOwnProperty(i) ) {
                                    vals.push( encodeURIComponent(i) + "=" + encodeURIComponent(body[i]) );
                                }
                            }
                            body = vals.join("&");
                        }
                        if ( !headers || !(headers instanceof Array) ) headers = [];
                        var content_type_exists = false;
                        for ( var i=0;  i < headers.length;  i+=2 ) {
                            if ( String(headers[i]).match(/^Content-type$/i) ) {
                                content_type_exists = true;
                                break;
                            }
                        }
                        if ( !content_type_exists ) {
                            headers = headers.concat("Content-type", "application/x-www-form-urlencoded");
                        }
                        return send.$Concurrent_Thread_compiled(
                            null,
                            ["POST", url, body, headers],
                            $cont
                        );
                    };

                    return {
                        send: send, post: post, get: get
                    };
                }();
            }
        }.call(null) ) {
            this.Concurrent.Thread.Http.send = send;
            this.Concurrent.Thread.Http.post = post;
            this.Concurrent.Thread.Http.get = get;
        }
    }).call(null);
    (function(){
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Error || (typeof this.Data.Error != 'object' && typeof this.Data.Error != 'function') ) this.Data.Error = new Object();
        if ( !this.Concurrent || (typeof this.Concurrent != 'object' && typeof this.Concurrent != 'function') ) this.Concurrent = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Concurrent || (typeof this.Concurrent != 'object' && typeof this.Concurrent != 'function') ) this.Concurrent = new Object();
        if ( !this.Concurrent.Thread || (typeof this.Concurrent.Thread != 'object' && typeof this.Concurrent.Thread != 'function') ) this.Concurrent.Thread = new Object();
        if ( this.Concurrent.Thread.Mutex === undefined ) this.Concurrent.Thread.Mutex = undefined;
        with ( function(){
            with ( Data ) {
                with ( Data.Error ) {
                    with ( Concurrent ) {
                        with ( Concurrent.Thread ) {

                            return function () {
                                var VERSION = '0.0.0';
                                var NAMESPACE;

                                /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Concurrent.Thread code.
 *
 * The Initial Developer of the Original Code is
 * Daisuke Maki.
 * Portions created by the Initial Developer are Copyright (C) 2008
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */



                                NAMESPACE = 'Concurrent.Thread';














                                function Mutex ( ) {
                                    this._acquiring = null;
                                    this._waiting   = new LinkedList();
                                }

                                var proto = Mutex.prototype;


                                proto.isAcquirable = function ( ) {
                                    return !this._acquiring  &&  this._waiting.isEmpty();
                                };


                                proto.acquire = function ( ) {
                                    throw new Error("can't `acquire' in non-converted function");
                                };

                                proto.acquire.$Concurrent_Thread_compiled = function ( $this, $args, $cont ) {
                                    if ( $this.isAcquirable() ) {
                                        $this._acquiring = Thread.self();
                                        return {
                                            continuation: $cont ,
                                            ret_val     : void 0,
                                            timeout     : void 0
                                        };
                                    } else {
                                        $this._waiting.push(Thread.self());
                                        var callee = arguments.callee;
                                        return {
                                            continuation: {
                                                procedure: null,
                                                this_val : null,
                                                exception: {
                                                    procedure: function( e ){
                                                        if ( e === releasedException ) {
                                                            if ( $this._waiting.shift() !== Thread.self() ) {
                                                                return {
                                                                    continuation: $cont.exception,
                                                                    ret_val     : new IllegalStateError("unknown state (maybe bug)"),
                                                                    timeout     : void 0
                                                                };
                                                            }
                                                            $this._acquiring = Thread.self();
                                                            return {
                                                                continuation: $cont,
                                                                ret_val     : void 0,
                                                                timeout     : void 0
                                                            };
                                                        } else {
                                                            $this._waiting.head().find(function( it ){
                                                                return it === Thread.self();
                                                            }).remove();
                                                            return {
                                                                continuation: $cont.exception,
                                                                ret_val     : e,
                                                                timeout     : void 0
                                                            };
                                                        }
                                                    },
                                                    this_val : null,
                                                    exception: $cont.exception
                                                }
                                            },
                                            ret_val: void 0,
                                            timeout: -1
                                        };
                                    }
                                };


                                proto.release = function ( ) {
                                    if ( !this._acquiring ) {
                                        throw new IllegalStateError("mutex is not locked");
                                    }
                                    if ( this._acquiring !== Thread.self() ) {
                                        throw new IllegalStateError("mutex can be released only by the thread locking it");
                                    }
                                    this._acquiring = null;
                                    if ( !this._waiting.isEmpty() ) {
                                        this._waiting.head().value().notify(releasedException);
                                    }
                                };


                                var releasedException = {};

                                return {
                                    Mutex: Mutex
                                };
                            }();
                        }
                    }
                }
            }
        }.call(null) ) {
            this.Concurrent.Thread.Mutex = Mutex;
        }
    }).call(null);
    (function(){
        if ( !this.Concurrent || (typeof this.Concurrent != 'object' && typeof this.Concurrent != 'function') ) this.Concurrent = new Object();
        if ( !this.Concurrent.Thread || (typeof this.Concurrent.Thread != 'object' && typeof this.Concurrent.Thread != 'function') ) this.Concurrent.Thread = new Object();
        if ( !this.Concurrent.Thread.Compiler || (typeof this.Concurrent.Thread.Compiler != 'object' && typeof this.Concurrent.Thread.Compiler != 'function') ) this.Concurrent.Thread.Compiler = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Cons || (typeof this.Data.Cons != 'object' && typeof this.Data.Cons != 'function') ) this.Data.Cons = new Object();
        if ( this.Concurrent.Thread.Compiler.Expression === undefined ) this.Concurrent.Thread.Compiler.Expression = undefined;
        if ( this.Concurrent.Thread.Compiler.UnaryExpression === undefined ) this.Concurrent.Thread.Compiler.UnaryExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.BinaryExpression === undefined ) this.Concurrent.Thread.Compiler.BinaryExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.ThisExpression === undefined ) this.Concurrent.Thread.Compiler.ThisExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.Identifier === undefined ) this.Concurrent.Thread.Compiler.Identifier = undefined;
        if ( this.Concurrent.Thread.Compiler.Literal === undefined ) this.Concurrent.Thread.Compiler.Literal = undefined;
        if ( this.Concurrent.Thread.Compiler.NumberLiteral === undefined ) this.Concurrent.Thread.Compiler.NumberLiteral = undefined;
        if ( this.Concurrent.Thread.Compiler.StringLiteral === undefined ) this.Concurrent.Thread.Compiler.StringLiteral = undefined;
        if ( this.Concurrent.Thread.Compiler.RegExpLiteral === undefined ) this.Concurrent.Thread.Compiler.RegExpLiteral = undefined;
        if ( this.Concurrent.Thread.Compiler.NullLiteral === undefined ) this.Concurrent.Thread.Compiler.NullLiteral = undefined;
        if ( this.Concurrent.Thread.Compiler.BooleanLiteral === undefined ) this.Concurrent.Thread.Compiler.BooleanLiteral = undefined;
        if ( this.Concurrent.Thread.Compiler.TrueLiteral === undefined ) this.Concurrent.Thread.Compiler.TrueLiteral = undefined;
        if ( this.Concurrent.Thread.Compiler.FalseLiteral === undefined ) this.Concurrent.Thread.Compiler.FalseLiteral = undefined;
        if ( this.Concurrent.Thread.Compiler.ArrayInitializer === undefined ) this.Concurrent.Thread.Compiler.ArrayInitializer = undefined;
        if ( this.Concurrent.Thread.Compiler.Elision === undefined ) this.Concurrent.Thread.Compiler.Elision = undefined;
        if ( this.Concurrent.Thread.Compiler.ObjectInitializer === undefined ) this.Concurrent.Thread.Compiler.ObjectInitializer = undefined;
        if ( this.Concurrent.Thread.Compiler.FunctionExpression === undefined ) this.Concurrent.Thread.Compiler.FunctionExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.DotAccessor === undefined ) this.Concurrent.Thread.Compiler.DotAccessor = undefined;
        if ( this.Concurrent.Thread.Compiler.BracketAccessor === undefined ) this.Concurrent.Thread.Compiler.BracketAccessor = undefined;
        if ( this.Concurrent.Thread.Compiler.NewExpression === undefined ) this.Concurrent.Thread.Compiler.NewExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.CallExpression === undefined ) this.Concurrent.Thread.Compiler.CallExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.PostIncExpression === undefined ) this.Concurrent.Thread.Compiler.PostIncExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.PostDecExpression === undefined ) this.Concurrent.Thread.Compiler.PostDecExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.PreIncExpression === undefined ) this.Concurrent.Thread.Compiler.PreIncExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.PreDecExpression === undefined ) this.Concurrent.Thread.Compiler.PreDecExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.DeleteExpression === undefined ) this.Concurrent.Thread.Compiler.DeleteExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.VoidExpression === undefined ) this.Concurrent.Thread.Compiler.VoidExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.TypeofExpression === undefined ) this.Concurrent.Thread.Compiler.TypeofExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.PosExpression === undefined ) this.Concurrent.Thread.Compiler.PosExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.NegExpression === undefined ) this.Concurrent.Thread.Compiler.NegExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.BitNotExpression === undefined ) this.Concurrent.Thread.Compiler.BitNotExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.NotExpression === undefined ) this.Concurrent.Thread.Compiler.NotExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.MulExpression === undefined ) this.Concurrent.Thread.Compiler.MulExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.DivExpression === undefined ) this.Concurrent.Thread.Compiler.DivExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.ModExpression === undefined ) this.Concurrent.Thread.Compiler.ModExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.AddExpression === undefined ) this.Concurrent.Thread.Compiler.AddExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.SubExpression === undefined ) this.Concurrent.Thread.Compiler.SubExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.LShiftExpression === undefined ) this.Concurrent.Thread.Compiler.LShiftExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.RShiftExpression === undefined ) this.Concurrent.Thread.Compiler.RShiftExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.URShiftExpression === undefined ) this.Concurrent.Thread.Compiler.URShiftExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.LessThanExpression === undefined ) this.Concurrent.Thread.Compiler.LessThanExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.GreaterThanExpression === undefined ) this.Concurrent.Thread.Compiler.GreaterThanExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.LessEqualExpression === undefined ) this.Concurrent.Thread.Compiler.LessEqualExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.GreaterEqualExpression === undefined ) this.Concurrent.Thread.Compiler.GreaterEqualExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.InstanceofExpression === undefined ) this.Concurrent.Thread.Compiler.InstanceofExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.InExpression === undefined ) this.Concurrent.Thread.Compiler.InExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.EqualExpression === undefined ) this.Concurrent.Thread.Compiler.EqualExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.NotEqualExpression === undefined ) this.Concurrent.Thread.Compiler.NotEqualExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.StrictEqualExpression === undefined ) this.Concurrent.Thread.Compiler.StrictEqualExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.StrictNotEqualExpression === undefined ) this.Concurrent.Thread.Compiler.StrictNotEqualExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.BitAndExpression === undefined ) this.Concurrent.Thread.Compiler.BitAndExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.BitXorExpression === undefined ) this.Concurrent.Thread.Compiler.BitXorExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.BitOrExpression === undefined ) this.Concurrent.Thread.Compiler.BitOrExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.AndExpression === undefined ) this.Concurrent.Thread.Compiler.AndExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.OrExpression === undefined ) this.Concurrent.Thread.Compiler.OrExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.ConditionalExpression === undefined ) this.Concurrent.Thread.Compiler.ConditionalExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.AssignExpression === undefined ) this.Concurrent.Thread.Compiler.AssignExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.SimpleAssignExpression === undefined ) this.Concurrent.Thread.Compiler.SimpleAssignExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.MulAssignExpression === undefined ) this.Concurrent.Thread.Compiler.MulAssignExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.DivAssignExpression === undefined ) this.Concurrent.Thread.Compiler.DivAssignExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.ModAssignExpression === undefined ) this.Concurrent.Thread.Compiler.ModAssignExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.AddAssignExpression === undefined ) this.Concurrent.Thread.Compiler.AddAssignExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.SubAssignExpression === undefined ) this.Concurrent.Thread.Compiler.SubAssignExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.LShiftAssignExpression === undefined ) this.Concurrent.Thread.Compiler.LShiftAssignExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.RShiftAssignExpression === undefined ) this.Concurrent.Thread.Compiler.RShiftAssignExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.URShiftAssignExpression === undefined ) this.Concurrent.Thread.Compiler.URShiftAssignExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.BitAndAssignExpression === undefined ) this.Concurrent.Thread.Compiler.BitAndAssignExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.BitXorAssignExpression === undefined ) this.Concurrent.Thread.Compiler.BitXorAssignExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.BitOrAssignExpression === undefined ) this.Concurrent.Thread.Compiler.BitOrAssignExpression = undefined;
        if ( this.Concurrent.Thread.Compiler.CommaExpression === undefined ) this.Concurrent.Thread.Compiler.CommaExpression = undefined;
        with ( function(){
            with ( Data.Cons ) {
                with ( Concurrent.Thread.Compiler ) {

                    return function () {
                        var VERSION ;
                        var NAMESPACE;

                        /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Concurrent.Thread code.
 *
 * The Initial Developer of the Original Code is
 * Daisuke Maki.
 * Portions created by the Initial Developer are Copyright (C) 2006-2007
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */


                        NAMESPACE = 'Concurrent.Thread.Compiler';










                        function Expression ( ) {
                            // This is kind of abstract class.
                        }

                        var proto = Expression.prototype;

                        proto.toString = function ( ) {
                            Kit.codeBug("Unimplemented method `toString' of class: " + this.constructor);
                        };

                        proto.containsFunctionCall = function ( ) {
                            Kit.codeBug("Unimplemented method `containsFunctionCall' of class: " + this.constructor);
                        };

                        proto.hasSideEffect = function ( ) {
                            Kit.codeBug("Unimplemented method `hasSideEffect' of class: " + this.constructor);
                        };

                        proto.hasLvalue = function ( ) {
                            return false;
                        };



                        function UnaryExpression ( e ) {
                            // This is kind of abstract class and should not be instantiated directly.
                            // It just provides default implementations of methods and constructor.
                            this.exp = e;  // Expression
                        }

                        var proto = UnaryExpression.prototype = new Expression();
                        proto.constructor = UnaryExpression;

                        proto.containsFunctionCall = function ( ) {
                            return this.exp.containsFunctionCall();
                        };

                        proto.hasSideEffect = function ( ) {
                            return this.exp.hasSideEffect();
                        };



                        function BinaryExpression ( l, r ) {
                            // This is kind of abstract class and should not be instantiated directly.
                            // It just provides default implementations of methods and constructor.
                            this.left  = l;  // Expression
                            this.right = r;  // Expression
                        }

                        var proto = BinaryExpression.prototype = new Expression();
                        proto.constructor = BinaryExpression;

                        proto.containsFunctionCall = function ( ) {
                            return this.left.containsFunctionCall() || this.right.containsFunctionCall();
                        };

                        proto.hasSideEffect = function ( ) {
                            return this.left.hasSideEfect() || this.right.hasSideEffect();
                        };



                        function ThisExpression ( ) {
                            return THIS_EXPRESSION;  // Reuse object.
                        }

                        var proto = ThisExpression.prototype = new Expression();
                        proto.constructor = ThisExpression;

                        proto.toString = function ( ) {
                            return "this";
                        };

                        proto.containsFunctionCall = function ( ) {
                            return false;
                        };

                        proto.hasSideEffect = function ( ) {
                            return false;
                        };

                        function temp ( ) { }
                        temp.prototype = ThisExpression.prototype;
                        var THIS_EXPRESSION = new temp();



                        function Identifier ( s ) {
                            this.string = String(s);
                            this.value  = eval('"' + this.string + '"');
                        }

                        var proto = Identifier.prototype = new Expression();
                        proto.constructor = Identifier;

                        proto.toString = function ( ) {
                            return this.string;
                        };

                        proto.valueOf = function ( ) {
                            return this.value;
                        };

                        proto.hasLvalue = function ( ) {
                            return true;
                        };

                        proto.containsFunctionCall = function ( ) {
                            return false;
                        };

                        proto.hasSideEffect = function ( ) {
                            return false;
                        };



                        function Literal ( s ) {
                            this.string = String(s);
                            this.value  = eval(this.string);
                        }

                        var proto = Literal.prototype = new Expression();
                        proto.constructor = Literal;

                        proto.toString = function ( ) {
                            return this.string;
                        };

                        proto.valueOf = function ( ) {
                            return this.value;
                        };

                        proto.containsFunctionCall = function ( ) {
                            return false;
                        };

                        proto.hasSideEffect = function ( ) {
                            return false;
                        };



                        function NumberLiteral ( s ) {
                            Literal.apply(this, arguments);
                        }

                        var proto = NumberLiteral.prototype = new Literal();
                        proto.constructor = NumberLiteral;



                        function StringLiteral ( s ) {
                            Literal.apply(this, arguments);
                        }

                        var proto = StringLiteral.prototype = new Literal();
                        proto.constructor = StringLiteral;



                        function RegExpLiteral ( s ) {
                            Literal.apply(this, arguments);
                        }

                        var proto = RegExpLiteral.prototype = new Literal();
                        proto.constructor = RegExpLiteral;



                        function NullLiteral ( ) {
                            return NULL_LITERAL;  // Reuse object.
                        }

                        var proto = NullLiteral.prototype = new Literal();
                        proto.constructor = NullLiteral;

                        proto.string = "null";
                        proto.vakue  = null;

                        proto.toString = function ( ) {
                            return "null";
                        };

                        proto.valueOf = function ( ) {
                            return null;
                        };

                        function temp ( ) { }
                        temp.prototype = NullLiteral.prototype;
                        var NULL_LITERAL = new temp();



                        function BooleanLiteral ( ) { }

                        var proto = BooleanLiteral.prototype = new Literal();
                        proto.constructor = BooleanLiteral;



                        function TrueLiteral ( ) {
                            return TRUE_LITERAL;  // Reuse object.
                        }

                        var proto = TrueLiteral.prototype = new BooleanLiteral();
                        proto.constructor = TrueLiteral;

                        proto.string = "true";
                        proto.vakue  = true;

                        proto.toString = function ( ) {
                            return "true";
                        };

                        proto.valueOf = function ( ) {
                            return true;
                        };

                        function temp ( ) { }
                        temp.prototype = TrueLiteral.prototype;
                        var TRUE_LITERAL = new temp();



                        function FalseLiteral ( ) {
                            return FALSE_LITERAL;  // Reuse object.
                        }

                        var proto = FalseLiteral.prototype = new BooleanLiteral();
                        proto.constructor = FalseLiteral;

                        proto.string = "false";
                        proto.vakue  = false;

                        proto.toString = function ( ) {
                            return "false";
                        };

                        proto.valueOf = function ( ) {
                            return false;
                        };

                        function temp ( ) { }
                        temp.prototype = FalseLiteral.prototype;
                        var FALSE_LITERAL = new temp();



                        function ArrayInitializer ( elems ) {
                            this.elems = elems;  // array of Expression
                        }

                        var proto = ArrayInitializer.prototype = new Expression();
                        proto.constructor = ArrayInitializer;

                        proto.toString = function ( ) {
                            return "[" + this.elems.join(", ") + "]";
                        };

                        proto.containsFunctionCall = function ( ) {
                            for ( var i=0;  i < this.elems.length;  i++ ) {
                                if ( this.elems[i].containsFunctionCall() ) return true;
                            }
                            return false;
                        };

                        proto.hasSideEfect = function ( ) {
                            for ( var i=0;  i < this.elems.length;  i++ ) {
                                if ( this.elems[i].hasSideEffect() ) return true;
                            }
                            return false;
                        };



                        function Elision ( ) { }

                        var proto = Elision.prototype = new Expression();
                        proto.constructor = Elision;

                        proto.toString = function ( ) {
                            return "";
                        };

                        proto.containsFunctionCall = function ( ) {
                            return false;
                        };

                        proto.hasSideEffect = function ( ) {
                            return false;
                        };



                        function ObjectInitializer ( v ) {
                            this.pairs = v;  // array of {prop: Identifier or Literal,  exp: Expression}
                        }

                        var proto = ObjectInitializer.prototype = new Expression();
                        proto.constructor = ObjectInitializer;

                        proto.toString = function ( ) {
                            var buf = [];
                            for ( var i=0;  i < this.pairs.length;  i++ ) {
                                buf.push( String(this.pairs[i].prop) + ":" + String(this.pairs[i].exp) );
                            }
                            return "{" + buf.join(", ") + "}";
                        };

                        proto.containsFunctionCall = function ( ) {
                            for ( var i=0;  i < this.pairs.length;  i++ ) {
                                if ( this.pairs[i].exp.containsFunctionCall() ) return true;
                            }
                            return false;
                        };

                        proto.hasSideEffect = function ( ) {
                            for ( var i=0;  i < this.pairs.length;  i++ ) {
                                if ( this.pairs[i].exp.hasSideEffect() ) return true;
                            }
                            return false;
                        };



                        function FunctionExpression ( name, params, body ) {
                            this.name   = name;    // Identifier or null
                            this.params = params;  // array of Identifier
                            this.body   = body;    // cons-list of Statement
                        }

                        var proto = FunctionExpression.prototype = new Expression();
                        proto.constructor = FunctionExpression;

                        proto.toString = function ( ) {
                            var buf = ["(function "];
                            if ( this.name ) buf.push(this.name);
                            buf.push( "(", this.params.join(", "), ") {\n");
                            this.body.forEach(function( it ){
                                buf.push(it, "\n");
                            });
                            buf.push("})");
                            return buf.join("");
                        };

                        proto.containsFunctionCall = function ( ) {
                            return false;
                        };

                        proto.hasSideEffect = function ( ) {
                            return false;
                        };



                        function DotAccessor ( base, prop ) {
                            this.base = base;  // Expression
                            this.prop = prop;  // Identifier
                        }

                        var proto = DotAccessor.prototype = new Expression();
                        proto.constructor = DotAccessor;

                        proto.toString = function ( ) {
                            return String(this.base) + "." + String(this.prop);
                        };

                        proto.hasLvalue = function ( ) {
                            return true;
                        };

                        proto.containsFunctionCall = function ( ) {
                            return this.base.containsFunctionCall();
                        };

                        proto.hasSideEffect = function ( ) {
                            return this.base.hasSideEffect();
                        };



                        function BracketAccessor ( left, right ) {
                            BinaryExpression.apply(this, arguments);
                        }

                        var proto = BracketAccessor.prototype = new BinaryExpression();
                        proto.constructor = BracketAccessor;

                        proto.toString = function ( ) {
                            return [ this.left, "[", this.right, "]" ].join("");
                        };

                        proto.hasLvalue = function ( ) {
                            return true;
                        };



                        function NewExpression ( func, args ) {
                            this.func = func;  // Expression
                            this.args = args;  // array of Expression
                        }

                        var proto = NewExpression.prototype = new Expression();
                        proto.constructor = NewExpression;

                        proto.toString = function ( ) {
                            return [ "new ", this.func, "(", this.args.join(", "), ")" ].join("");
                        };

                        proto.containsFunctionCall = function ( ) {
                            return true;
                        };

                        proto.hasSideEffect = function ( ) {
                            return true;
                        };



                        function CallExpression ( func, args ) {
                            this.func = func;  // Expression
                            this.args = args;  // array of Expression
                        }

                        var proto = CallExpression.prototype = new Expression();
                        proto.constructor = CallExpression;

                        proto.toString = function ( ) {
                            return [ this.func, "(", this.args.join(", "), ")" ].join("");
                        };

                        proto.containsFunctionCall = function ( ) {
                            return true;
                        };

                        proto.hasSideEffect = function ( ) {
                            return true;
                        };



                        function PostIncExpression ( e ) {
                            UnaryExpression.apply(this, arguments);
                        }

                        var proto = PostIncExpression.prototype = new UnaryExpression();
                        proto.constructor = PostIncExpression;

                        proto.toString = function ( ) {
                            return String(this.exp) + "++";
                        };

                        proto.hasSideEffect = function ( ) {
                            return true;
                        };



                        function PostDecExpression ( e ) {
                            UnaryExpression.apply(this, arguments);
                        }

                        var proto = PostDecExpression.prototype = new UnaryExpression();
                        proto.constructor = PostDecExpression;

                        proto.toString = function ( ) {
                            return String(this.exp) + "--";
                        };

                        proto.hasSideEffect = function ( ) {
                            return true;
                        };



                        function PreIncExpression ( e ) {
                            UnaryExpression.apply(this, arguments);
                        }

                        var proto = PreIncExpression.prototype = new UnaryExpression();
                        proto.constructor = PreIncExpression;

                        proto.toString = function ( ) {
                            return "++" + String(this.exp);
                        };

                        proto.hasSideEffect = function ( ) {
                            return true;
                        };



                        function PreDecExpression ( e ) {
                            UnaryExpression.apply(this, arguments);
                        }

                        var proto = PreDecExpression.prototype = new UnaryExpression();
                        proto.constructor = PreDecExpression;

                        proto.toString = function ( ) {
                            return "--" + String(this.exp);
                        };

                        proto.hasSideEffect = function ( ) {
                            return true;
                        };



                        function DeleteExpression ( e ) {
                            UnaryExpression.apply(this, arguments);
                        }

                        var proto = DeleteExpression.prototype = new UnaryExpression();
                        proto.constructor = DeleteExpression;

                        proto.toString = function ( ) {
                            return "delete " + String(this.exp);
                        };

                        proto.hasSideEffect = function ( ) {
                            return true;
                        };



                        function VoidExpression ( e ) {
                            UnaryExpression.apply(this, arguments);
                        }

                        var proto = VoidExpression.prototype = new UnaryExpression();
                        proto.constructor = VoidExpression;

                        proto.toString = function ( ) {
                            return "void " + String(this.exp);
                        };



                        function TypeofExpression ( e ) {
                            UnaryExpression.apply(this, arguments);
                        }

                        var proto = TypeofExpression.prototype = new UnaryExpression();
                        proto.constructor = TypeofExpression;

                        proto.toString = function ( ) {
                            return "typeof " + String(this.exp);
                        };



                        function PosExpression ( e ) {
                            UnaryExpression.apply(this, arguments);
                        }

                        var proto = PosExpression.prototype = new UnaryExpression();
                        proto.constructor = PosExpression;

                        proto.toString = function ( ) {
                            return "+ " + String(this.exp);
                        };



                        function NegExpression ( e ) {
                            UnaryExpression.apply(this, arguments);
                        }

                        var proto = NegExpression.prototype = new UnaryExpression();
                        proto.constructor = NegExpression;

                        proto.toString = function ( ) {
                            return "- " + String(this.exp);
                        };



                        function BitNotExpression ( e ) {
                            UnaryExpression.apply(this, arguments);
                        }

                        var proto = BitNotExpression.prototype = new UnaryExpression();
                        proto.constructor = BitNotExpression;

                        proto.toString = function ( ) {
                            return "~" + String(this.exp);
                        };



                        function NotExpression ( e ) {
                            UnaryExpression.apply(this, arguments);
                        }

                        var proto = NotExpression.prototype = new UnaryExpression();
                        proto.constructor = NotExpression;

                        proto.toString = function ( ) {
                            return "!" + String(this.exp);
                        };



                        function MulExpression ( left, right ) {
                            BinaryExpression.apply(this, arguments);
                        }

                        var proto = MulExpression.prototype = new BinaryExpression();
                        proto.constructor = MulExpression;

                        proto.toString = function ( ) {
                            return [ "(", this.left, " * ", this.right, ")" ].join("");
                        };



                        function DivExpression ( left, right ) {
                            BinaryExpression.apply(this, arguments);
                        }

                        var proto = DivExpression.prototype = new BinaryExpression();
                        proto.constructor = DivExpression;

                        proto.toString = function ( ) {
                            return [ "(", this.left, " / ", this.right, ")" ].join("");
                        };



                        function ModExpression ( left, right ) {
                            BinaryExpression.apply(this, arguments);
                        }

                        var proto = ModExpression.prototype = new BinaryExpression();
                        proto.constructor = ModExpression;

                        proto.toString = function ( ) {
                            return [ "(", this.left, " % ", this.right, ")" ].join("");
                        };



                        function AddExpression ( left, right ) {
                            BinaryExpression.apply(this, arguments);
                        }

                        var proto = AddExpression.prototype = new BinaryExpression();
                        proto.constructor = AddExpression;

                        proto.toString = function ( ) {
                            return [ "(", this.left, " + ", this.right, ")" ].join("");
                        };



                        function SubExpression ( left, right ) {
                            BinaryExpression.apply(this, arguments);
                        }

                        var proto = SubExpression.prototype = new BinaryExpression();
                        proto.constructor = SubExpression;

                        proto.toString = function ( ) {
                            return [ "(", this.left, " - ", this.right, ")" ].join("");
                        };



                        function LShiftExpression ( left, right ) {
                            BinaryExpression.apply(this, arguments);
                        }

                        var proto = LShiftExpression.prototype = new BinaryExpression();
                        proto.constructor = LShiftExpression;

                        proto.toString = function ( ) {
                            return [ "(", this.left, " << ", this.right, ")" ].join("");
                        };



                        function RShiftExpression ( left, right ) {
                            BinaryExpression.apply(this, arguments);
                        }

                        var proto = RShiftExpression.prototype = new BinaryExpression();
                        proto.constructor = RShiftExpression;

                        proto.toString = function ( ) {
                            return [ "(", this.left, " >> ", this.right, ")" ].join("");
                        };



                        function URShiftExpression ( left, right ) {
                            BinaryExpression.apply(this, arguments);
                        }

                        var proto = URShiftExpression.prototype = new BinaryExpression();
                        proto.constructor = URShiftExpression;

                        proto.toString = function ( ) {
                            return [ "(", this.left, " >>> ", this.right, ")" ].join("");
                        };



                        function LessThanExpression ( left, right ) {
                            BinaryExpression.apply(this, arguments);
                        }

                        var proto = LessThanExpression.prototype = new BinaryExpression();
                        proto.constructor = LessThanExpression;

                        proto.toString = function ( ) {
                            return [ "(", this.left, " < ", this.right, ")" ].join("");
                        };



                        function GreaterThanExpression ( left, right ) {
                            BinaryExpression.apply(this, arguments);
                        }

                        var proto = GreaterThanExpression.prototype = new BinaryExpression();
                        proto.constructor = GreaterThanExpression;

                        proto.toString = function ( ) {
                            return [ "(", this.left, " > ", this.right, ")" ].join("");
                        };



                        function LessEqualExpression ( left, right ) {
                            BinaryExpression.apply(this, arguments);
                        }

                        var proto = LessEqualExpression.prototype = new BinaryExpression();
                        proto.constructor = LessEqualExpression;

                        proto.toString = function ( ) {
                            return [ "(", this.left, " <= ", this.right, ")" ].join("");
                        };



                        function GreaterEqualExpression ( left, right ) {
                            BinaryExpression.apply(this, arguments);
                        }

                        var proto = GreaterEqualExpression.prototype = new BinaryExpression();
                        proto.constructor = GreaterEqualExpression;

                        proto.toString = function ( ) {
                            return [ "(", this.left, " >= ", this.right, ")" ].join("");
                        };



                        function InstanceofExpression ( left, right ) {
                            BinaryExpression.apply(this, arguments);
                        }

                        var proto = InstanceofExpression.prototype = new BinaryExpression();
                        proto.constructor = InstanceofExpression;

                        proto.toString = function ( ) {
                            return [ "(", this.left, " instanceof ", this.right, ")" ].join("");
                        };



                        function InExpression ( left, right ) {
                            BinaryExpression.apply(this, arguments);
                        }

                        var proto = InExpression.prototype = new BinaryExpression();
                        proto.constructor = InExpression;

                        proto.toString = function ( ) {
                            return [ "(", this.left, " in ", this.right, ")" ].join("");
                        };



                        function EqualExpression ( left, right ) {
                            BinaryExpression.apply(this, arguments);
                        }

                        var proto = EqualExpression.prototype = new BinaryExpression();
                        proto.constructor = EqualExpression;

                        proto.toString = function ( ) {
                            return [ "(", this.left, " == ", this.right, ")" ].join("");
                        };



                        function NotEqualExpression ( left, right ) {
                            BinaryExpression.apply(this, arguments);
                        }

                        var proto = NotEqualExpression.prototype = new BinaryExpression();
                        proto.constructor = NotEqualExpression;

                        proto.toString = function ( ) {
                            return [ "(", this.left, " != ", this.right, ")" ].join("");
                        };



                        function StrictEqualExpression ( left, right ) {
                            BinaryExpression.apply(this, arguments);
                        }

                        var proto = StrictEqualExpression.prototype = new BinaryExpression();
                        proto.constructor = StrictEqualExpression;

                        proto.toString = function ( ) {
                            return [ "(", this.left, " === ", this.right, ")" ].join("");
                        };



                        function StrictNotEqualExpression ( left, right ) {
                            BinaryExpression.apply(this, arguments);
                        }

                        var proto = StrictNotEqualExpression.prototype = new BinaryExpression();
                        proto.constructor = StrictNotEqualExpression;

                        proto.toString = function ( ) {
                            return [ "(", this.left, " !== ", this.right, ")" ].join("");
                        };



                        function BitAndExpression ( left, right ) {
                            BinaryExpression.apply(this, arguments);
                        }

                        var proto = BitAndExpression.prototype = new BinaryExpression();
                        proto.constructor = BitAndExpression;

                        proto.toString = function ( ) {
                            return [ "(", this.left, " & ", this.right, ")" ].join("");
                        };



                        function BitXorExpression ( left, right ) {
                            BinaryExpression.apply(this, arguments);
                        }

                        var proto = BitXorExpression.prototype = new BinaryExpression();
                        proto.constructor = BitXorExpression;

                        proto.toString = function ( ) {
                            return [ "(", this.left, " ^ ", this.right, ")" ].join("");
                        };



                        function BitOrExpression ( left, right ) {
                            BinaryExpression.apply(this, arguments);
                        }

                        var proto = BitOrExpression.prototype = new BinaryExpression();
                        proto.constructor = BitOrExpression;

                        proto.toString = function ( ) {
                            return [ "(", this.left, " | ", this.right, ")" ].join("");
                        };



                        function AndExpression ( left, right ) {
                            BinaryExpression.apply(this, arguments);
                        }

                        var proto = AndExpression.prototype = new BinaryExpression();
                        proto.constructor = AndExpression;

                        proto.toString = function ( ) {
                            return [ "(", this.left, " && ", this.right, ")" ].join("");
                        };



                        function OrExpression ( left, right ) {
                            BinaryExpression.apply(this, arguments);
                        }

                        var proto = OrExpression.prototype = new BinaryExpression();
                        proto.constructor = OrExpression;

                        proto.toString = function ( ) {
                            return [ "(", this.left, " || ", this.right, ")" ].join("");
                        };



                        function ConditionalExpression ( c, t, f ) {
                            this.cond = c;  // Expression
                            this.texp = t;  // Expression
                            this.fexp = f;  // Expression
                        }

                        var proto = ConditionalExpression.prototype = new Expression();
                        proto.constructor = ConditionalExpression;

                        proto.toString = function ( ) {
                            return [ "(", this.cond, " ? ", this.texp, " : ", this.fexp, ")" ].join("");
                        };

                        proto.containsFunctionCall = function ( ) {
                            return this.cond.containsFunctionCall()
                                || this.texp.containsFunctionCall()
                                || this.fexp.containsFunctionCall();
                        };

                        proto.hasSideEffect = function ( ) {
                            return this.cond.hasSideEffect()
                                || this.texp.hasSideEffect()
                                || this.fexp.hasSideEffect();
                        };



                        function AssignExpression ( left, right ) {
                            // This is kind of interface. It just represents a set of classes.
                            BinaryExpression.apply(this, arguments);
                        }

                        var proto = AssignExpression.prototype = new BinaryExpression();
                        proto.constructor = AssignExpression;

                        proto.hasSideEffect = function ( ) {
                            return true;
                        };



                        function SimpleAssignExpression ( left, right ) {
                            AssignExpression.apply(this, arguments);
                        }

                        var proto = SimpleAssignExpression.prototype = new AssignExpression();
                        proto.constructor = SimpleAssignExpression;

                        proto.toString = function ( ) {
                            return [ "(", this.left, " = ", this.right, ")" ].join("");
                        };



                        function MulAssignExpression ( left, right ) {
                            AssignExpression.apply(this, arguments);
                        }

                        var proto = MulAssignExpression.prototype = new AssignExpression();
                        proto.constructor = MulAssignExpression;

                        proto.toString = function ( ) {
                            return [ "(", this.left, " *= ", this.right, ")" ].join("");
                        };



                        function DivAssignExpression ( left, right ) {
                            AssignExpression.apply(this, arguments);
                        }

                        var proto = DivAssignExpression.prototype = new AssignExpression();
                        proto.constructor = DivAssignExpression;

                        proto.toString = function ( ) {
                            return [ "(", this.left, " /= ", this.right, ")" ].join("");
                        };



                        function ModAssignExpression ( left, right ) {
                            AssignExpression.apply(this, arguments);
                        }

                        var proto = ModAssignExpression.prototype = new AssignExpression();
                        proto.constructor = ModAssignExpression;

                        proto.toString = function ( ) {
                            return [ "(",  this.left, " %= ", this.right, ")" ].join("");
                        };



                        function AddAssignExpression ( left, right ) {
                            AssignExpression.apply(this, arguments);
                        }

                        var proto = AddAssignExpression.prototype = new AssignExpression();
                        proto.constructor = AddAssignExpression;

                        proto.toString = function ( ) {
                            return [ "(", this.left, " += ", this.right, ")" ].join("");
                        };



                        function SubAssignExpression ( left, right ) {
                            AssignExpression.apply(this, arguments);
                        }

                        var proto = SubAssignExpression.prototype = new AssignExpression();
                        proto.constructor = SubAssignExpression;

                        proto.toString = function ( ) {
                            return [ "(", this.left, " -= ", this.right, ")" ].join("");
                        };



                        function LShiftAssignExpression ( left, right ) {
                            AssignExpression.apply(this, arguments);
                        }

                        var proto = LShiftAssignExpression.prototype = new AssignExpression();
                        proto.constructor = LShiftAssignExpression;

                        proto.toString = function ( ) {
                            return [ "(", this.left, " <<= ", this.right, ")" ].join("");
                        };



                        function RShiftAssignExpression ( left, right ) {
                            AssignExpression.apply(this, arguments);
                        }

                        var proto = RShiftAssignExpression.prototype = new AssignExpression();
                        proto.constructor = RShiftAssignExpression;

                        proto.toString = function ( ) {
                            return [ "(", this.left, " >>= ", this.right, ")" ].join("");
                        };



                        function URShiftAssignExpression ( left, right ) {
                            AssignExpression.apply(this, arguments);
                        }

                        var proto = URShiftAssignExpression.prototype = new AssignExpression();
                        proto.constructor = URShiftAssignExpression;

                        proto.toString = function ( ) {
                            return [ "(", this.left, " >>>= ", this.right, ")" ].join("");
                        };



                        function BitAndAssignExpression ( left, right ) {
                            AssignExpression.apply(this, arguments);
                        }

                        var proto = BitAndAssignExpression.prototype = new AssignExpression();
                        proto.constructor = BitAndAssignExpression;

                        proto.toString = function ( ) {
                            return [ "(", this.left, " &= ", this.right, ")" ].join("");
                        };



                        function BitXorAssignExpression ( left, right ) {
                            AssignExpression.apply(this, arguments);
                        }

                        var proto = BitXorAssignExpression.prototype = new AssignExpression();
                        proto.constructor = BitXorAssignExpression;

                        proto.toString = function ( ) {
                            return [ "(", this.left, " ^= ", this.right, ")" ].join("");
                        };



                        function BitOrAssignExpression ( left, right ) {
                            AssignExpression.apply(this, arguments);
                        }

                        var proto = BitOrAssignExpression.prototype = new AssignExpression();
                        proto.constructor = BitOrAssignExpression;

                        proto.toString = function ( ) {
                            return [ "(", this.left, " |= ", this.right, ")" ].join("");
                        };



                        function CommaExpression ( left, right ) {
                            BinaryExpression.apply(this, arguments);
                        }

                        var proto = CommaExpression.prototype = new BinaryExpression();
                        proto.constructor = CommaExpression;

                        proto.toString = function ( ) {
                            return [ "(", this.left, ", ", this.right, ")" ].join("");
                        };



                        return {
                            StrictEqualExpression: StrictEqualExpression, BooleanLiteral: BooleanLiteral, OrExpression: OrExpression, NotExpression: NotExpression, ThisExpression: ThisExpression, BitAndAssignExpression: BitAndAssignExpression, DivExpression: DivExpression, BracketAccessor: BracketAccessor, CommaExpression: CommaExpression, BitAndExpression: BitAndExpression, MulExpression: MulExpression, EqualExpression: EqualExpression, CallExpression: CallExpression, FunctionExpression: FunctionExpression, Elision: Elision, PostIncExpression: PostIncExpression, InstanceofExpression: InstanceofExpression, NullLiteral: NullLiteral, BitXorAssignExpression: BitXorAssignExpression, URShiftExpression: URShiftExpression, ConditionalExpression: ConditionalExpression, Identifier: Identifier, UnaryExpression: UnaryExpression, BitOrAssignExpression: BitOrAssignExpression, DivAssignExpression: DivAssignExpression, VoidExpression: VoidExpression, TypeofExpression: TypeofExpression, NewExpression: NewExpression, MulAssignExpression: MulAssignExpression, BinaryExpression: BinaryExpression, TrueLiteral: TrueLiteral, AssignExpression: AssignExpression, SubExpression: SubExpression, PreDecExpression: PreDecExpression, RegExpLiteral: RegExpLiteral, DeleteExpression: DeleteExpression, FalseLiteral: FalseLiteral, BitNotExpression: BitNotExpression, GreaterEqualExpression: GreaterEqualExpression, LessEqualExpression: LessEqualExpression, ModExpression: ModExpression, StringLiteral: StringLiteral, LShiftAssignExpression: LShiftAssignExpression, SubAssignExpression: SubAssignExpression, LShiftExpression: LShiftExpression, ModAssignExpression: ModAssignExpression, URShiftAssignExpression: URShiftAssignExpression, NegExpression: NegExpression, PosExpression: PosExpression, AddAssignExpression: AddAssignExpression, ArrayInitializer: ArrayInitializer, LessThanExpression: LessThanExpression, NumberLiteral: NumberLiteral, StrictNotEqualExpression: StrictNotEqualExpression, RShiftExpression: RShiftExpression, InExpression: InExpression, BitOrExpression: BitOrExpression, AndExpression: AndExpression, PostDecExpression: PostDecExpression, ObjectInitializer: ObjectInitializer, RShiftAssignExpression: RShiftAssignExpression, Expression: Expression, DotAccessor: DotAccessor, Literal: Literal, SimpleAssignExpression: SimpleAssignExpression, BitXorExpression: BitXorExpression, AddExpression: AddExpression, GreaterThanExpression: GreaterThanExpression, NotEqualExpression: NotEqualExpression, PreIncExpression: PreIncExpression
                        };
                    }();
                }
            }
        }.call(null) ) {
            this.Concurrent.Thread.Compiler.StrictEqualExpression = StrictEqualExpression;
            this.Concurrent.Thread.Compiler.BooleanLiteral = BooleanLiteral;
            this.Concurrent.Thread.Compiler.OrExpression = OrExpression;
            this.Concurrent.Thread.Compiler.NotExpression = NotExpression;
            this.Concurrent.Thread.Compiler.ThisExpression = ThisExpression;
            this.Concurrent.Thread.Compiler.BitAndAssignExpression = BitAndAssignExpression;
            this.Concurrent.Thread.Compiler.DivExpression = DivExpression;
            this.Concurrent.Thread.Compiler.BracketAccessor = BracketAccessor;
            this.Concurrent.Thread.Compiler.CommaExpression = CommaExpression;
            this.Concurrent.Thread.Compiler.BitAndExpression = BitAndExpression;
            this.Concurrent.Thread.Compiler.MulExpression = MulExpression;
            this.Concurrent.Thread.Compiler.EqualExpression = EqualExpression;
            this.Concurrent.Thread.Compiler.CallExpression = CallExpression;
            this.Concurrent.Thread.Compiler.FunctionExpression = FunctionExpression;
            this.Concurrent.Thread.Compiler.Elision = Elision;
            this.Concurrent.Thread.Compiler.PostIncExpression = PostIncExpression;
            this.Concurrent.Thread.Compiler.InstanceofExpression = InstanceofExpression;
            this.Concurrent.Thread.Compiler.NullLiteral = NullLiteral;
            this.Concurrent.Thread.Compiler.BitXorAssignExpression = BitXorAssignExpression;
            this.Concurrent.Thread.Compiler.URShiftExpression = URShiftExpression;
            this.Concurrent.Thread.Compiler.ConditionalExpression = ConditionalExpression;
            this.Concurrent.Thread.Compiler.Identifier = Identifier;
            this.Concurrent.Thread.Compiler.UnaryExpression = UnaryExpression;
            this.Concurrent.Thread.Compiler.BitOrAssignExpression = BitOrAssignExpression;
            this.Concurrent.Thread.Compiler.DivAssignExpression = DivAssignExpression;
            this.Concurrent.Thread.Compiler.VoidExpression = VoidExpression;
            this.Concurrent.Thread.Compiler.TypeofExpression = TypeofExpression;
            this.Concurrent.Thread.Compiler.NewExpression = NewExpression;
            this.Concurrent.Thread.Compiler.MulAssignExpression = MulAssignExpression;
            this.Concurrent.Thread.Compiler.BinaryExpression = BinaryExpression;
            this.Concurrent.Thread.Compiler.TrueLiteral = TrueLiteral;
            this.Concurrent.Thread.Compiler.AssignExpression = AssignExpression;
            this.Concurrent.Thread.Compiler.SubExpression = SubExpression;
            this.Concurrent.Thread.Compiler.PreDecExpression = PreDecExpression;
            this.Concurrent.Thread.Compiler.RegExpLiteral = RegExpLiteral;
            this.Concurrent.Thread.Compiler.DeleteExpression = DeleteExpression;
            this.Concurrent.Thread.Compiler.FalseLiteral = FalseLiteral;
            this.Concurrent.Thread.Compiler.BitNotExpression = BitNotExpression;
            this.Concurrent.Thread.Compiler.GreaterEqualExpression = GreaterEqualExpression;
            this.Concurrent.Thread.Compiler.LessEqualExpression = LessEqualExpression;
            this.Concurrent.Thread.Compiler.ModExpression = ModExpression;
            this.Concurrent.Thread.Compiler.StringLiteral = StringLiteral;
            this.Concurrent.Thread.Compiler.LShiftAssignExpression = LShiftAssignExpression;
            this.Concurrent.Thread.Compiler.SubAssignExpression = SubAssignExpression;
            this.Concurrent.Thread.Compiler.LShiftExpression = LShiftExpression;
            this.Concurrent.Thread.Compiler.ModAssignExpression = ModAssignExpression;
            this.Concurrent.Thread.Compiler.URShiftAssignExpression = URShiftAssignExpression;
            this.Concurrent.Thread.Compiler.NegExpression = NegExpression;
            this.Concurrent.Thread.Compiler.PosExpression = PosExpression;
            this.Concurrent.Thread.Compiler.AddAssignExpression = AddAssignExpression;
            this.Concurrent.Thread.Compiler.ArrayInitializer = ArrayInitializer;
            this.Concurrent.Thread.Compiler.LessThanExpression = LessThanExpression;
            this.Concurrent.Thread.Compiler.NumberLiteral = NumberLiteral;
            this.Concurrent.Thread.Compiler.StrictNotEqualExpression = StrictNotEqualExpression;
            this.Concurrent.Thread.Compiler.RShiftExpression = RShiftExpression;
            this.Concurrent.Thread.Compiler.InExpression = InExpression;
            this.Concurrent.Thread.Compiler.BitOrExpression = BitOrExpression;
            this.Concurrent.Thread.Compiler.AndExpression = AndExpression;
            this.Concurrent.Thread.Compiler.PostDecExpression = PostDecExpression;
            this.Concurrent.Thread.Compiler.ObjectInitializer = ObjectInitializer;
            this.Concurrent.Thread.Compiler.RShiftAssignExpression = RShiftAssignExpression;
            this.Concurrent.Thread.Compiler.Expression = Expression;
            this.Concurrent.Thread.Compiler.DotAccessor = DotAccessor;
            this.Concurrent.Thread.Compiler.Literal = Literal;
            this.Concurrent.Thread.Compiler.SimpleAssignExpression = SimpleAssignExpression;
            this.Concurrent.Thread.Compiler.BitXorExpression = BitXorExpression;
            this.Concurrent.Thread.Compiler.AddExpression = AddExpression;
            this.Concurrent.Thread.Compiler.GreaterThanExpression = GreaterThanExpression;
            this.Concurrent.Thread.Compiler.NotEqualExpression = NotEqualExpression;
            this.Concurrent.Thread.Compiler.PreIncExpression = PreIncExpression;
        }
    }).call(null);
    (function(){
        if ( !this.Concurrent || (typeof this.Concurrent != 'object' && typeof this.Concurrent != 'function') ) this.Concurrent = new Object();
        if ( !this.Concurrent.Thread || (typeof this.Concurrent.Thread != 'object' && typeof this.Concurrent.Thread != 'function') ) this.Concurrent.Thread = new Object();
        if ( !this.Concurrent.Thread.Compiler || (typeof this.Concurrent.Thread.Compiler != 'object' && typeof this.Concurrent.Thread.Compiler != 'function') ) this.Concurrent.Thread.Compiler = new Object();
        if ( this.Concurrent.Thread.Compiler.Token === undefined ) this.Concurrent.Thread.Compiler.Token = undefined;
        with ( function(){
            with ( Concurrent.Thread.Compiler ) {

                return function () {
                    var VERSION = '0.0.0';
                    var NAMESPACE;

                    /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Rhino code, released
 * May 6, 1999.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1997-1999
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Roger Lawrence
 *   Mike McCabe
 *   Igor Bukanov
 *   Milen Nankov
 *   Daisuke Maki
 *
 * Alternatively, the contents of this file may be used under the terms of
 * the GNU General Public License Version 2 or later (the "GPL"), in which
 * case the provisions of the GPL are applicable instead of those above. If
 * you wish to allow use of your version of this file only under the terms of
 * the GPL and not to allow others to use your version of this file under the
 * MPL, indicate your decision by deleting the provisions above and replacing
 * them with the notice and other provisions required by the GPL. If you do
 * not delete the provisions above, a recipient may use your version of this
 * file under either the MPL or the GPL.
 *
 * ***** END LICENSE BLOCK ***** */

                    /**
                     * This file is based on the file Token.java in Rhino 1.6R5.
                     */





                    NAMESPACE = 'Concurrent.Thread.Compiler';







                    var Token = {};

// Although Token is in fact a namespace, we here implements it
// "manually" because of efficiency.


// start enum
                    Token.ERROR          = -1; // well-known as the only code < EOF
                    Token.EOF            = 0;  // end of file token - (not EOF_CHAR)
                    Token.EOL            = 1;  // end of line

// Interpreter reuses the following as bytecodes
                    Token.FIRST_BYTECODE_TOKEN    = 2;

                    Token.ENTERWITH      = 2;
                    Token.LEAVEWITH      = 3;
                    Token.RETURN         = 4;
                    Token.GOTO           = 5;
                    Token.IFEQ           = 6;
                    Token.IFNE           = 7;
                    Token.SETNAME        = 8;
                    Token.BITOR          = 9;
                    Token.BITXOR         = 10;
                    Token.BITAND         = 11;
                    Token.EQ             = 12;
                    Token.NE             = 13;
                    Token.LT             = 14;
                    Token.LE             = 15;
                    Token.GT             = 16;
                    Token.GE             = 17;
                    Token.LSH            = 18;
                    Token.RSH            = 19;
                    Token.URSH           = 20;
                    Token.ADD            = 21;
                    Token.SUB            = 22;
                    Token.MUL            = 23;
                    Token.DIV            = 24;
                    Token.MOD            = 25;
                    Token.NOT            = 26;
                    Token.BITNOT         = 27;
                    Token.POS            = 28;
                    Token.NEG            = 29;
                    Token.NEW            = 30;
                    Token.DELPROP        = 31;
                    Token.TYPEOF         = 32;
                    Token.GETPROP        = 33;
                    Token.SETPROP        = 34;
                    Token.GETELEM        = 35;
                    Token.SETELEM        = 36;
                    Token.CALL           = 37;
                    Token.NAME           = 38;
                    Token.NUMBER         = 39;
                    Token.STRING         = 40;
                    Token.NULL           = 41;
                    Token.THIS           = 42;
                    Token.FALSE          = 43;
                    Token.TRUE           = 44;
                    Token.SHEQ           = 45;   // shallow equality (===)
                    Token.SHNE           = 46;   // shallow inequality (!==)
                    Token.REGEXP         = 47;
                    Token.BINDNAME       = 48;
                    Token.THROW          = 49;
                    Token.RETHROW        = 50; // rethrow caught execetion: catch (e if ) use it
                    Token.IN             = 51;
                    Token.INSTANCEOF     = 52;
                    Token.LOCAL_LOAD     = 53;
                    Token.GETVAR         = 54;
                    Token.SETVAR         = 55;
                    Token.CATCH_SCOPE    = 56;
                    Token.ENUM_INIT_KEYS = 57;
                    Token.ENUM_INIT_VALUES = 58;
                    Token.ENUM_NEXT      = 59;
                    Token.ENUM_ID        = 60;
                    Token.THISFN         = 61;
                    Token.RETURN_RESULT  = 62; // to return prevoisly stored return result
                    Token.ARRAYLIT       = 63; // array literal
                    Token.OBJECTLIT      = 64; // object literal
                    Token.GET_REF        = 65; // *reference
                    Token.SET_REF        = 66; // *reference    : something
                    Token.DEL_REF        = 67; // delete reference
                    Token.REF_CALL       = 68; // f(args)    = something or f(args)++
                    Token.REF_SPECIAL    = 69; // reference for special properties like __proto

// For XML support:
                    Token.DEFAULTNAMESPACE = 70; // default xml namespace =
                    Token.ESCXMLATTR     = 71;
                    Token.ESCXMLTEXT     = 72;
                    Token.REF_MEMBER     = 73; // Reference for x.@y, x..y etc.
                    Token.REF_NS_MEMBER  = 74; // Reference for x.ns::y, x..ns::y etc.
                    Token.REF_NAME       = 75; // Reference for @y, @[y] etc.
                    Token.REF_NS_NAME    = 76; // Reference for ns::y, @ns::y@[y] etc.

// End of interpreter bytecodes

                    Token.LAST_BYTECODE_TOKEN = Token.REF_NS_NAME;

                    Token.TRY            = 77;
                    Token.SEMI           = 78;  // semicolon
                    Token.LB             = 79;  // left and right brackets
                    Token.RB             = 80;
                    Token.LC             = 81;  // left and right curlies (braces)
                    Token.RC             = 82;
                    Token.LP             = 83;  // left and right parentheses
                    Token.RP             = 84;
                    Token.COMMA          = 85;  // comma operator

                    Token.ASSIGN         = 86;  // simple assignment  (=)
                    Token.ASSIGN_BITOR   = 87;  // |=
                    Token.ASSIGN_BITXOR  = 88;  // ^=
                    Token.ASSIGN_BITAND  = 89;  // |=
                    Token.ASSIGN_LSH     = 90;  // <<=
                    Token.ASSIGN_RSH     = 91;  // >>=
                    Token.ASSIGN_URSH    = 92;  // >>>=
                    Token.ASSIGN_ADD     = 93;  // +=
                    Token.ASSIGN_SUB     = 94;  // -=
                    Token.ASSIGN_MUL     = 95;  // *=
                    Token.ASSIGN_DIV     = 96;  // /=
                    Token.ASSIGN_MOD     = 97;  // %=

                    Token.FIRST_ASSIGN   = Token.ASSIGN;
                    Token.LAST_ASSIGN    = Token.ASSIGN_MOD;

                    Token.HOOK           = 98; // conditional (?:)
                    Token.COLON          = 99;
                    Token.OR             = 100; // logical or (||)
                    Token.AND            = 101; // logical and (&&)
                    Token.INC            = 102; // increment/decrement (++ --)
                    Token.DEC            = 103;
                    Token.DOT            = 104; // member operator (.)
                    Token.FUNCTION       = 105; // function keyword
                    Token.EXPORT         = 106; // export keyword
                    Token.IMPORT         = 107; // import keyword
                    Token.IF             = 108; // if keyword
                    Token.ELSE           = 109; // else keyword
                    Token.SWITCH         = 110; // switch keyword
                    Token.CASE           = 111; // case keyword
                    Token.DEFAULT        = 112; // default keyword
                    Token.WHILE          = 113; // while keyword
                    Token.DO             = 114; // do keyword
                    Token.FOR            = 115; // for keyword
                    Token.BREAK          = 116; // break keyword
                    Token.CONTINUE       = 117; // continue keyword
                    Token.VAR            = 118; // var keyword
                    Token.WITH           = 119; // with keyword
                    Token.CATCH          = 120; // catch keyword
                    Token.FINALLY        = 121; // finally keyword
                    Token.VOID           = 122; // void keyword
                    Token.RESERVED       = 123; // reserved keywords

                    Token.EMPTY          = 124;

                    /* types used for the parse tree - these never get returned
 * by the scanner.
 */

                    Token.BLOCK          = 125; // statement block
                    Token.LABEL          = 126; // label
                    Token.TARGET         = 127;
                    Token.LOOP           = 128;
                    Token.EXPR_VOID      = 129; // expression statement in functions
                    Token.EXPR_RESULT    = 130; // expression statement in scripts
                    Token.JSR            = 131;
                    Token.SCRIPT         = 132; // top-level node for entire script
                    Token.TYPEOFNAME     = 133; // for typeof(simple-name)
                    Token.USE_STACK      = 134;
                    Token.SETPROP_OP     = 135; // x.y op= something
                    Token.SETELEM_OP     = 136; // x[y] op= something
                    Token.LOCAL_BLOCK    = 137;
                    Token.SET_REF_OP     = 138; // *reference op= something

// For XML support:
                    Token.DOTDOT         = 139;  // member operator (..)
                    Token.COLONCOLON     = 140;  // namespace::name
                    Token.XML            = 141;  // XML type
                    Token.DOTQUERY       = 142;  // .() -- e.g., x.emps.emp.(name == "terry")
                    Token.XMLATTR        = 143;  // @
                    Token.XMLEND         = 144;

// Optimizer-only-tokens
                    Token.TO_OBJECT      = 145;
                    Token.TO_DOUBLE      = 146;

                    Token.LAST_TOKEN     = 146;


                    Token.name = function ( token )
                    {
                        if ( !Kit.printTrees ) return String(token);
                        with ( Token ) {
                            switch ( token ) {
                                case ERROR:           return "ERROR";
                                case EOF:             return "EOF";
                                case EOL:             return "EOL";
                                case ENTERWITH:       return "ENTERWITH";
                                case LEAVEWITH:       return "LEAVEWITH";
                                case RETURN:          return "RETURN";
                                case GOTO:            return "GOTO";
                                case IFEQ:            return "IFEQ";
                                case IFNE:            return "IFNE";
                                case SETNAME:         return "SETNAME";
                                case BITOR:           return "BITOR";
                                case BITXOR:          return "BITXOR";
                                case BITAND:          return "BITAND";
                                case EQ:              return "EQ";
                                case NE:              return "NE";
                                case LT:              return "LT";
                                case LE:              return "LE";
                                case GT:              return "GT";
                                case GE:              return "GE";
                                case LSH:             return "LSH";
                                case RSH:             return "RSH";
                                case URSH:            return "URSH";
                                case ADD:             return "ADD";
                                case SUB:             return "SUB";
                                case MUL:             return "MUL";
                                case DIV:             return "DIV";
                                case MOD:             return "MOD";
                                case NOT:             return "NOT";
                                case BITNOT:          return "BITNOT";
                                case POS:             return "POS";
                                case NEG:             return "NEG";
                                case NEW:             return "NEW";
                                case DELPROP:         return "DELPROP";
                                case TYPEOF:          return "TYPEOF";
                                case GETPROP:         return "GETPROP";
                                case SETPROP:         return "SETPROP";
                                case GETELEM:         return "GETELEM";
                                case SETELEM:         return "SETELEM";
                                case CALL:            return "CALL";
                                case NAME:            return "NAME";
                                case NUMBER:          return "NUMBER";
                                case STRING:          return "STRING";
                                case NULL:            return "NULL";
                                case THIS:            return "THIS";
                                case FALSE:           return "FALSE";
                                case TRUE:            return "TRUE";
                                case SHEQ:            return "SHEQ";
                                case SHNE:            return "SHNE";
                                case REGEXP:          return "OBJECT";
                                case BINDNAME:        return "BINDNAME";
                                case THROW:           return "THROW";
                                case RETHROW:         return "RETHROW";
                                case IN:              return "IN";
                                case INSTANCEOF:      return "INSTANCEOF";
                                case LOCAL_LOAD:      return "LOCAL_LOAD";
                                case GETVAR:          return "GETVAR";
                                case SETVAR:          return "SETVAR";
                                case CATCH_SCOPE:     return "CATCH_SCOPE";
                                case ENUM_INIT_KEYS:  return "ENUM_INIT_KEYS";
                                case ENUM_INIT_VALUES:  return "ENUM_INIT_VALUES";
                                case ENUM_NEXT:       return "ENUM_NEXT";
                                case ENUM_ID:         return "ENUM_ID";
                                case THISFN:          return "THISFN";
                                case RETURN_RESULT:   return "RETURN_RESULT";
                                case ARRAYLIT:        return "ARRAYLIT";
                                case OBJECTLIT:       return "OBJECTLIT";
                                case GET_REF:         return "GET_REF";
                                case SET_REF:         return "SET_REF";
                                case DEL_REF:         return "DEL_REF";
                                case REF_CALL:        return "REF_CALL";
                                case REF_SPECIAL:     return "REF_SPECIAL";
                                case DEFAULTNAMESPACE:return "DEFAULTNAMESPACE";
                                case ESCXMLTEXT:      return "ESCXMLTEXT";
                                case ESCXMLATTR:      return "ESCXMLATTR";
                                case REF_MEMBER:      return "REF_MEMBER";
                                case REF_NS_MEMBER:   return "REF_NS_MEMBER";
                                case REF_NAME:        return "REF_NAME";
                                case REF_NS_NAME:     return "REF_NS_NAME";
                                case TRY:             return "TRY";
                                case SEMI:            return "SEMI";
                                case LB:              return "LB";
                                case RB:              return "RB";
                                case LC:              return "LC";
                                case RC:              return "RC";
                                case LP:              return "LP";
                                case RP:              return "RP";
                                case COMMA:           return "COMMA";
                                case ASSIGN:          return "ASSIGN";
                                case ASSIGN_BITOR:    return "ASSIGN_BITOR";
                                case ASSIGN_BITXOR:   return "ASSIGN_BITXOR";
                                case ASSIGN_BITAND:   return "ASSIGN_BITAND";
                                case ASSIGN_LSH:      return "ASSIGN_LSH";
                                case ASSIGN_RSH:      return "ASSIGN_RSH";
                                case ASSIGN_URSH:     return "ASSIGN_URSH";
                                case ASSIGN_ADD:      return "ASSIGN_ADD";
                                case ASSIGN_SUB:      return "ASSIGN_SUB";
                                case ASSIGN_MUL:      return "ASSIGN_MUL";
                                case ASSIGN_DIV:      return "ASSIGN_DIV";
                                case ASSIGN_MOD:      return "ASSIGN_MOD";
                                case HOOK:            return "HOOK";
                                case COLON:           return "COLON";
                                case OR:              return "OR";
                                case AND:             return "AND";
                                case INC:             return "INC";
                                case DEC:             return "DEC";
                                case DOT:             return "DOT";
                                case FUNCTION:        return "FUNCTION";
                                case EXPORT:          return "EXPORT";
                                case IMPORT:          return "IMPORT";
                                case IF:              return "IF";
                                case ELSE:            return "ELSE";
                                case SWITCH:          return "SWITCH";
                                case CASE:            return "CASE";
                                case DEFAULT:         return "DEFAULT";
                                case WHILE:           return "WHILE";
                                case DO:              return "DO";
                                case FOR:             return "FOR";
                                case BREAK:           return "BREAK";
                                case CONTINUE:        return "CONTINUE";
                                case VAR:             return "VAR";
                                case WITH:            return "WITH";
                                case CATCH:           return "CATCH";
                                case FINALLY:         return "FINALLY";
                                case RESERVED:        return "RESERVED";
                                case EMPTY:           return "EMPTY";
                                case BLOCK:           return "BLOCK";
                                case LABEL:           return "LABEL";
                                case TARGET:          return "TARGET";
                                case LOOP:            return "LOOP";
                                case EXPR_VOID:       return "EXPR_VOID";
                                case EXPR_RESULT:     return "EXPR_RESULT";
                                case JSR:             return "JSR";
                                case SCRIPT:          return "SCRIPT";
                                case TYPEOFNAME:      return "TYPEOFNAME";
                                case USE_STACK:       return "USE_STACK";
                                case SETPROP_OP:      return "SETPROP_OP";
                                case SETELEM_OP:      return "SETELEM_OP";
                                case LOCAL_BLOCK:     return "LOCAL_BLOCK";
                                case SET_REF_OP:      return "SET_REF_OP";
                                case DOTDOT:          return "DOTDOT";
                                case COLONCOLON:      return "COLONCOLON";
                                case XML:             return "XML";
                                case DOTQUERY:        return "DOTQUERY";
                                case XMLATTR:         return "XMLATTR";
                                case XMLEND:          return "XMLEND";
                                case TO_OBJECT:       return "TO_OBJECT";
                                case TO_DOUBLE:       return "TO_DOUBLE";
                            }
                        }
                        // Token without name
                        Kit.codeBug(token);
                    };

                    return {
                        Token: Token
                    };
                }();
            }
        }.call(null) ) {
            this.Concurrent.Thread.Compiler.Token = Token;
        }
    }).call(null);
    (function(){
        if ( !this.Concurrent || (typeof this.Concurrent != 'object' && typeof this.Concurrent != 'function') ) this.Concurrent = new Object();
        if ( !this.Concurrent.Thread || (typeof this.Concurrent.Thread != 'object' && typeof this.Concurrent.Thread != 'function') ) this.Concurrent.Thread = new Object();
        if ( !this.Concurrent.Thread.Compiler || (typeof this.Concurrent.Thread.Compiler != 'object' && typeof this.Concurrent.Thread.Compiler != 'function') ) this.Concurrent.Thread.Compiler = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Cons || (typeof this.Data.Cons != 'object' && typeof this.Data.Cons != 'function') ) this.Data.Cons = new Object();
        if ( this.Concurrent.Thread.Compiler.Statement === undefined ) this.Concurrent.Thread.Compiler.Statement = undefined;
        if ( this.Concurrent.Thread.Compiler.EmptyStatement === undefined ) this.Concurrent.Thread.Compiler.EmptyStatement = undefined;
        if ( this.Concurrent.Thread.Compiler.Block === undefined ) this.Concurrent.Thread.Compiler.Block = undefined;
        if ( this.Concurrent.Thread.Compiler.ExpStatement === undefined ) this.Concurrent.Thread.Compiler.ExpStatement = undefined;
        if ( this.Concurrent.Thread.Compiler.VarStatement === undefined ) this.Concurrent.Thread.Compiler.VarStatement = undefined;
        if ( this.Concurrent.Thread.Compiler.IfStatement === undefined ) this.Concurrent.Thread.Compiler.IfStatement = undefined;
        if ( this.Concurrent.Thread.Compiler.IfElseStatement === undefined ) this.Concurrent.Thread.Compiler.IfElseStatement = undefined;
        if ( this.Concurrent.Thread.Compiler.DoWhileStatement === undefined ) this.Concurrent.Thread.Compiler.DoWhileStatement = undefined;
        if ( this.Concurrent.Thread.Compiler.WhileStatement === undefined ) this.Concurrent.Thread.Compiler.WhileStatement = undefined;
        if ( this.Concurrent.Thread.Compiler.ForStatement === undefined ) this.Concurrent.Thread.Compiler.ForStatement = undefined;
        if ( this.Concurrent.Thread.Compiler.ForVarStatement === undefined ) this.Concurrent.Thread.Compiler.ForVarStatement = undefined;
        if ( this.Concurrent.Thread.Compiler.ForInStatement === undefined ) this.Concurrent.Thread.Compiler.ForInStatement = undefined;
        if ( this.Concurrent.Thread.Compiler.ForInVarStatement === undefined ) this.Concurrent.Thread.Compiler.ForInVarStatement = undefined;
        if ( this.Concurrent.Thread.Compiler.ForEachStatement === undefined ) this.Concurrent.Thread.Compiler.ForEachStatement = undefined;
        if ( this.Concurrent.Thread.Compiler.ForEachVarStatement === undefined ) this.Concurrent.Thread.Compiler.ForEachVarStatement = undefined;
        if ( this.Concurrent.Thread.Compiler.ContinueStatement === undefined ) this.Concurrent.Thread.Compiler.ContinueStatement = undefined;
        if ( this.Concurrent.Thread.Compiler.BreakStatement === undefined ) this.Concurrent.Thread.Compiler.BreakStatement = undefined;
        if ( this.Concurrent.Thread.Compiler.ReturnStatement === undefined ) this.Concurrent.Thread.Compiler.ReturnStatement = undefined;
        if ( this.Concurrent.Thread.Compiler.WithStatement === undefined ) this.Concurrent.Thread.Compiler.WithStatement = undefined;
        if ( this.Concurrent.Thread.Compiler.SwitchStatement === undefined ) this.Concurrent.Thread.Compiler.SwitchStatement = undefined;
        if ( this.Concurrent.Thread.Compiler.CaseClause === undefined ) this.Concurrent.Thread.Compiler.CaseClause = undefined;
        if ( this.Concurrent.Thread.Compiler.DefaultClause === undefined ) this.Concurrent.Thread.Compiler.DefaultClause = undefined;
        if ( this.Concurrent.Thread.Compiler.ThrowStatement === undefined ) this.Concurrent.Thread.Compiler.ThrowStatement = undefined;
        if ( this.Concurrent.Thread.Compiler.TryCatchStatement === undefined ) this.Concurrent.Thread.Compiler.TryCatchStatement = undefined;
        if ( this.Concurrent.Thread.Compiler.TryFinallyStatement === undefined ) this.Concurrent.Thread.Compiler.TryFinallyStatement = undefined;
        if ( this.Concurrent.Thread.Compiler.TryCatchFinallyStatement === undefined ) this.Concurrent.Thread.Compiler.TryCatchFinallyStatement = undefined;
        if ( this.Concurrent.Thread.Compiler.TryCatchListStatement === undefined ) this.Concurrent.Thread.Compiler.TryCatchListStatement = undefined;
        if ( this.Concurrent.Thread.Compiler.TryCatchListFinallyStatement === undefined ) this.Concurrent.Thread.Compiler.TryCatchListFinallyStatement = undefined;
        if ( this.Concurrent.Thread.Compiler.CatchGuard === undefined ) this.Concurrent.Thread.Compiler.CatchGuard = undefined;
        if ( this.Concurrent.Thread.Compiler.FunctionDeclaration === undefined ) this.Concurrent.Thread.Compiler.FunctionDeclaration = undefined;
        with ( function(){
            with ( Data.Cons ) {
                with ( Concurrent.Thread.Compiler ) {

                    return function () {
                        var VERSION ;
                        var NAMESPACE;

                        /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Concurrent.Thread code.
 *
 * The Initial Developer of the Original Code is
 * Daisuke Maki.
 * Portions created by the Initial Developer are Copyright (C) 2006-2007
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */


                        NAMESPACE = 'Concurrent.Thread.Compiler';










                        function Statement ( labels, lineno, source ) {
                            // This is kind of abstract class.
                            this.labels = labels;  // array of Identifier  # labels directly qualifying this statement
                            this.lineno = lineno;  // Number (optional)    # line no.
                            this.source = source;  // String (optional)    # file-name, URL, ...etc
                        }

                        Statement.prototype.toString = function ( ) {
                            Kit.codeBug();
                        };

// kind of final protected method.
// Use this like: labelsToString.call(obj, arg0, arg1 ...)
                        function labelsToString ( ) {
                            var buf = [];
                            for ( var i=0;  i < this.labels.length;  i++ ) {
                                buf.push(this.labels[i], ": ");
                            }
                            return buf.join("");
                        }



                        function EmptyStatement ( labels, lineno, source ) {
                            Statement.call(this, labels, lineno, source);
                        }

                        var proto = EmptyStatement.prototype = new Statement();
                        proto.constructor = EmptyStatement;

                        proto.toString = function ( ) {
                            return labelsToString.call(this) + ";";
                        };



                        function Block ( labels, body, lineno, source ) {
                            Statement.call(this, labels, lineno, source);
                            this.body = body;  // cons-list of Statement
                        }

                        var proto = Block.prototype = new Statement();
                        proto.constructor = Block;

                        proto.toString = function ( ) {
                            var buf = [labelsToString.call(this), "{"];
                            this.body.forEach(function( it ){
                                buf.push(it);
                            });
                            buf.push("}");
                            return buf.join("\n");
                        };



                        function ExpStatement ( labels, exp, lineno, source ) {
                            Statement.call(this, labels, lineno, source);
                            this.exp = exp;  // Expression
                        }

                        var proto = ExpStatement.prototype = new Statement();
                        proto.constructor = ExpStatement;

                        proto.toString = function ( ) {
                            return labelsToString.call(this) + String(this.exp) + ";";
                        };

                        proto.containsFunctionCall = function ( ) {
                            return this.exp.containsFunctionCall();
                        };



                        function VarStatement ( labels, decls, lineno, source ) {
                            Statement.call(this, labels, lineno, source);
                            this.decls = decls;  // array of {id: Identifier,  exp: Expression or null}
                        }

                        var proto = VarStatement.prototype = new Statement();
                        proto.constructor = VarStatement;

                        proto.toString = function ( ) {
                            var buf = [];
                            for ( var i=0;  i < this.decls.length;  i++ ) {
                                if ( this.decls[i].exp ) {
                                    buf.push( [ this.decls[i].id, "=", this.decls[i].exp ].join("") );
                                }
                                else {
                                    buf.push( this.decls[i].id );
                                }
                            }
                            return [ labelsToString.call(this),
                                "var ",
                                buf.join(", "),
                                ";",
                            ].join("");
                        };

                        proto.containsFunctionCall = function ( ) {
                            for ( var i=0;  i < this.decls.length;  i++ ) {
                                if ( this.decls[i].exp && this.decls[i].exp.containsFunctionCall() ) {
                                    return true;
                                }
                            }
                            return false;
                        };



                        function IfStatement ( labels, cond, body, lineno, source ) {
                            Statement.call(this, labels, lineno, source);
                            this.cond = cond;  // Expression
                            this.body = body;  // Statement
                        }

                        var proto = IfStatement.prototype = new Statement();
                        proto.constructor = IfStatement;

                        proto.toString = function ( ) {
                            return [ labelsToString.call(this),
                                "if (",
                                this.cond,
                                ") ",
                                this.body
                            ].join("");
                        };



                        function IfElseStatement ( labels, cond, tbody, fbody, lineno, source ) {
                            Statement.call(this, labels, lineno, source);
                            this.cond  = cond;   // Expression
                            this.tbody = tbody;  // Statement
                            this.fbody = fbody;  // Statement
                        }

                        var proto = IfElseStatement.prototype = new Statement();
                        proto.constructor = IfElseStatement;

                        proto.toString = function ( ) {
                            return [ labelsToString.call(this),
                                "if (",
                                this.cond,
                                ") ",
                                this.tbody,
                                "\n",
                                "else ",
                                this.fbody
                            ].join("");
                        };



                        function DoWhileStatement ( labels, body, cond, lineno, source ) {
                            Statement.call(this, labels, lineno, source);
                            this.body = body;  // Statement
                            this.cond = cond;  // Expression
                        }

                        var proto = DoWhileStatement.prototype = new Statement();
                        proto.constructor = DoWhileStatement;

                        proto.toString = function ( ) {
                            return [ labelsToString.call(this),
                                "do ",
                                this.body,
                                " while (",
                                this.cond,
                                ");"
                            ].join("");
                        };



                        function WhileStatement ( labels, cond, body, lineno, source ) {
                            Statement.call(this, labels, lineno, source);
                            this.cond = cond;  // Expression
                            this.body = body;  // Statement
                        }

                        var proto = WhileStatement.prototype = new Statement();
                        proto.constructor = WhileStatement;

                        proto.toString = function ( ) {
                            return [ labelsToString.call(this),
                                "while (",
                                this.cond,
                                ") ",
                                this.body
                            ].join("");
                        };



                        function ForStatement ( labels, init, cond, incr, body, lineno, source ) {
                            Statement.call(this, labels, lineno, source);
                            this.init = init;  // Expression or null
                            this.cond = cond;  // Expression or null
                            this.incr = incr;  // Expression or null
                            this.body = body;  // Statement
                        }

                        var proto = ForStatement.prototype = new Statement();
                        proto.constructor = ForStatement;

                        proto.toString = function ( ) {
                            return [ labelsToString.call(this),
                                "for (",
                                this.init ? this.init : "", "; ",
                                this.cond ? this.cond : "", "; ",
                                this.incr ? this.incr : "",
                                ") ",
                                this.body
                            ].join("");
                        };



                        function ForVarStatement ( labels, decls, cond, incr, body, lineno, source ) {
                            Statement.call(this, labels, lineno, source);
                            this.decls = decls;  // array of {id: Identifier,  exp: Expression or null}
                            this.cond  = cond;   // Expression or null
                            this.incr  = incr;   // Expression or null
                            this.body  = body;   // Statement
                        }

                        var proto = ForVarStatement.prototype = new Statement();
                        proto.constructor = ForVarStatement;

                        proto.toString = function ( ) {
                            return [ labelsToString.call(this),
                                "for (",
                                (this.decls.length ? new VarStatement([], this.decls) : ";"), " ",
                                this.cond ? this.cond : "", "; ",
                                this.incr ? this.incr : "",
                                ") ",
                                this.body
                            ].join("");
                        };



                        function ForInStatement ( labels, lhs, exp, body, lineno, source ) {
                            Statement.call(this, labels, lineno, source);
                            this.lhs  = lhs;   // Identifier or DotAccessor or BracketAccessor
                            this.exp  = exp;   // Expression
                            this.body = body;  // Statement
                        }

                        var proto = ForInStatement.prototype = new Statement();
                        proto.constructor = ForInStatement;

                        proto.toString = function ( ) {
                            return [ labelsToString.call(this),
                                "for (", this.lhs, " in ", this.exp, ") ",
                                this.body
                            ].join("");
                        };



                        function ForInVarStatement ( labels, decl, exp, body, lineno, source ) {
                            Statement.call(this, labels, lineno, source);
                            this.decl = decl;  // {id: Identifier,  exp: Expression or null}
                            this.exp  = exp;   // Expression
                            this.body = body;  // Statement
                        }

                        var proto = ForInVarStatement.prototype = new Statement();
                        proto.constructor = ForInVarStatement;

                        proto.toString = function ( ) {
                            return [ labelsToString.call(this),
                                "for ( var ",
                                this.decl.exp ? String(this.decl.id) + "=" + String(this.decl.exp)
                                    : String(this.decl.id),
                                " in ",
                                this.exp,
                                ") ",
                                this.body
                            ].join("");
                        };


// Mozilla extention "for each ( ... in ... )"

                        function ForEachStatement ( labels, lhs, exp, body, lineno, source ) {
                            Statement.call(this, labels, lineno, source);
                            this.lhs  = lhs;   // Identifier or DotAccessor or BracketAccessor
                            this.exp  = exp;   // Expression
                            this.body = body;  // Statement
                        }

                        var proto = ForEachStatement.prototype = new Statement();
                        proto.constructor = ForEachStatement;

                        proto.toString = function ( ) {
                            return [ labelsToString.call(this),
                                "for each (", this.lhs, " in ", this.exp, ") ",
                                this.body
                            ].join("");
                        };



                        function ForEachVarStatement ( labels, decl, exp, body, lineno, source ) {
                            Statement.call(this, labels, lineno, source);
                            this.decl = decl;  // {id: Identifier,  exp: Expression or null}
                            this.exp  = exp;   // Expression
                            this.body = body;  // Statement
                        }

                        var proto = ForEachVarStatement.prototype = new Statement();
                        proto.constructor = ForEachVarStatement;

                        proto.toString = function ( ) {
                            return [ labelsToString.call(this),
                                "for each ( var ",
                                this.decl.exp ? String(this.decl.id) + "=" + String(this.decl.exp)
                                    : String(this.decl.id),
                                " in ",
                                this.exp,
                                ") ",
                                this.body
                            ].join("");
                        };



                        function ContinueStatement ( labels, target, lineno, source ) {
                            Statement.call(this, labels, lineno, source);
                            this.target = target;  // Identifier or null
                        }

                        var proto = ContinueStatement.prototype = new Statement();
                        proto.constructor = ContinueStatement;

                        proto.toString = function ( ) {
                            var buf = [labelsToString.call(this), "continue"];
                            if ( this.target ) buf.push(" ", this.target);
                            buf.push(";");
                            return buf.join("");
                        };



                        function BreakStatement ( labels, target, lineno, source ) {
                            Statement.call(this, labels, lineno, source);
                            this.target = target;  // Identifier or null
                        }

                        var proto = BreakStatement.prototype = new Statement();
                        proto.constructor = BreakStatement;

                        proto.toString = function ( ) {
                            var buf = [labelsToString.call(this), "break"];
                            if ( this.target ) buf.push(" ", this.target);
                            buf.push(";");
                            return buf.join("");
                        };



                        function ReturnStatement ( labels, exp, lineno, source ) {
                            Statement.call(this, labels, lineno, source);
                            this.exp = exp;  // Expression or null
                        }

                        var proto = ReturnStatement.prototype = new Statement();
                        proto.constructor = ReturnStatement;

                        proto.toString = function ( ) {
                            return [ labelsToString.call(this),
                                "return ",
                                this.exp ? this.exp : "",
                                ";"
                            ].join("");
                        };



                        function WithStatement ( labels, exp, body, lineno, source ) {
                            Statement.call(this, labels, lineno, source);
                            this.exp  = exp;   // Expression
                            this.body = body;  // Statement
                        }

                        var proto = WithStatement.prototype = new Statement();
                        proto.constructor = WithStatement;

                        proto.toString = function ( ) {
                            return [ "with (", this.exp, ") ", this.body ].join("");
                        };



                        function SwitchStatement ( labels, exp, clauses, lineno, source ) {
                            Statement.call(this, labels, lineno, source);
                            this.exp     = exp;      // Expression
                            this.clauses = clauses;  // cons-list of (CaseClause or DefaultClause)
                        }

                        var proto = SwitchStatement.prototype = new Statement();
                        proto.constructor = SwitchStatement;

                        proto.toString = function ( ) {
                            var buf = [ "switch ( ", this.exp, ") {\n"];
                            this.clauses.forEach(function( it ){
                                buf.push(it, "\n");
                            });
                            buf.push("}");
                            return buf.join("");
                        };



                        function CaseClause ( exp, body, lineno, source ) {
                            this.exp    = exp;     // Expression
                            this.body   = body;    // cons-list of Statement
                            this.lineno = lineno;  // Number (optional)
                            this.source = source;  // String (optional)
                        }

                        CaseClause.prototype.toString = function ( ) {
                            var buf = ["case ", this.exp, ":\n"];
                            this.body.forEach(function( it ){
                                buf.push(it, "\n");
                            });
                            return buf.join("");
                        };



                        function DefaultClause ( body, lineno, source ) {
                            this.body   = body;    // cons-list of Statement
                            this.lineno = lineno;  // Number (optional)
                            this.source = source;  // String (optional)
                        }

                        DefaultClause.prototype.toString = function ( ) {
                            var buf = ["default:\n"];
                            this.body.forEach(function( it ){
                                buf.push(it, "\n");
                            });
                            return buf.join("");
                        };



                        function ThrowStatement ( labels, exp, lineno, source ) {
                            Statement.call(this, labels, lineno, source);
                            this.exp = exp;  // Expression
                        }

                        var proto = ThrowStatement.prototype = new Statement();
                        proto.constructor = ThrowStatement;

                        proto.toString = function ( ) {
                            return [ labelsToString.call(this),
                                "throw ", this.exp, ";"
                            ].join("");
                        };



                        function TryCatchStatement ( labels, tryBlock, variable, catchBlock, lineno, source ) {
                            Statement.call(this, labels, lineno, source);
                            this.tryBlock   = tryBlock;    // Block
                            this.variable   = variable;    // Identifier
                            this.catchBlock = catchBlock;  // Block
                        }

                        var proto = TryCatchStatement.prototype = new Statement();
                        proto.constructor = TryCatchStatement;

                        proto.toString = function ( ) {
                            return [ labelsToString.call(this),
                                "try ", this.tryBlock, "\n",
                                "catch (", this.variable, ") ", this.catchBlock
                            ].join("");
                        };



                        function TryFinallyStatement ( labels, tryBlock, finallyBlock, lineno, source ) {
                            Statement.call(this, labels, lineno, source);
                            this.tryBlock     = tryBlock;      // Block
                            this.finallyBlock = finallyBlock;  // Block
                        }

                        var proto = TryFinallyStatement.prototype = new Statement();
                        proto.constructor = TryFinallyStatement;

                        proto.toString = function ( ) {
                            return [ labelsToString.call(this),
                                "try ", this.tryBlock, "\n",
                                "finally ", this.finallyBlock
                            ].join("");
                        };



                        function TryCatchFinallyStatement ( labels, tryBlock, variable, catchBlock, finallyBlock, lineno, source ) {
                            Statement.call(this, labels, lineno, source);
                            this.tryBlock     = tryBlock;      // Block
                            this.variable     = variable;      // Identifier
                            this.catchBlock   = catchBlock;    // Block
                            this.finallyBlock = finallyBlock;  // Block
                        }

                        var proto = TryCatchFinallyStatement.prototype = new Statement();
                        proto.constructor = TryCatchFinallyStatement;

                        proto.toString = function ( ) {
                            return [ labelsToString.call(this),
                                "try ", this.tryBlock, "\n",
                                "catch (", this.variable, ") ", this.catchBlock, "\n",
                                "finally ", this.finallyBlock
                            ].join("");
                        };



                        function TryCatchListStatement ( labels, tryBlock, catchList, lineno, source ) {
                            Statement.call(this, labels, lineno, source);
                            this.tryBlock  = tryBlock;   // Block
                            this.catchList = catchList;  // cons-list of CatchGuard
                        }

                        var proto = TryCatchListStatement.prototype = new Statement();
                        proto.constructor = TryCatchListStatement;

                        proto.toString = function ( ) {
                            var buf = [ labelsToString.call(this),
                                "try ", this.tryBlock, "\n" ];
                            this.catchList.forEach(function( it ){
                                buf.push(it);
                            });
                            return buf.join("");
                        };



                        function TryCatchListFinallyStatement ( labels, tryBlock, catchList, finallyBlock, lineno, source ) {
                            Statement.call(this, labels, lineno, source);
                            this.tryBlock     = tryBlock;      // Block
                            this.catchList    = catchList;     // cons-list of CatchGuard
                            this.finallyBlock = finallyBlock;  // Block
                        }

                        var proto = TryCatchListFinallyStatement.prototype = new Statement();
                        proto.constructor = TryCatchListFinallyStatement;

                        proto.toString = function ( ) {
                            var buf = [ labelsToString.call(this),
                                "try ", this.tryBlock, "\n" ];
                            this.catchList.forEach(function( it ){
                                buf.push(it);
                            });
                            buf.push("finally ", this.finallyBlock);
                            return buf.join("");
                        };



                        function CatchGuard ( variable, cond, block, lineno, source ) {
                            this.variable = variable;  // Identifier
                            this.cond     = cond;      // Expression or null (null means this is default catch clause)
                            this.block    = block;     // Block
                            this.lineno   = lineno;    // Number (optional)
                            this.source   = source;    // String (optional)
                        }

                        CatchGuard.prototype.toString = function ( ) {
                            var buf = ["catch ( ", this.variable];
                            if ( this.cond ) buf.push(" if ", this.cond);
                            buf.push(" )", this.block);
                            return buf.join("");
                        };



                        function FunctionDeclaration ( labels, name, params, body, lineno, source ) {
                            Statement.call(this, labels, lineno, source);
                            this.name   = name;    // Identifier
                            this.params = params;  // array of Identifier
                            this.body   = body;    // cons-list of Statement
                        }

                        var proto = FunctionDeclaration.prototype = new Statement();
                        proto.constructor = FunctionDeclaration;

                        proto.toString = function ( ) {
                            var buf = [ "function ", this.name,
                                " (", this.params.join(", "), ") {\n" ];
                            this.body.forEach(function( it ){
                                buf.push(it, "\n");
                            });
                            buf.push("}");
                            return buf.join("");
                        };


                        return {
                            CatchGuard: CatchGuard, Block: Block, IfStatement: IfStatement, FunctionDeclaration: FunctionDeclaration, ForVarStatement: ForVarStatement, IfElseStatement: IfElseStatement, TryFinallyStatement: TryFinallyStatement, TryCatchFinallyStatement: TryCatchFinallyStatement, ThrowStatement: ThrowStatement, ForEachStatement: ForEachStatement, EmptyStatement: EmptyStatement, TryCatchStatement: TryCatchStatement, WithStatement: WithStatement, ExpStatement: ExpStatement, ReturnStatement: ReturnStatement, Statement: Statement, ForInVarStatement: ForInVarStatement, BreakStatement: BreakStatement, TryCatchListStatement: TryCatchListStatement, DoWhileStatement: DoWhileStatement, ForInStatement: ForInStatement, DefaultClause: DefaultClause, VarStatement: VarStatement, ContinueStatement: ContinueStatement, TryCatchListFinallyStatement: TryCatchListFinallyStatement, WhileStatement: WhileStatement, SwitchStatement: SwitchStatement, ForEachVarStatement: ForEachVarStatement, CaseClause: CaseClause, ForStatement: ForStatement
                        };
                    }();
                }
            }
        }.call(null) ) {
            this.Concurrent.Thread.Compiler.CatchGuard = CatchGuard;
            this.Concurrent.Thread.Compiler.Block = Block;
            this.Concurrent.Thread.Compiler.IfStatement = IfStatement;
            this.Concurrent.Thread.Compiler.FunctionDeclaration = FunctionDeclaration;
            this.Concurrent.Thread.Compiler.ForVarStatement = ForVarStatement;
            this.Concurrent.Thread.Compiler.IfElseStatement = IfElseStatement;
            this.Concurrent.Thread.Compiler.TryFinallyStatement = TryFinallyStatement;
            this.Concurrent.Thread.Compiler.TryCatchFinallyStatement = TryCatchFinallyStatement;
            this.Concurrent.Thread.Compiler.ThrowStatement = ThrowStatement;
            this.Concurrent.Thread.Compiler.ForEachStatement = ForEachStatement;
            this.Concurrent.Thread.Compiler.EmptyStatement = EmptyStatement;
            this.Concurrent.Thread.Compiler.TryCatchStatement = TryCatchStatement;
            this.Concurrent.Thread.Compiler.WithStatement = WithStatement;
            this.Concurrent.Thread.Compiler.ExpStatement = ExpStatement;
            this.Concurrent.Thread.Compiler.ReturnStatement = ReturnStatement;
            this.Concurrent.Thread.Compiler.Statement = Statement;
            this.Concurrent.Thread.Compiler.ForInVarStatement = ForInVarStatement;
            this.Concurrent.Thread.Compiler.BreakStatement = BreakStatement;
            this.Concurrent.Thread.Compiler.TryCatchListStatement = TryCatchListStatement;
            this.Concurrent.Thread.Compiler.DoWhileStatement = DoWhileStatement;
            this.Concurrent.Thread.Compiler.ForInStatement = ForInStatement;
            this.Concurrent.Thread.Compiler.DefaultClause = DefaultClause;
            this.Concurrent.Thread.Compiler.VarStatement = VarStatement;
            this.Concurrent.Thread.Compiler.ContinueStatement = ContinueStatement;
            this.Concurrent.Thread.Compiler.TryCatchListFinallyStatement = TryCatchListFinallyStatement;
            this.Concurrent.Thread.Compiler.WhileStatement = WhileStatement;
            this.Concurrent.Thread.Compiler.SwitchStatement = SwitchStatement;
            this.Concurrent.Thread.Compiler.ForEachVarStatement = ForEachVarStatement;
            this.Concurrent.Thread.Compiler.CaseClause = CaseClause;
            this.Concurrent.Thread.Compiler.ForStatement = ForStatement;
        }
    }).call(null);
    (function(){
        if ( !this.Concurrent || (typeof this.Concurrent != 'object' && typeof this.Concurrent != 'function') ) this.Concurrent = new Object();
        if ( !this.Concurrent.Thread || (typeof this.Concurrent.Thread != 'object' && typeof this.Concurrent.Thread != 'function') ) this.Concurrent.Thread = new Object();
        if ( !this.Concurrent.Thread.Compiler || (typeof this.Concurrent.Thread.Compiler != 'object' && typeof this.Concurrent.Thread.Compiler != 'function') ) this.Concurrent.Thread.Compiler = new Object();
        if ( this.Concurrent.Thread.Compiler.IdentifierMap === undefined ) this.Concurrent.Thread.Compiler.IdentifierMap = undefined;
        with ( function(){
            with ( Concurrent.Thread.Compiler ) {

                return function () {
                    var VERSION ;
                    var NAMESPACE;

                    /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Concurrent.Thread code.
 *
 * The Initial Developer of the Original Code is
 * Daisuke Maki.
 * Portions created by the Initial Developer are Copyright (C) 2006-2007
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */


                    NAMESPACE = 'Concurrent.Thread.Compiler';





                    var hasOwnProperty = Object.prototype.hasOwnProperty;




                    function IdentifierMap ( ) {
                        this._map = {};
                    }

                    var proto = IdentifierMap.prototype;


                    proto.clone = function clone ( ) {
                        var c = new IdentifierMap();
                        for ( var i in this._map ) {
                            if ( hasOwnProperty.call(this._map, i) ) c._map[i] = this._map[i];
                        }
                        return c;
                    };


                    proto.exists = function ( /* variable arguments */ ) {
                        for ( var i=0;  i < arguments.length;  i++ ) {
                            var key = arguments[i];
                            if ( !(key instanceof Identifier) ) throw new TypeError("arguments[" + i + "] is not of type Identifier");
                            if ( !hasOwnProperty.call(this._map, key.valueOf()) ) return false;
                        }
                        return true;
                    };


                    proto.get = function ( k ) {
                        if ( !(k instanceof Identifier) ) throw new TypeError("arguments[0] is not of type Identifier");
                        var s = k.valueOf();
                        if ( !hasOwnProperty.call(this._map, s) ) return undefined;
                        return this._map[s].value;
                    };


                    proto.put = function ( k, v ) {
                        if ( !(k instanceof Identifier) ) throw new TypeError("arguments[0] is not of type Identifier");
                        this._map[k.valueOf()] = {id: k, value: v};
                    };


                    proto.remove = function ( k ) {
                        if ( !(k instanceof Identifier) ) throw new TypeError("arguments[0] is not of type Identifier");
                        return delete this._map[k.valueOf()];
                    };


                    proto.keys = function ( ) {
                        var set = new IdentifierSet();
                        for ( var i in this._map ) {
                            if ( hasOwnProperty.call(this._map, i) ) set.add(this._map[i].id);
                        }
                        return set;
                    };


                    proto.values = function ( ) {
                        var vals = [];
                        for ( var i in this._map ) {
                            if ( hasOwnProperty.call(this._map, i) ) vals.push(this._map[i].value);
                        }
                        return vals;
                    };


                    return {
                        IdentifierMap: IdentifierMap
                    };
                }();
            }
        }.call(null) ) {
            this.Concurrent.Thread.Compiler.IdentifierMap = IdentifierMap;
        }
    }).call(null);
    (function(){
        if ( !this.Concurrent || (typeof this.Concurrent != 'object' && typeof this.Concurrent != 'function') ) this.Concurrent = new Object();
        if ( !this.Concurrent.Thread || (typeof this.Concurrent.Thread != 'object' && typeof this.Concurrent.Thread != 'function') ) this.Concurrent.Thread = new Object();
        if ( !this.Concurrent.Thread.Compiler || (typeof this.Concurrent.Thread.Compiler != 'object' && typeof this.Concurrent.Thread.Compiler != 'function') ) this.Concurrent.Thread.Compiler = new Object();
        if ( this.Concurrent.Thread.Compiler.TokenStream === undefined ) this.Concurrent.Thread.Compiler.TokenStream = undefined;
        with ( function(){
            with ( Concurrent.Thread.Compiler ) {

                return function () {
                    var VERSION = '0.0.0';
                    var NAMESPACE;

                    /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Rhino code, released
 * May 6, 1999.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1997-1999
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Roger Lawrence
 *   Mike McCabe
 *   Igor Bukanov
 *   Ethan Hugg
 *   Terry Lucas
 *   Milen Nankov
 *   Daisuke Maki
 *
 * Alternatively, the contents of this file may be used under the terms of
 * the GNU General Public License Version 2 or later (the "GPL"), in which
 * case the provisions of the GPL are applicable instead of those above. If
 * you wish to allow use of your version of this file only under the terms of
 * the GPL and not to allow others to use your version of this file under the
 * MPL, indicate your decision by deleting the provisions above and replacing
 * them with the notice and other provisions required by the GPL. If you do
 * not delete the provisions above, a recipient may use your version of this
 * file under either the MPL or the GPL.
 *
 * ***** END LICENSE BLOCK ***** */

                    /**
                     * This file is based on the file TokenStream.java in Rhino 1.6R5.
                     */





                    NAMESPACE = 'Concurrent.Thread.Compiler';







                    /*
 * For chars - because we need something out-of-range
 * to check.  (And checking EOF by exception is annoying.)
 * Fortunatelly, U+FFFF is guaranteed not to be assigned
 * for any character.
 * Note distinction from EOF token type!
 */
                    var EOF_CHAR = String.fromCharCode(0xFFFF);




                    function TokenStream( parser, sourceString, lineno )
                    {
                        this.parser = parser;
                        this.sourceString = String(sourceString);
                        this.sourceEnd    = this.sourceString.length;
                        this.sourceCursor = 0;

                        // stuff other than whitespace since start of line
                        this.dirtyLine = false;

                        this.string = "";

                        this.stringBuffer = [];
                        this.ungetBuffer  = [];

                        this.hitEOF = false;

                        this.lineStart   = 0;
                        this.lineno      = Number(lineno) || 1;
                        this.lineEndChar = undefined;

                        // for xml tokenizer
                        this.xmlIsAttribute   = false;
                        this.xmlIsTagContent  = false;
                        this.xmlOpenTagsCount = 0;
                    }

                    var proto = TokenStream.prototype;


                    /* This function uses the cached op, string and number fields in
 * TokenStream; if getToken has been called since the passed token
 * was scanned, the op or string printed may be incorrect.
 */
                    proto.tokenToString = function ( token )
                    {
                        if (Token.printTrees) {
                            var name = Token.name(token);

                            switch ( token ) {
                                case Token.STRING:
                                case Token.REGEXP:
                                case Token.NAME:
                                    return name + " `" + this.string + "'";

                                case Token.NUMBER:
                                    return "NUMBER " + this.number;
                            }

                            return name;
                        }
                        return "";
                    };


                    function isKeyword ( s )
                    {
                        return Token.EOF != stringToKeyword(s);
                    }


                    var strIdMap = {
                        "break"         : Token.BREAK,
                        "case"          : Token.CASE,
                        "catch"         : Token.CATCH,
                        "continue"      : Token.CONTINUE,
                        "default"       : Token.DEFAULT,
                        "delete"        : Token.DELPROP,
                        "do"            : Token.DO,
                        "else"          : Token.ELSE,
                        "export"        : Token.EXPORT,
                        "false"         : Token.FALSE,
                        "finally"       : Token.FINALLY,
                        "for"           : Token.FOR,
                        "function"      : Token.FUNCTION,
                        "if"            : Token.IF,
                        "in"            : Token.IN,
                        "instanceof"    : Token.INSTANCEOF,
                        "new"           : Token.NEW,
                        "null"          : Token.NULL,
                        "return"        : Token.RETURN,
                        "switch"        : Token.SWITCH,
                        "this"          : Token.THIS,
                        "throw"         : Token.THROW,
                        "true"          : Token.TRUE,
                        "try"           : Token.TRY,
                        "typeof"        : Token.TYPEOF,
                        "var"           : Token.VAR,
                        "void"          : Token.VOID,
                        "while"         : Token.WHILE,
                        "with"          : Token.WITH,
                        // Future Reserved Words
                        "abstract"      : Token.RESERVED,
                        "boolean"       : Token.RESERVED,
                        "byte"          : Token.RESERVED,
                        "char"          : Token.RESERVED,
                        "class"         : Token.RESERVED,
                        "const"         : Token.RESERVED,
                        "debugger"      : Token.RESERVED,
                        "double"        : Token.RESERVED,
                        "enum"          : Token.RESERVED,
                        "extends"       : Token.RESERVED,
                        "final"         : Token.RESERVED,
                        "float"         : Token.RESERVED,
                        "goto"          : Token.RESERVED,
                        "implements"    : Token.RESERVED,
                        "import"        : Token.IMPORT,
                        "int"           : Token.RESERVED,
                        "interface"     : Token.RESERVED,
                        "long"          : Token.RESERVED,
                        "native"        : Token.RESERVED,
                        "package"       : Token.RESERVED,
                        "private"       : Token.RESERVED,
                        "protected"     : Token.RESERVED,
                        "public"        : Token.RESERVED,
                        "short"         : Token.RESERVED,
                        "static"        : Token.RESERVED,
                        "super"         : Token.RESERVED,
                        "synchronized"  : Token.RESERVED,
                        "throws"        : Token.RESERVED,
                        "transient"     : Token.RESERVED,
                        "volatile"      : Token.RESERVED
                    };

                    function stringToKeyword ( name )
                    {
                        return strIdMap.hasOwnProperty(name) ? strIdMap[name] : Token.EOF;
                    }


                    proto.getLineno = function ( ) { return this.lineno; };

                    proto.getString = function ( ) { return this.string; };

                    proto.eof = function ( ) { return this.hitEOF; };


                    proto.getToken = function ( )
                    {
                        var c;

                        retry:
                            for (;;) {
                                // Eat whitespace, possibly sensitive to newlines.
                                for (;;) {
                                    c = this.getChar();
                                    if ( c === EOF_CHAR ) {
                                        return Token.EOF;
                                    } else if ( c === '\n' ) {
                                        this.dirtyLine = false;
                                        return Token.EOL;
                                    } else if ( !isSpace(c) ) {
                                        if ( c !== '-' ) {
                                            this.dirtyLine = true;
                                        }
                                        break;
                                    }
                                }

                                // identifier/keyword/instanceof?
                                // watch out for starting with a <backslash>
                                var identifierStart      = false;
                                var isUnicodeEscapeStart = false;
                                if ( c === '\\' ) {
                                    c = this.getChar();
                                    if ( c === 'u' ) {
                                        identifierStart      = true;
                                        isUnicodeEscapeStart = true;
                                        this.stringBuffer    = ["\\u"];
                                    } else {
                                        identifierStart = false;
                                        this.ungetChar(c);
                                        c = '\\';
                                    }
                                } else if ( isIdentifierStart(c) ) {
                                    identifierStart   = true;
                                    this.stringBuffer = [c];
                                }

                                if ( identifierStart ) {
                                    var containsEscape = isUnicodeEscapeStart;
                                    for (;;) {
                                        if ( isUnicodeEscapeStart ) {
                                            // strictly speaking we should probably push-back
                                            // all the bad characters if the <backslash>uXXXX
                                            // sequence is malformed. But since there isn't a
                                            // correct context(is there?) for a bad Unicode
                                            // escape sequence in an identifier, we can report
                                            // an error here.
                                            for ( var i=0;  i != 4;  ++i ) {
                                                c = this.getChar();
                                                if ( isHexDigit(c) ) {
                                                    this.addToString(c);
                                                } else {
                                                    this.parser.addError("msg.invalid.escape");
                                                    return Token.ERROR;
                                                }
                                            }
                                            isUnicodeEscapeStart = false;
                                        } else {
                                            c = this.getChar();
                                            if (c == '\\') {
                                                c = this.getChar();
                                                if (c == 'u') {
                                                    this.addToString("\\u");
                                                    isUnicodeEscapeStart = true;
                                                    containsEscape       = true;
                                                } else {
                                                    this.parser.addError("msg.illegal.character");
                                                    return Token.ERROR;
                                                }
                                            } else {
                                                if ( !isIdentifierPart(c) ) break;
                                                this.addToString(c);
                                            }
                                        }
                                    }
                                    this.ungetChar(c);

                                    var str = this.getStringFromBuffer();
                                    if ( !containsEscape ) {
                                        // OPT we shouldn't have to make a string to
                                        // check if it's a keyword.

                                        // Return the corresponding token if it's a keyword
                                        var result = stringToKeyword(str);
                                        if ( result != Token.EOF ) return result;
                                    }
                                    this.string = str;
                                    return Token.NAME;
                                }

                                // is it a number?
                                if ( isDigit(c)  ||  (c==='.' && isDigit(this.peekChar())) ) {
                                    this.stringBuffer = [];
                                    var base = 10;

                                    if ( c === '0' ) {
                                        this.addToString('0');
                                        c = this.getChar();
                                        if ( c === 'x' || c === 'X' ) {
                                            this.addToString(c);
                                            base = 16;
                                            c = this.getChar();
                                        } else if ( isDigit(c) ) {
                                            base = 8;
                                        }
                                    }

                                    if ( base === 16 ) {
                                        while ( isHexDigit(c) ) {
                                            this.addToString(c);
                                            c = this.getChar();
                                        }
                                    } else {
                                        while ( isDigit(c) ) {
                                            /*
                     * We permit 08 and 09 as decimal numbers, which
                     * makes our behavior a superset of the ECMA
                     * numeric grammar.  We might not always be so
                     * permissive, so we warn about it.
                     */
                                            if ( base === 8  &&  (c==='8' || c==='9') ) {
                                                this.parser.addWarning("msg.bad.octal.literal", c == '8' ? "8" : "9");
                                                base = 10;
                                            }
                                            this.addToString(c);
                                            c = this.getChar();
                                        }
                                    }

                                    if ( base === 10 ) {
                                        if ( c === '.' ) {
                                            do {
                                                this.addToString(c);
                                                c = this.getChar();
                                            } while ( isDigit(c) );
                                        }
                                        if ( c === 'e' || c === 'E' ) {
                                            this.addToString(c);
                                            c = this.getChar();
                                            if ( c === '+' || c === '-' ) {
                                                this.addToString(c);
                                                c = this.getChar();
                                            }
                                            if ( !isDigit(c) ) {
                                                this.parser.addError("msg.missing.exponent");
                                                return Token.ERROR;
                                            }
                                            do {
                                                this.addToString(c);
                                                c = this.getChar();
                                            } while ( isDigit(c) );
                                        }
                                    }
                                    this.ungetChar(c);

                                    this.string = this.getStringFromBuffer();
                                    return Token.NUMBER;
                                }

                                // is it a string?
                                if ( c === '"' || c === "'" ) {
                                    var quoteChar = c;
                                    this.stringBuffer = [c];
                                    c = this.getChar();
                                    while ( c !== quoteChar ) {
                                        if ( c === '\n' || c === EOF_CHAR ) {
                                            this.ungetChar(c);
                                            this.parser.addError("msg.unterminated.string.lit");
                                            return Token.ERROR;
                                        }
                                        if ( c === '\\' ) {
                                            this.addToString('\\');
                                            c = this.getChar();
                                            if ( c === '\n' ) {
                                                // Remove line terminator after escape to follow
                                                // SpiderMonkey and C/C++
                                                // But, issue warning since ECMA262-3 does not allow that.
                                                this.parser.addWarning("msg.unsafe.string.lit");
                                            } else {
                                                this.addToString(c);
                                            }
                                        } else {
                                            this.addToString(c);
                                        }
                                        c = this.getChar();
                                    }
                                    this.addToString(quoteChar);
                                    this.string = this.getStringFromBuffer();
                                    return Token.STRING;
                                }

                                switch ( c.charCodeAt(0) ) {
                                    case 0x3B:  // ';'
                                        return Token.SEMI;

                                    case 0x5B:  // '['
                                        return Token.LB;

                                    case 0x5D:  // ']'
                                        return Token.RB;

                                    case 0x7B:  // '{'
                                        return Token.LC;

                                    case 0x7D:  // '}'
                                        return Token.RC;

                                    case 0x28:  // '('
                                        return Token.LP;

                                    case 0x29:  // ')'
                                        return Token.RP;

                                    case 0x2C:  // ','
                                        return Token.COMMA;

                                    case 0x3F:  // '?'
                                        return Token.HOOK;

                                    case 0x40:  // '@'
                                        return Token.XMLATTR;

                                    case 0x3A:  // ':'
                                        if ( this.matchChar(':') ) {
                                            return Token.COLONCOLON;
                                        } else {
                                            return Token.COLON;
                                        }

                                    case 0x2E:  // '.'
                                        if ( this.matchChar('.') ) {
                                            return Token.DOTDOT;
                                        } else if ( this.matchChar('(') ) {
                                            return Token.DOTQUERY;
                                        } else {
                                            return Token.DOT;
                                        }

                                    case 0x7C:  // '|'
                                        if ( this.matchChar('|') ) {
                                            return Token.OR;
                                        } else if ( this.matchChar('=') ) {
                                            return Token.ASSIGN_BITOR;
                                        } else {
                                            return Token.BITOR;
                                        }

                                    case 0x5E:  // '^'
                                        if ( this.matchChar('=') ) {
                                            return Token.ASSIGN_BITXOR;
                                        } else {
                                            return Token.BITXOR;
                                        }

                                    case 0x26:  // '&'
                                        if ( this.matchChar('&') ) {
                                            return Token.AND;
                                        } else if ( this.matchChar('=') ) {
                                            return Token.ASSIGN_BITAND;
                                        } else {
                                            return Token.BITAND;
                                        }

                                    case 0x3D:  // '='
                                        if ( this.matchChar('=') ) {
                                            if ( this.matchChar('=') ) {
                                                return Token.SHEQ;
                                            } else {
                                                return Token.EQ;
                                            }
                                        } else {
                                            return Token.ASSIGN;
                                        }

                                    case 0x21:  // '!'
                                        if ( this.matchChar('=') ) {
                                            if ( this.matchChar('=') ) {
                                                return Token.SHNE;
                                            } else {
                                                return Token.NE;
                                            }
                                        } else {
                                            return Token.NOT;
                                        }

                                    case 0x3C:  // '<'
                                        /* NB:treat HTML begin-comment as comment-till-eol */
                                        if ( this.matchChar('!') ) {
                                            if ( this.matchChar('-') ) {
                                                if ( this.matchChar('-') ) {
                                                    this.skipLine();
                                                    continue retry;
                                                }
                                                this.ungetChar('-');
                                            }
                                            this.ungetChar('!');
                                        }
                                        if ( this.matchChar('<') ) {
                                            if ( this.matchChar('=') ) {
                                                return Token.ASSIGN_LSH;
                                            } else {
                                                return Token.LSH;
                                            }
                                        } else {
                                            if ( this.matchChar('=') ) {
                                                return Token.LE;
                                            } else {
                                                return Token.LT;
                                            }
                                        }

                                    case 0x3E:  // '>'
                                        if ( this.matchChar('>') ) {
                                            if ( this.matchChar('>') ) {
                                                if ( this.matchChar('=') ) {
                                                    return Token.ASSIGN_URSH;
                                                } else {
                                                    return Token.URSH;
                                                }
                                            } else {
                                                if ( this.matchChar('=') ) {
                                                    return Token.ASSIGN_RSH;
                                                } else {
                                                    return Token.RSH;
                                                }
                                            }
                                        } else {
                                            if ( this.matchChar('=') ) {
                                                return Token.GE;
                                            } else {
                                                return Token.GT;
                                            }
                                        }

                                    case 0x2A:  // '*'
                                        if ( this.matchChar('=') ) {
                                            return Token.ASSIGN_MUL;
                                        } else {
                                            return Token.MUL;
                                        }

                                    case 0x2F:  // '/'
                                                // is it a // comment?
                                        if ( this.matchChar('/') ) {
                                            this.skipLine();
                                            continue retry;
                                        } else if ( this.matchChar('*') ) {
                                            for (;;) {
                                                c = this.getChar();
                                                if ( c === EOF_CHAR ) {
                                                    this.parser.addError("msg.unterminated.comment");
                                                    return Token.ERROR;
                                                } else if ( c === '*' ) {
                                                    c = this.getChar();
                                                    if ( c === '/' ) {
                                                        continue retry;
                                                    }
                                                }
                                            }
                                        } else if ( this.matchChar('=') ) {
                                            return Token.ASSIGN_DIV;
                                        } else {
                                            return Token.DIV;
                                        }

                                    case 0x25:  // '%'
                                        if ( this.matchChar('=') ) {
                                            return Token.ASSIGN_MOD;
                                        } else {
                                            return Token.MOD;
                                        }

                                    case 0x7E:  // '~'
                                        return Token.BITNOT;

                                    case 0x2B:  // '+'
                                        if ( this.matchChar('=') ) {
                                            return Token.ASSIGN_ADD;
                                        } else if ( this.matchChar('+') ) {
                                            return Token.INC;
                                        } else {
                                            return Token.ADD;
                                        }

                                    case 0x2D:  // '-'
                                        if ( this.matchChar('=') ) {
                                            c = Token.ASSIGN_SUB;
                                        } else if ( this.matchChar('-') ) {
                                            if ( !this.dirtyLine ) {
                                                // treat HTML end-comment after possible whitespace
                                                // after line start as comment-untill-eol
                                                if ( this.matchChar('>')) {
                                                    this.skipLine();
                                                    continue retry;
                                                }
                                            }
                                            c = Token.DEC;
                                        } else {
                                            c = Token.SUB;
                                        }
                                        this.dirtyLine = true;
                                        return c;

                                    default:
                                        parser.addError("msg.illegal.character");
                                        return Token.ERROR;
                                }
                            }
                    };



                    /**
                     * Parser calls the method when it gets / or /= in literal context.
                     */
                    proto.readRegExp = function ( startToken )
                    {
                        if ( startToken === Token.ASSIGN_DIV ) {
                            // Miss-scanned /=
                            this.stringBuffer = ["/="];
                        } else if ( startToken === Token.DIV ) {
                            this.stringBuffer = ["/"];
                        } else {
                            Kit.codeBug();
                        }

                        var c;
                        while ( (c = this.getChar()) !== '/' ) {
                            if ( c === '\n' || c === EOF_CHAR ) {
                                this.ungetChar(c);
                                throw this.parser.reportError("msg.unterminated.re.lit");
                            }
                            if ( c === '\\' ) {
                                this.addToString(c);
                                c = this.getChar();
                            }
                            this.addToString(c);
                        }
                        this.addToString("/");

                        while ( isIdentifierPart(c = this.getChar()) ) {
                            this.addToString(c);
                        }
                        this.ungetChar(c);

                        this.string = this.getStringFromBuffer();
                    }


                    proto.isXMLAttribute = function ( )
                    {
                        return this.xmlIsAttribute;
                    };

                    proto.getFirstXMLToken = function ( )
                    {
                        this.xmlOpenTagsCount = 0;
                        this.xmlIsAttribute   = false;
                        this.xmlIsTagContent  = false;
                        this.ungetChar('<');
                        return this.getNextXMLToken();
                    };

                    proto.getNextXMLToken = function ( )
                    {
                        this.stringBuffer = []; // remember the XML

                        for ( var c=this.getChar();  c !== EOF_CHAR;  c=this.getChar() ) {
                            if ( this.xmlIsTagContent ) {
                                switch ( c.charCodeAt(0) ) {
                                    case 0x3E:  // '>'
                                        this.addToString('>');
                                        this.xmlIsTagContent = false;
                                        this.xmlIsAttribute  = false;
                                        break;
                                    case 0x2F:  // '/'
                                        this.addToString('/');
                                        if ( this.matchChar('>') ) {
                                            this.addToString('>');
                                            this.xmlIsTagContent = false;
                                            this.xmlOpenTagsCount--;
                                        }
                                        break;
                                    case 0x7B:  // '{'
                                        this.ungetChar('{');
                                        this.string = this.getStringFromBuffer();
                                        return Token.XML;
                                    case 0x27:  // "'"
                                    case 0x22:  // '"'
                                        this.addToString(c);
                                        if ( !this.readQuotedString(c) ) return Token.ERROR;
                                        break;
                                    case 0x3D:  // '='
                                        this.addToString('=');
                                        this.xmlIsAttribute = true;
                                        break;
                                    case 0x20:  // ' '
                                    case 0x09:  // '\t'
                                    // case 0x0D:  // '\r'  CR never comes here because of the implementation of getChar().
                                    case 0x0A:  // '\n'
                                        this.addToString(c);
                                        break;
                                    default:
                                        this.addToString(c);
                                        this.xmlIsAttribute = false;
                                        break;
                                }

                                if ( !this.xmlIsTagContent  &&  this.xmlOpenTagsCount === 0 ) {
                                    this.string = this.getStringFromBuffer();
                                    return Token.XMLEND;
                                }
                            } else {
                                switch ( c.charCodeAt(0) ) {
                                    case 0x3C:  // '<'
                                        this.addToString('<');
                                        c = this.getChar();
                                        switch ( c.charCodeAt(0) ) {
                                            case 0x21:  // '!'
                                                this.addToString('!');
                                                c = this.getChar();
                                                switch ( c.charCodeAt(0) ) {
                                                    case 0x2D:  // '-'
                                                        if ( this.getChar() === '-' ) {
                                                            this.addToString('--');
                                                            if ( !this.readXmlComment() ) return Token.ERROR;
                                                        } else {
                                                            this.parser.addError("msg.XML.bad.form");
                                                            return Token.ERROR;
                                                        }
                                                        break;
                                                    case 0x5B:  // '['
                                                        if ( this.getChar() === 'C' &&
                                                            this.getChar() === 'D' &&
                                                            this.getChar() === 'A' &&
                                                            this.getChar() === 'T' &&
                                                            this.getChar() === 'A' &&
                                                            this.getChar() === '['    )
                                                        {
                                                            this.addToString('[CDATA[');
                                                            if ( !this.readCDATA() ) return Token.ERROR;
                                                        } else {
                                                            this.parser.addError("msg.XML.bad.form");
                                                            return Token.ERROR;
                                                        }
                                                        break;
                                                    default:
                                                        this.ungetChar(c);
                                                        if( !this.readEntity() ) return Token.ERROR;
                                                        break;
                                                }
                                                break;
                                            case 0x3F:  // '?'
                                                this.addToString('?');
                                                if ( !this.readPI() ) return Token.ERROR;
                                                break;
                                            case 0x2F:  // '/'
                                                // End tag
                                                this.addToString('/');
                                                if ( this.xmlOpenTagsCount === 0 ) {
                                                    this.parser.addError("msg.XML.bad.form");
                                                    return Token.ERROR;
                                                }
                                                this.xmlIsTagContent = true;
                                                this.xmlOpenTagsCount--;
                                                break;
                                            default:
                                                // Start tag
                                                this.ungetChar(c);
                                                this.xmlIsTagContent = true;
                                                this.xmlOpenTagsCount++;
                                                break;
                                        }
                                        break;
                                    case 0x7B:  // '{'
                                        this.ungetChar('{');
                                        this.string = this.getStringFromBuffer();
                                        return Token.XML;
                                    default:
                                        this.addToString(c);
                                        break;
                                }
                            }
                        }

                        this.parser.addError("msg.XML.bad.form");
                        return Token.ERROR;
                    };

                    proto.readQuotedString = function ( quote )
                    {
                        for ( var c=this.getChar();  c !== EOF_CHAR;  c=this.getChar() ) {
                            this.addToString(c);
                            if ( c === quote ) return true;
                        }
                        parser.addError("msg.XML.bad.form");
                        return false;
                    };

                    proto.readXmlComment = function ( )
                    {
                        for ( var c=this.getChar();  c !== EOF_CHAR; ) {
                            this.addToString(c);
                            if ( c === '-'  &&  this.matchChar('-') ) {
                                this.addToString('-');
                                if ( this.matchChar('>') ) {
                                    this.addToString('>');
                                    return true;
                                } else {
                                    // Strictly, XMLComment MUST NOT include the sequence "--".
                                    // So, if the program execution is here, the source is
                                    // syntactically wrong, according to ECMA367. However, we
                                    // allow the sequence here, so that our syntax is super-set
                                    // of the specification.
                                    c = '-';
                                    continue;
                                }
                            }
                            c = this.getChar();
                        }
                        this.parser.addError("msg.XML.bad.form");
                        return false;
                    };

                    proto.readCDATA = function ( )
                    {
                        for ( var c=this.getChar();  c !== EOF_CHAR; ) {
                            this.addToString(c);
                            if ( c === ']'  &&  this.matchChar(']') ) {
                                this.addToString(']');
                                if ( this.matchChar('>') ) {
                                    this.addToString('>');
                                    return true;
                                } else {
                                    c = ']';
                                    continue;
                                }
                            }
                            c = this.getChar();
                        }
                        this.parser.addError("msg.XML.bad.form");
                        return false;
                    };

                    proto.readEntity = function ( )
                    {
                        var declTags = 1;
                        for ( var c=this.getChar();  c !== EOF_CHAR;  c=this.getChar() ) {
                            this.addToString(c);
                            switch ( c ) {
                                case '<':
                                    declTags++;
                                    break;
                                case '>':
                                    declTags--;
                                    if ( declTags === 0 ) return true;
                                    break;
                            }
                        }
                        this.parser.addError("msg.XML.bad.form");
                        return false;
                    };

                    proto.readPI = function ( )
                    {
                        for ( var c=this.getChar();  c !== EOF_CHAR;  c=this.getChar() ) {
                            this.addToString(c);
                            if ( c === '?'  &&  this.matchChar('>') ) {
                                this.addToString('>');
                                return true;
                            }
                        }
                        this.parser.addError("msg.XML.bad.form");
                        return false;
                    };


                    proto.getStringFromBuffer = function ( )
                    {
                        return this.stringBuffer.join("");
                    };

                    proto.addToString = function ( /* variable arguments */ )
                    {
                        this.stringBuffer.push.apply(this.stringBuffer, arguments);
                    };

                    proto.ungetChar = function ( c )
                    {
                        // can not unread past across line boundary
                        if ( this.ungetBuffer.length && this.ungetBuffer[this.ungetBuffer.length-1] == '\n') Kit.codeBug();
                        this.ungetBuffer.push(c);
                    };

                    proto.matchChar = function ( test )
                    {
                        var c = this.getChar();
                        if ( c === test ) {
                            return true;
                        } else {
                            this.ungetChar(c);
                            return false;
                        }
                    };

                    proto.peekChar = function ( )
                    {
                        var c = this.getChar();
                        this.ungetChar(c);
                        return c;
                    };

                    proto.getChar = function ( )
                    {
                        if ( this.ungetBuffer.length ) return this.ungetBuffer.pop();

                        for ( ;; ) {
                            if ( this.sourceCursor == this.sourceEnd ) {
                                this.hitEOF = true;
                                return EOF_CHAR;
                            }
                            var c = this.sourceString.charAt(this.sourceCursor++);

                            if ( this.lineEndChar ) {
                                if ( this.lineEndChar == '\r' && c == '\n') {
                                    this.lineEndChar = '\n';
                                    continue;
                                }
                                this.lineEndChar = undefined;
                                this.lineStart   = this.sourceCursor - 1;
                                this.lineno++;
                            }

                            if ( isLineTerminator(c) ) {
                                this.lineEndChar = c;
                                c = '\n';
                            }
                            if ( isFormatChar(c) ) {
                                continue;
                            }
                            return c;
                        }
                    };

                    proto.skipLine = function ( )
                    {
                        // skip to end of line
                        var c;
                        while ((c=this.getChar()) != EOF_CHAR && c != '\n') { }
                        this.ungetChar(c);
                    };

                    proto.getOffset = function ( )
                    {
                        var n = this.sourceCursor - this.lineStart;
                        if ( this.lineEndChar ) { --n; }
                        return n;
                    };

                    proto.getLine = function ( )
                    {
                        var lineEnd = this.sourceCursor;
                        if ( this.lineEndChar ) {
                            --lineEnd;
                        } else {
                            for (; lineEnd != this.sourceEnd; ++lineEnd) {
                                var c = this.sourceString.charAt(lineEnd);
                                if ( isLineTerminator(c) ) {
                                    break;
                                }
                            }
                        }
                        return this.sourceString.substring(this.lineStart, lineEnd);
                    };


                    return {
                        TokenStream: TokenStream
                    };
                }();
            }
        }.call(null) ) {
            this.Concurrent.Thread.Compiler.TokenStream = TokenStream;
        }
    }).call(null);
    (function(){
        if ( !this.Concurrent || (typeof this.Concurrent != 'object' && typeof this.Concurrent != 'function') ) this.Concurrent = new Object();
        if ( !this.Concurrent.Thread || (typeof this.Concurrent.Thread != 'object' && typeof this.Concurrent.Thread != 'function') ) this.Concurrent.Thread = new Object();
        if ( !this.Concurrent.Thread.Compiler || (typeof this.Concurrent.Thread.Compiler != 'object' && typeof this.Concurrent.Thread.Compiler != 'function') ) this.Concurrent.Thread.Compiler = new Object();
        if ( !this.Concurrent.Thread.Compiler.IntermediateLanguage || (typeof this.Concurrent.Thread.Compiler.IntermediateLanguage != 'object' && typeof this.Concurrent.Thread.Compiler.IntermediateLanguage != 'function') ) this.Concurrent.Thread.Compiler.IntermediateLanguage = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Cons || (typeof this.Data.Cons != 'object' && typeof this.Data.Cons != 'function') ) this.Data.Cons = new Object();
        if ( !this.Data.Cons.Util || (typeof this.Data.Cons.Util != 'object' && typeof this.Data.Cons.Util != 'function') ) this.Data.Cons.Util = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Cons || (typeof this.Data.Cons != 'object' && typeof this.Data.Cons != 'function') ) this.Data.Cons = new Object();
        if ( this.Concurrent.Thread.Compiler.IntermediateLanguage.Function === undefined ) this.Concurrent.Thread.Compiler.IntermediateLanguage.Function = undefined;
        if ( this.Concurrent.Thread.Compiler.IntermediateLanguage.Block === undefined ) this.Concurrent.Thread.Compiler.IntermediateLanguage.Block = undefined;
        if ( this.Concurrent.Thread.Compiler.IntermediateLanguage.GotoBlock === undefined ) this.Concurrent.Thread.Compiler.IntermediateLanguage.GotoBlock = undefined;
        if ( this.Concurrent.Thread.Compiler.IntermediateLanguage.CallBlock === undefined ) this.Concurrent.Thread.Compiler.IntermediateLanguage.CallBlock = undefined;
        if ( this.Concurrent.Thread.Compiler.IntermediateLanguage.NewBlock === undefined ) this.Concurrent.Thread.Compiler.IntermediateLanguage.NewBlock = undefined;
        if ( this.Concurrent.Thread.Compiler.IntermediateLanguage.Statement === undefined ) this.Concurrent.Thread.Compiler.IntermediateLanguage.Statement = undefined;
        if ( this.Concurrent.Thread.Compiler.IntermediateLanguage.ExpStatement === undefined ) this.Concurrent.Thread.Compiler.IntermediateLanguage.ExpStatement = undefined;
        if ( this.Concurrent.Thread.Compiler.IntermediateLanguage.CondStatement === undefined ) this.Concurrent.Thread.Compiler.IntermediateLanguage.CondStatement = undefined;
        if ( this.Concurrent.Thread.Compiler.IntermediateLanguage.RecvStatement === undefined ) this.Concurrent.Thread.Compiler.IntermediateLanguage.RecvStatement = undefined;
        if ( this.Concurrent.Thread.Compiler.IntermediateLanguage.EnumStatement === undefined ) this.Concurrent.Thread.Compiler.IntermediateLanguage.EnumStatement = undefined;
        with ( function(){
            with ( Data.Cons.Util ) {
                with ( Data.Cons ) {
                    with ( Concurrent.Thread.Compiler.IntermediateLanguage ) {

                        return function () {
                            var VERSION = '0.0.0';
                            var NAMESPACE;

                            /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Concurrent.Thread code.
 *
 * The Initial Developer of the Original Code is
 * Daisuke Maki.
 * Portions created by the Initial Developer are Copyright (C) 2006-2007
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */



                            NAMESPACE = 'Concurrent.Thread.Compiler.IntermediateLanguage';














                            function Function ( name, params, vars, body, start ) {
                                this.name   = name;    // Identifier | Null
                                this.params = params;  // [Identifier]
                                this.vars   = vars;    // [Identifier]
                                this.body   = body;    // <Block>
                                this.start  = start;   // Block
                            }

                            Function.prototype.toString = function ( ) {
                                return  [ "function ", this.name, "( ", this.params.join(", "), " ) {\n",
                                    "  var ", this.vars.join(", "), ";\n",
                                    this.body.join("\n").replace(/^/mg, "  "),
                                    "\n}" ].join("");
                            };



                            var block_id = 0;

                            function Block ( scopes, body, target, exception ) {
                                this.id        = "label" + block_id++;
                                this.scopes    = scopes;     // [Expression]
                                this.body      = body;       // <Statement>
                                this.target    = target;     // Block | "return" | "throw"
                                this.exception = exception;  // Block | "return" | "throw"
                            }

                            var proto = Block.prototype;

                            proto.toString = function ( ) {
                                Kit.codeBug('"toString" is not implemented for ', this.constructor);
                            };

                            proto.appendStatement = function ( /* variable arguments */ ) {
                                var args = arguments;
                                if ( this.body.isNil() ) {
                                    this.body = cons(arguments[0], this.body);
                                    args = Array.prototype.slice.call(arguments, 1, arguments.length);
                                } else {
                                    adder(this.body).apply(null, args);
                                }
                            };

                            proto.prependStatement = function ( /* variable arguments */ ) {
                                for ( var i=arguments.length-1;  i >= 0;  i-- ) {
                                    this.body = cons(arguments[i], this.body);
                                }
                            };


                            function stringify ( b ) {
                                if ( b instanceof Block ) {
                                    return b.id;
                                } else {
                                    return '"' + b + '"';
                                }
                            }



                            function GotoBlock ( scopes, body, arg, target, exception ) {
                                Block.call(this, scopes, body, target, exception);
                                this.arg = arg;
                            }

                            var proto = GotoBlock.prototype = new Block();

                            proto.constructor = GotoBlock;

                            proto.toString = function ( ) {
                                return [ this.id, "([", this.scopes.join(", "), "], ", stringify(this.exception), "): {\n",
                                    this.body.join("\n").replace(/^/mg, "  "), "\n",
                                    "  goto ", this.arg, " -> ", stringify(this.target), "\n",
                                    "}" ].join("");
                            };



                            function CallBlock ( scopes, body, this_val, func, args, target, exception ) {
                                Block.call(this, scopes, body, target, exception);
                                this.this_val  = this_val;   // Expression
                                this.func      = func;       // Expression
                                this.args      = args;       // [Expression]
                            }

                            var proto = CallBlock.prototype = new Block();

                            proto.constructor = CallBlock;

                            proto.toString = function ( ) {
                                return [ this.id, "([", this.scopes.join(", "), "], ", stringify(this.exception), "): {\n",
                                    this.body.join("\n").replace(/^/mg, "  "), "\n",
                                    "  call ", this.this_val, ".", this.func, "(", this.args.join(", "), ") -> ", stringify(this.target), "\n",
                                    "}" ].join("");
                            };



                            function NewBlock ( scopes, body, func, args, target, exception ) {
                                Block.call(this, scopes, body, target, exception);
                                this.func      = func;       // Expression
                                this.args      = args;       // [Expression]
                            }

                            var proto = NewBlock.prototype = new Block();

                            proto.constructor = NewBlock;

                            proto.toString = function ( ) {
                                return [ this.id, "([", this.scopes.join(", "), "], ", stringify(this.exception), "): {\n",
                                    this.body.join("\n").replace(/^/mg, "  "), "\n",
                                    "  new ", this.func, "(", this.args.join(", "), ") -> ", stringify(this.target), "\n",
                                    "}" ].join("");
                            };




                            function Statement ( ) {
                                // This is kind of interface.
                            }

                            Statement.prototype.toString = function ( ) {
                                Kit.codeBug('"toString" is not implemented for ', this.constructor);
                            };



                            function ExpStatement ( e ) {
                                this.exp = e;  // Expression
                            }

                            var proto = ExpStatement.prototype = new Statement();

                            proto.constructor = ExpStatement;

                            proto.toString = function ( ) {
                                return this.exp + ";";
                            };



                            function CondStatement ( c, t ) {
                                this.cond   = c;  // Expression
                                this.target = t;  // Block
                            }

                            var proto = CondStatement.prototype = new Statement();

                            proto.constructor = CondStatement;

                            proto.toString = function ( ) {
                                return [ "if ", this.cond, " -> ", stringify(this.target), ";" ].join("");
                            };



                            function RecvStatement ( a ) {
                                this.assignee = a;  // Identifier | DotAccessor | BracketAccessor
                            }

                            var proto = RecvStatement.prototype = new Statement();

                            proto.constructor = RecvStatement;

                            proto.toString = function ( ) {
                                return [ "recv ", this.assignee, ";" ].join("");
                            };



                            function EnumStatement ( e, a ) {
                                this.exp      = e;  // Expression
                                this.assignee = a;  // Identifier | DotAccessor | BracketAccessor
                            }

                            var proto = EnumStatement.prototype = new Statement();

                            proto.constructor = EnumStatement;

                            proto.toString = function ( ) {
                                return [ "enum ", this.assignee, " <- ", this.exp, ";" ].join("");
                            };

                            return {
                                Block: Block, RecvStatement: RecvStatement, GotoBlock: GotoBlock, Function: Function, NewBlock: NewBlock, ExpStatement: ExpStatement, CallBlock: CallBlock, EnumStatement: EnumStatement, Statement: Statement, CondStatement: CondStatement
                            };
                        }();
                    }
                }
            }
        }.call(null) ) {
            this.Concurrent.Thread.Compiler.IntermediateLanguage.Block = Block;
            this.Concurrent.Thread.Compiler.IntermediateLanguage.RecvStatement = RecvStatement;
            this.Concurrent.Thread.Compiler.IntermediateLanguage.GotoBlock = GotoBlock;
            this.Concurrent.Thread.Compiler.IntermediateLanguage.Function = Function;
            this.Concurrent.Thread.Compiler.IntermediateLanguage.NewBlock = NewBlock;
            this.Concurrent.Thread.Compiler.IntermediateLanguage.ExpStatement = ExpStatement;
            this.Concurrent.Thread.Compiler.IntermediateLanguage.CallBlock = CallBlock;
            this.Concurrent.Thread.Compiler.IntermediateLanguage.EnumStatement = EnumStatement;
            this.Concurrent.Thread.Compiler.IntermediateLanguage.Statement = Statement;
            this.Concurrent.Thread.Compiler.IntermediateLanguage.CondStatement = CondStatement;
        }
    }).call(null);
    (function(){
        if ( !this.Concurrent || (typeof this.Concurrent != 'object' && typeof this.Concurrent != 'function') ) this.Concurrent = new Object();
        if ( !this.Concurrent.Thread || (typeof this.Concurrent.Thread != 'object' && typeof this.Concurrent.Thread != 'function') ) this.Concurrent.Thread = new Object();
        if ( !this.Concurrent.Thread.Compiler || (typeof this.Concurrent.Thread.Compiler != 'object' && typeof this.Concurrent.Thread.Compiler != 'function') ) this.Concurrent.Thread.Compiler = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Cons || (typeof this.Data.Cons != 'object' && typeof this.Data.Cons != 'function') ) this.Data.Cons = new Object();
        if ( this.Concurrent.Thread.Compiler.CssConvert === undefined ) this.Concurrent.Thread.Compiler.CssConvert = undefined;
        with ( function(){
            with ( Data.Cons ) {
                with ( Concurrent.Thread.Compiler ) {

                    return function () {
                        var VERSION ;
                        var NAMESPACE;

                        /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Concurrent.Thread code.
 *
 * The Initial Developer of the Original Code is
 * Daisuke Maki.
 * Portions created by the Initial Developer are Copyright (C) 2006-2007
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */


                        NAMESPACE = 'Concurrent.Thread.Compiler';












                        var Css = "Concurrent.Thread.Compiler.CssConvert";



                        function CssConvert ( func ) {
                            return func[Css]();
                        }


                        Statement.prototype[Css] = function ( ) {
                            Kit.codeBug("unimplemented '" + Css + "' method for: " + this);
                        };

                        EmptyStatement.prototype[Css] = function ( ) {
                            return this;
                        };

                        Block.prototype[Css] = function ( ) {
                            var head = last = cons(null, nil());
                            for ( var c=this.body;  !c.isNil();  c=c.cdr ) {
                                last = last.cdr = cons(c.car[Css](), last.cdr);
                            }
                            return new Block(this.labels, head.cdr, this.lineno, this.source);
                        };

                        ExpStatement.prototype[Css] = function ( ) {
                            return new ExpStatement(this.labels, this.exp[Css](), this.lineno, this.source);
                        };

                        VarStatement.prototype[Css] = function ( ) {
                            var decls = [];
                            for ( var i=0;  i < this.decls.length;  i++ ) {
                                decls[i] = {
                                    id : this.decls[i].id,
                                    exp: this.decls[i].exp ? this.decls[i].exp[Css]() : null
                                };
                            }
                            return new VarStatement(this.labels, decls, this.lineno, this.source);
                        };

                        IfStatement.prototype[Css] = function ( ) {
                            return new IfStatement(this.labels, this.cond[Css](), this.body[Css](), this.lineno, this.source);
                        };

                        IfElseStatement.prototype[Css] = function ( ) {
                            return new IfElseStatement(this.labels, this.cond[Css](), this.tbody[Css](), this.fbody[Css](), this.lineno, this.source);
                        };

                        DoWhileStatement.prototype[Css] = function ( ) {
                            return new DoWhileStatement(this.labels, this.body[Css](), this.cond[Css](), this.lineno, this.source);
                        };

                        WhileStatement.prototype[Css] = function ( ) {
                            return new WhileStatement(this.labels, this.cond[Css](), this.body[Css](), this.lineno, this.source);
                        };

                        ForStatement.prototype[Css] = function ( ) {
                            return new ForStatement(
                                this.labels,
                                this.init ? this.init[Css]() : null,
                                this.cond ? this.cond[Css]() : null,
                                this.incr ? this.incr[Css]() : null,
                                this.body[Css](),
                                this.lineno,
                                this.source
                            );
                        };

                        ForVarStatement.prototype[Css] = function ( ) {
                            var decls = [];
                            for ( var i=0;  i < this.decls.length;  i++ ) {
                                decls[i] = {
                                    id : this.decls[i].id,
                                    exp: this.decls[i].exp ? this.decls[i].exp[Css]() : null
                                };
                            }
                            return new ForVarStatement(
                                this.labels,
                                decls,
                                this.cond ? this.cond[Css]() : null,
                                this.incr ? this.incr[Css]() : null,
                                this.body[Css](),
                                this.lineno,
                                this.source
                            );
                        };

                        ForInStatement.prototype[Css] = function ( ) {
                            return new ForInStatement(this.labels, this.lhs[Css](), this.exp[Css](), this.body[Css](), this.lineno, this.source);
                        };

                        ForInVarStatement.prototype[Css] = function ( ) {
                            var decl = {
                                id : this.decl.id,
                                exp: this.decl.exp ? this.decl.exp[Css]() : null
                            };
                            return new ForInVarStatement(this.labels, decl, this.exp[Css](), this.body[Css](), this.lineno, this.source);
                        };

                        ForEachStatement.prototype[Css] = function ( ) {
                            return new ForEachStatement(this.labels, this.lhs[Css](), this.exp[Css](), this.body[Css](), this.lineno, this.source);
                        };

                        ForEachVarStatement.prototype[Css] = function ( ) {
                            var decl = {
                                id : this.decl.id,
                                exp: this.decl.exp ? this.decl.exp[Css]() : null
                            };
                            return new ForEachVarStatement(this.labels, decl, this.exp[Css](), this.body[Css](), this.lineno, this.source);
                        };

                        ContinueStatement.prototype[Css] = function ( ) {
                            return this;
                        };

                        BreakStatement.prototype[Css] = function ( ) {
                            return this;
                        };

                        ReturnStatement.prototype[Css] = function ( ) {
                            if ( !this.exp ) return this;
                            return new ReturnStatement(this.labels, this.exp[Css](), this.lineno, this.source);
                        };

                        WithStatement.prototype[Css] = function ( ) {
                            return new WithStatement(this.labels, this.exp[Css](), this.body[Css](), this.lineno, this.source);
                        };

                        SwitchStatement.prototype[Css] = function ( ) {
                            var head = last = cons(null, nil());
                            for ( var c=this.clauses;  !c.isNil();  c=c.cdr ) {
                                last = last.cdr = cons(c.car[Css](), last.cdr);
                            }
                            return new SwitchStatement(this.labels, this.exp[Css](), head.cdr, this.lineno, this.source);
                        };

                        CaseClause.prototype[Css] = function ( ) {
                            var head = last = cons(null, nil());
                            for ( var c=this.body;  !c.isNil();  c=c.cdr ) {
                                last = last.cdr = cons(c.car[Css](), last.cdr);
                            }
                            return new CaseClause(this.exp[Css](), head.cdr, this.lineno, this.source);
                        };

                        DefaultClause.prototype[Css] = function ( ) {
                            var head = last = cons(null, nil());
                            for ( var c=this.body;  !c.isNil();  c=c.cdr ) {
                                last = last.cdr = cons(c.car[Css](), last.cdr);
                            }
                            return new DefaultClause(head.cdr, this.lineno, this.source);
                        };

                        ThrowStatement.prototype[Css] = function ( ) {
                            return new ThrowStatement(this.labels, this.exp[Css](), this.lineno, this.source);
                        };

                        TryCatchStatement.prototype[Css] = function ( ) {
                            return new TryCatchStatement(this.labels, this.tryBlock[Css](), this.variable, this.catchBlock[Css](), this.lineno, this.source);
                        };

                        TryFinallyStatement.prototype[Css] = function ( ) {
                            return new TryFinallyStatement(this.labels, this.tryBlock[Css](), this.finallyBlock[Css](), this.lineno, this.source);
                        };

                        TryCatchFinallyStatement.prototype[Css] = function ( ) {
                            return new TryCatchFinallyStatement(this.labels, this.tryBlock[Css](), this.variable, this.catchBlock[Css](), this.finallyBlock[Css](), this.lineno, this.source);
                        };

                        TryCatchListStatement.prototype[Css] = function ( ) {
                            if ( this.catchList.isNil() ) {  // no more catch-guard
                                var block = this.tryBlock[Css]();
                                block.labels = this.labels;
                                return block;
                            } else if ( this.catchList.car.cond ) {  // one or more qualified catch-guard
                                var guard = this.catchList.car;
                                return new TryCatchStatement(
                                    this.labels,
                                    this.tryBlock[Css](),
                                    guard.variable,
                                    new Block([], list(
                                        new IfElseStatement(
                                            [],
                                            guard.cond[Css](),
                                            guard.block[Css](),
                                            (new TryCatchListStatement(
                                                [],
                                                new Block([], list(new ThrowStatement([], guard.variable))),
                                                this.catchList.cdr,
                                                this.catchList.cdr.lineno, this.cdr.cdr.source
                                            ))[Css](),
                                            guard.lineno, guard.source
                                        )
                                    ))
                                );
                            } else {  // (only one) default catch-guard
                                var guard = this.catchList.car;
                                return new TryCatchStatement(this.labels, this.tryBlock[Css](), guard.variable, guard.block[Css](), this.lineno, this.source);
                            }
                        };

                        TryCatchListFinallyStatement.prototype[Css] = function ( ) {
                            return new TryFinallyStatement(
                                this.labels,
                                new Block([], list(
                                    (new TryCatchListStatement([],
                                        this.tryBlock,
                                        this.catchList,
                                        this.lineno,
                                        this.source
                                    ))[Css]()
                                ), this.lineno, this.source),
                                this.finallyBlock[Css](),
                                this.lineno, this.source
                            );
                        };

                        FunctionDeclaration.prototype[Css] = function ( ) {
                            var head = last = cons(null, nil());
                            for ( var c=this.body;  !c.isNil();  c=c.cdr ) {
                                last = last.cdr = cons(c.car[Css](), last.cdr);
                            }
                            return new FunctionDeclaration(this.labels, this.name, this.params, head.cdr, this.lineno, this.source);
                        };



                        Expression.prototype[Css] = Statement.prototype[Css];

                        UnaryExpression.prototype[Css] = function ( ) {
                            return new this.constructor( this.exp[Css]() );
                        };

                        BinaryExpression.prototype[Css] = function ( ) {
                            return new this.constructor(this.left[Css](), this.right[Css]());
                        };

                        Literal.prototype[Css]        =
                            Identifier.prototype[Css]     =
                                ThisExpression.prototype[Css] =
                                    Elision.prototype[Css]        = function ( ) {
                                        return this;
                                    };

                        ArrayInitializer.prototype[Css] = function ( ) {
                            var elems = [];
                            for ( var i=0;  i < this.elems.length;  i++ ) {
                                elems[i] = this.elems[i][Css]();
                            }
                            return new ArrayInitializer(elems);
                        };

                        ObjectInitializer.prototype[Css] = function ( ) {
                            var pairs = [];
                            for ( var i=0;  i < this.pairs.length;  i++ ) {
                                pairs[i] = {prop:this.pairs[i].prop, exp:this.pairs[i].exp[Css]()};
                            }
                            return new ObjectInitializer(pairs);
                        };

                        FunctionExpression.prototype[Css] = function ( ) {
                            var head = last = cons(null, nil());
                            for ( var c=this.body;  !c.isNil();  c=c.cdr ) {
                                last = last.cdr = cons(c.car[Css](), last.cdr);
                            }
                            return new FunctionExpression(this.name, this.params, head.cdr);
                        };

                        DotAccessor.prototype[Css] = function ( ) {
                            return new DotAccessor(this.base[Css](), this.prop);
                        };

                        NewExpression.prototype[Css]  =
                            CallExpression.prototype[Css] = function ( ) {
                                var args = [];
                                for ( var i=0;  i < this.args.length;  i++ ) {
                                    args[i] = this.args[i][Css]();
                                }
                                return new this.constructor(this.func[Css](), args);
                            };

                        ConditionalExpression.prototype[Css] = function ( ) {
                            return new ConditionalExpression(this.cond[Css](), this.texp[Css](), this.fexp[Css]());
                        };

                        return {
                            CssConvert: CssConvert
                        };
                    }();
                }
            }
        }.call(null) ) {
            this.Concurrent.Thread.Compiler.CssConvert = CssConvert;
        }
    }).call(null);
    (function(){
        if ( !this.Concurrent || (typeof this.Concurrent != 'object' && typeof this.Concurrent != 'function') ) this.Concurrent = new Object();
        if ( !this.Concurrent.Thread || (typeof this.Concurrent.Thread != 'object' && typeof this.Concurrent.Thread != 'function') ) this.Concurrent.Thread = new Object();
        if ( !this.Concurrent.Thread.Compiler || (typeof this.Concurrent.Thread.Compiler != 'object' && typeof this.Concurrent.Thread.Compiler != 'function') ) this.Concurrent.Thread.Compiler = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Error || (typeof this.Data.Error != 'object' && typeof this.Data.Error != 'function') ) this.Data.Error = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Cons || (typeof this.Data.Cons != 'object' && typeof this.Data.Cons != 'function') ) this.Data.Cons = new Object();
        if ( this.Concurrent.Thread.Compiler.Parser === undefined ) this.Concurrent.Thread.Compiler.Parser = undefined;
        with ( function(){
            with ( Data.Cons ) {
                with ( Data ) {
                    with ( Data.Error ) {
                        with ( Concurrent.Thread.Compiler ) {

                            return function () {
                                var VERSION = '0.0.0';
                                var NAMESPACE;

                                /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Rhino code, released
 * May 6, 1999.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1997-1999
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Mike Ang
 *   Igor Bukanov
 *   Yuh-Ruey Chen
 *   Ethan Hugg
 *   Terry Lucas
 *   Mike McCabe
 *   Milen Nankov
 *   Daisuke Maki
 *
 * Alternatively, the contents of this file may be used under the terms of
 * the GNU General Public License Version 2 or later (the "GPL"), in which
 * case the provisions of the GPL are applicable instead of those above. If
 * you wish to allow use of your version of this file only under the terms of
 * the GPL and not to allow others to use your version of this file under the
 * MPL, indicate your decision by deleting the provisions above and replacing
 * them with the notice and other provisions required by the GPL. If you do
 * not delete the provisions above, a recipient may use your version of this
 * file under either the MPL or the GPL.
 *
 * ***** END LICENSE BLOCK ***** */

                                /**
                                 * This file is based on the file Parser.java in Rhino 1.6R5.
                                 */





                                NAMESPACE = 'Concurrent.Thread.Compiler';





















// TokenInformation flags : flaggedTokenBuffer stores them together
// with token type
                                var CLEAR_TI_MASK  = 0xFFFF;   // mask to clear token information bits
                                var TI_AFTER_EOL   = 1 << 16;  // first token of the source line
                                var TI_CHECK_LABEL = 1 << 17;  // indicates to check for label


// Exception to unwind
                                var ParserException = Exception.extend(
                                    function($super, message){ $super(message); },
                                    { name: NAMESPACE + ".ParserException" }
                                );

// Exception to return statement-label
                                function LabelException ( label ) {
                                    this.label = label;  // Identifier
                                }


// default error reporter
                                var defaultReporter = new ErrorReporter();
                                defaultReporter.error = function ( message, line, lineSource, lineOffset ) {
                                    throw new SyntaxError("(" + line + ", " + lineOffset + "): " + message + "\nline: " + lineSource);
                                };



                                function Parser ( errorReporter )
                                {
                                    this.errorReporter       = errorReporter instanceof ErrorReporter
                                        ?  errorReporter  :  defaultReporter;
                                    this.ts                  = undefined;  // TokenStream
                                    this.source              = undefined;  // String       # file-name, URL, ...etc
                                    this.flaggedTokenBuffer  = null;       // Stack
                                    this.syntaxErrorCount    = 0;
                                    this.nestingOfFunction   = 0;
                                    // The following are per function variables and should be saved/restored
                                    // during function parsing.
                                    this.nestingOfLoop   = 0;
                                    this.nestingOfSwitch = 0;
                                    this.allLabelSet     = null;  // contains all labels in current scope
                                    this.loopLabelSet    = null;  // contains only labels qualifying IterationStatement in current scope
                                }

                                var proto = Parser.prototype;


                                proto.getMessage = function ( messageId  /* optional args */ )
                                {
                                    //!! fake implementation
                                    return messageId;
                                };

                                proto.addWarning = function ( messageId  /* optional args */ )
                                {
                                    this.errorReporter.warning(this.getMessage.apply(this, arguments),
                                        this.ts.getLineno()                   ,
                                        this.ts.getLine()                     ,
                                        this.ts.getOffset()                   );
                                };

                                proto.addError = function ( messageId  /* optional args */ )
                                {
                                    ++this.syntaxErrorCount;
                                    this.errorReporter.error(this.getMessage.apply(this, arguments),
                                        this.ts.getLineno()                   ,
                                        this.ts.getLine()                     ,
                                        this.ts.getOffset()                   );
                                };

                                proto.reportError = function ( messageId  /* optional args */ )
                                {
                                    this.addError.apply(this, arguments);
                                    // Throw a ParserException exception to unwind the recursive descent
                                    // parse.
                                    throw new ParserException();
                                };


                                proto.peekToken = function ( )
                                {
                                    var tt;
                                    if ( this.flaggedTokenBuffer.isEmpty() ) {
                                        tt = this.ts.getToken();
                                        if ( tt === Token.EOL ) {
                                            do {
                                                tt = this.ts.getToken();
                                            } while ( tt === Token.EOL );
                                            tt |= TI_AFTER_EOL;
                                        }
                                        this.flaggedTokenBuffer.push(tt);
                                    } else {
                                        tt = this.flaggedTokenBuffer.peek();
                                    }
                                    return tt & CLEAR_TI_MASK;
                                };

                                proto.peekFlaggedToken = function ( )
                                {
                                    this.peekToken();
                                    return this.flaggedTokenBuffer.peek();
                                };

                                proto.consumeToken = function ( )
                                {
                                    this.flaggedTokenBuffer.pop();
                                };

                                proto.nextToken = function ( )
                                {
                                    var tt = this.peekToken();
                                    this.consumeToken();
                                    return tt;
                                };

                                proto.nextFlaggedToken = function ( )
                                {
                                    this.peekToken();
                                    var ttFlagged = this.flaggedTokenBuffer.peek();
                                    this.consumeToken();
                                    return ttFlagged;
                                };

                                proto.matchToken = function ( toMatch )
                                {
                                    if ( this.peekToken() !== toMatch ) return false;
                                    this.consumeToken();
                                    return true;
                                };

                                proto.peekTokenOrEOL = function ( )
                                {
                                    var tt = this.peekToken();
                                    // Check for last peeked token flags
                                    if ( this.flaggedTokenBuffer.peek() & TI_AFTER_EOL ) return Token.EOL;
                                    return tt;
                                };

// Since we need to backtrack to properly parse "default xml namespace"
// in switch-statement.
                                proto.ungetToken = function ( token )
                                {
                                    this.flaggedTokenBuffer.push(token);
                                };

                                proto.setCheckForLabel = function ( )
                                {
                                    var tt = this.flaggedTokenBuffer.pop();
                                    if ( (tt & CLEAR_TI_MASK) !== Token.NAME ) throw Kit.codeBug();
                                    this.flaggedTokenBuffer.push(tt | TI_CHECK_LABEL);
                                };

                                proto.mustMatchToken = function ( toMatch, messageId  /* optional args */ )
                                {
                                    if ( !this.matchToken(toMatch) ) {
                                        var args = [];
                                        for ( var i=1;  i < arguments.length;  i++ ) args.push(arguments[i]);
                                        this.reportError.apply(this, args);
                                    }
                                };

                                proto.eof = function ( )
                                {
                                    return this.ts.eof();
                                };

                                proto.insideFunction = function ( )
                                {
                                    return this.nestingOfFunction !== 0;
                                };

                                proto.insideLoop = function ( )
                                {
                                    return this.nestingOfLoop !== 0;
                                };

                                proto.enterLoop = function ( labels )
                                {
                                    for ( var i=0;  i < labels.length;  i++ ) this.loopLabelSet.add(labels[i]);
                                    this.nestingOfLoop++;
                                };

                                proto.exitLoop = function ( labels )
                                {
                                    for ( var i=0;  i < labels.length;  i++ ) this.loopLabelSet.remove(labels[i]);
                                    this.nestingOfLoop--;
                                };


                                proto.parse = function ( sourceString, lineno, source )
                                {
                                    this.ts     = new TokenStream(this, sourceString, lineno);
                                    this.source = source;  // optional
                                    this.flaggedTokenBuffer = new Stack();
                                    this.syntaxErrorCount   = 0;
                                    this.nestingOfFunction  = 0;
                                    this.nestingOfLoop      = 0;
                                    this.nestingOfSwitch    = 0;
                                    this.allLabelSet        = new IdentifierSet();
                                    this.loopLabelSet       = new IdentifierSet();

                                    try {
                                        var body = this.statements();
                                        this.mustMatchToken(Token.EOF, "msg.syntax");
                                    } catch ( e ) {
                                        if ( e instanceof ParserException ) {
                                            // Ignore it.
                                        } else {
                                            // Maybe stack overflow.
                                            //!!fake implementation
                                            throw e;
                                        }
                                    }

                                    if ( this.syntaxErrorCount ) {
                                        var msg = "msg.got.syntax.errors";
                                        this.addError(msg);
                                        throw new SyntaxError(this.getMessage("msg.got.syntax.errors"));
                                    }

                                    this.ts = null; // It helps GC
                                    return body;
                                };


                                proto.statements = function ( )
                                {
                                    var head, cell;
                                    cell = head = cons(null, nil());
                                    bodyLoop: for (;;) {
                                        var n;
                                        switch ( this.peekToken() ) {
                                            case Token.ERROR:
                                            case Token.EOF:
                                            case Token.RC:
                                                break bodyLoop;
                                            case Token.FUNCTION:  // save the stack
                                                this.consumeToken();
                                                n = this.functionDecl([]);
                                                break;
                                            default:
                                                n = this.statement();
                                                break;
                                        }
                                        cell = cell.cdr = cons(n, cell.cdr);
                                    }
                                    return head.cdr;
                                };


                                proto.functionDecl = function ( labels )
                                {
                                    var baseLineno = this.ts.getLineno();  // line number where source starts
                                    this.mustMatchToken(Token.NAME, "msg.no.func.name");
                                    var name   = new Identifier(this.ts.getString());
                                    var params = this.parameterList();
                                    var body   = this.functionBody();
                                    return new FunctionDeclaration(labels, name, params, body, baseLineno, this.source);
                                };

                                proto.functionExpr = function ( )
                                {
                                    var name = null;
                                    if ( this.matchToken(Token.NAME) ) name = new Identifier(this.ts.getString());
                                    var params = this.parameterList();
                                    var body   = this.functionBody();
                                    return new FunctionExpression(name, params, body);
                                };

                                proto.parameterList = function ( )
                                {
                                    this.mustMatchToken(Token.LP, "msg.no.paren.parms");
                                    if ( this.matchToken(Token.RP) ) return [];
                                    var params = [];
                                    var exists = new IdentifierSet();
                                    do {
                                        this.mustMatchToken(Token.NAME, "msg.no.parm");
                                        var p = new Identifier(this.ts.getString());
                                        if ( exists.contains(p) ) this.addWarning("msg.dup.parms", s);
                                        params.push(p);
                                        exists.add(p);
                                    } while ( this.matchToken(Token.COMMA) );
                                    this.mustMatchToken(Token.RP, "msg.no.paren.after.parms");
                                    return params;
                                };

                                proto.functionBody = function ( )
                                {
                                    this.mustMatchToken(Token.LC, "msg.no.brace.body");

                                    var saveAllLabel  = this.allLabelSet;
                                    var saveLoopLabel = this.loopLabelSet;
                                    var saveLoop      = this.nestingOfLoop;
                                    var saveSwitch    = this.nestingOfSwitch;
                                    this.allLabelSet  = new IdentifierSet();
                                    this.loopLabelSet = new IdentifierSet();
                                    this.nestingOfLoop   = 0;
                                    this.nestingOfSwitch = 0;
                                    this.nestingOfFunction++;
                                    try {
                                        var body = this.statements();
                                    } catch ( e ) {
                                        if ( e instanceof ParserException ) {
                                            // Ignore it
                                        } else {
                                            throw e;
                                        }
                                    } finally {
                                        this.allLabelSet     = saveAllLabel;
                                        this.loopLabelSet    = saveLoopLabel;
                                        this.nestingOfLoop   = saveLoop;
                                        this.nestingOfSwitch = saveSwitch;
                                        this.nestingOfFunction--;
                                    }

                                    this.mustMatchToken(Token.RC, "msg.no.brace.after.body");
                                    return body;
                                };


                                proto.statement = function ( )
                                {
                                    try {
                                        var n = this.statementHelper([]);
                                        if ( n != null ) return n;
                                    } catch ( e ) {
                                        if ( e instanceof ParserException ) {
                                            // Ignore it.
                                        } else {
                                            throw e;
                                        }
                                    }

                                    // skip to end of statement
                                    guessingStatementEnd: for (;;) {
                                        var tt = this.peekTokenOrEOL();
                                        this.consumeToken();
                                        switch ( tt ) {
                                            case Token.ERROR:
                                            case Token.EOF:
                                            case Token.EOL:
                                            case Token.SEMI:
                                                break guessingStatementEnd;
                                        }
                                    }
                                    return null;
                                };

                                proto.statementHelper = function ( labels )
                                {
                                    var statement = null;
                                    switch ( this.peekToken() ) {
                                        case Token.IF: {
                                            this.consumeToken();
                                            var lineno = this.ts.getLineno();
                                            var cond   = this.condition();
                                            var tstat  = this.statement();
                                            if ( this.matchToken(Token.ELSE) ) {
                                                return new IfElseStatement(labels, cond, tstat, this.statement(), lineno, this.source);
                                            } else {
                                                return new IfStatement(labels, cond, tstat, lineno, this.source);
                                            }
                                        }

                                        case Token.SWITCH: {
                                            this.consumeToken();
                                            var lineno = this.ts.getLineno();
                                            this.mustMatchToken(Token.LP, "msg.no.paren.switch");
                                            var exp = this.expr(false);
                                            this.mustMatchToken(Token.RP, "msg.no.paren.after.switch");
                                            this.mustMatchToken(Token.LC, "msg.no.brace.switch");
                                            var switchStatement = new SwitchStatement(labels, exp, nil(), lineno, this.source);
                                            var clauses = cons(nil(), nil());
                                            var last = clauses;
                                            this.nestingOfSwitch++;
                                            try {
                                                var hasDefault = false;
                                                switchLoop: for (;;) {
                                                    var lineno = this.ts.getLineno();
                                                    var caseExpression;
                                                    switch ( this.nextToken() ) {
                                                        case Token.RC:
                                                            break switchLoop;
                                                        case Token.CASE:
                                                            caseExpression = this.expr(false);
                                                            this.mustMatchToken(Token.COLON, "msg.no.colon.case");
                                                            break;
                                                        case Token.DEFAULT:
                                                            if ( hasDefault ) this.reportError("msg.double.switch.default");
                                                            hasDefault     = true;
                                                            caseExpression = null;
                                                            this.mustMatchToken(Token.COLON, "msg.no.colon.case");
                                                            break;
                                                        default:
                                                            this.reportError("msg.bad.switch");
                                                            break switchLoop;
                                                    }
                                                    var c = caseExpression
                                                        ?  new CaseClause(caseExpression, this.statementsInSwitch(), lineno, this.source)
                                                        :  new DefaultClause(this.statementsInSwitch(), lineno, this.source);
                                                    last = last.cdr = cons(c, last.cdr);
                                                }
                                            } finally {
                                                this.nestingOfSwitch--;
                                            }
                                            switchStatement.clauses = clauses.cdr;
                                            return switchStatement;
                                        }

                                        case Token.WHILE: {
                                            this.consumeToken();
                                            var lineno = this.ts.getLineno();
                                            this.enterLoop(labels);
                                            try {
                                                return new WhileStatement(labels, this.condition(), this.statement(), lineno, this.source);
                                            } finally {
                                                this.exitLoop(labels);
                                            }
                                        }

                                        case Token.DO: {
                                            this.consumeToken();
                                            var lineno = this.ts.getLineno();
                                            this.enterLoop(labels);
                                            try {
                                                var body = this.statement();
                                            } finally {
                                                this.exitLoop(labels);
                                            }
                                            this.mustMatchToken(Token.WHILE, "msg.no.while.do");
                                            var cond = this.condition();
                                            // Always auto-insert semicon to follow SpiderMonkey:
                                            // It is required by EMAScript but is ignored by the rest of
                                            // world, see bug 238945
                                            this.matchToken(Token.SEMI);
                                            return new DoWhileStatement(labels, body, cond, lineno, this.source);
                                        }

                                        case Token.FOR: {
                                            this.consumeToken();
                                            var lineno = this.ts.getLineno();

                                            var init;  // init is also foo in 'foo in Object'
                                            var cond;  // cond is also object in 'foo in Object'
                                            var incr = null;
                                            var body;

                                            var isForEach = false;
                                            var isForIn   = false;
                                            var isVar     = false;

                                            // See if this is a for each () instead of just a for ()
                                            if ( this.matchToken(Token.NAME) ) {
                                                if ( this.ts.getString() === "each" ) {
                                                    isForEach = true;
                                                } else {
                                                    this.reportError("msg.no.paren.for");
                                                }
                                            }

                                            this.mustMatchToken(Token.LP, "msg.no.paren.for");

                                            var tt = this.peekToken();
                                            if ( tt === Token.SEMI ) {
                                                init = null;
                                            } else {
                                                if ( tt === Token.VAR ) {
                                                    // set init to a var list or initial
                                                    this.consumeToken();    // consume the 'var' token
                                                    init  = this.variables(true);
                                                    isVar = true;
                                                }
                                                else {
                                                    init = this.expr(true);
                                                }
                                            }

                                            if ( this.matchToken(Token.IN) ) {
                                                isForIn = true;
                                                // 'cond' is the object over which we're iterating
                                                cond = this.expr(false);
                                            } else {  // ordinary for loop
                                                this.mustMatchToken(Token.SEMI, "msg.no.semi.for");
                                                if ( this.peekToken() === Token.SEMI ) {
                                                    // no loop condition
                                                    cond = null;
                                                } else {
                                                    cond = this.expr(false);
                                                }

                                                this.mustMatchToken(Token.SEMI, "msg.no.semi.for.cond");
                                                if ( this.peekToken() === Token.RP ) {
                                                    incr = null;
                                                } else {
                                                    incr = this.expr(false);
                                                }
                                            }

                                            this.mustMatchToken(Token.RP, "msg.no.paren.for.ctrl");

                                            this.enterLoop(labels);
                                            try {
                                                body = this.statement();
                                            } finally {
                                                this.exitLoop(labels);
                                            }

                                            if ( !isForIn ) {
                                                // Although SpiderMonkey doesn't allow "for each ( ...; ...; ... )",
                                                // Rhino1.6R5 allowed it. We follow Rhino's position here.
                                                if ( isVar ) return new ForVarStatement(labels, init, cond, incr, body, lineno, this.source);
                                                else         return new ForStatement(labels, init, cond, incr, body, lineno, this.source);
                                            } else {
                                                if ( isVar ) {
                                                    // Check if init (var declarations) contains only one.
                                                    if ( init.length != 1 ) this.reportError("msg.mult.index");
                                                    if ( isForEach ) return new ForEachVarStatement(labels, init[0], cond, body, lineno, this.source);
                                                    else             return new ForInVarStatement(labels, init[0], cond, body, lineno, this.source);
                                                } else {
                                                    // Check if init (an expression left-hand-side of "in") has lvalue.
                                                    if ( !init.hasLvalue() ) this.reportError("msg.bad.for.in.lhs");
                                                    if ( isForEach ) return new ForEachStatement(labels, init, cond, body, lineno, this.source);
                                                    else             return new ForInStatement(labels, init, cond, body, lineno, this.source);
                                                }
                                            }
                                        }

                                        case Token.TRY: {
                                            this.consumeToken();
                                            var lineno = this.ts.getLineno();

                                            // Although ECMA262-3 requires a block here, Rhino1.6R5 allows any kind of statement.
                                            // We follow Rhino's style, but issue warning when a statement is not a block.
                                            var tryBlock = this.statement();
                                            if ( !(tryBlock instanceof Block) ) {
                                                this.addWarning("msg.no.brace.tryblock");
                                                tryBlock = new Block([], cons(tryBlock, nil()), tryBlock.lineno, tryBlock.source);
                                            }

                                            var catchList;
                                            var cell = catchList = cons(null, nil());
                                            var sawDefaultCatch = false;
                                            var peek = this.peekToken();
                                            if ( peek === Token.CATCH ) {
                                                while ( this.matchToken(Token.CATCH) ) {
                                                    if ( sawDefaultCatch ) this.reportError("msg.catch.unreachable");
                                                    var line = this.ts.getLineno();
                                                    this.mustMatchToken(Token.LP, "msg.no.paren.catch");
                                                    this.mustMatchToken(Token.NAME, "msg.bad.catchcond");
                                                    var variable = new Identifier(this.ts.getString());

                                                    var cond = null;
                                                    if ( this.matchToken(Token.IF) ) {
                                                        cond = this.expr(false);
                                                    } else {
                                                        sawDefaultCatch = true;
                                                    }

                                                    this.mustMatchToken(Token.RP, "msg.bad.catchcond");
                                                    this.mustMatchToken(Token.LC, "msg.no.brace.catchblock");
                                                    var block = new Block([], this.statements(), line, this.source);
                                                    this.mustMatchToken(Token.RC, "msg.no.brace.after.body");

                                                    var clause = new CatchGuard(variable, cond, block, line, this.source);
                                                    cell = cell.cdr = cons(clause, cell.cdr);
                                                }
                                            } else if ( peek !== Token.FINALLY ) {
                                                this.mustMatchToken(Token.FINALLY, "msg.try.no.catchfinally");
                                            }
                                            catchList = catchList.cdr;

                                            var finallyBlock = null;
                                            if ( this.matchToken(Token.FINALLY) ) {
                                                // Rhino also allows any kind of statement here.
                                                finallyBlock = this.statement();
                                                if ( !(finallyBlock instanceof Block) ) {
                                                    this.addWarning("msg.no.brace.finallyblock");
                                                    finallyBlock = new Block([], cons(finallyBlock, nil()), finallyBlock.lineno, finallyBlock.source);
                                                }
                                            }

                                            return finallyBlock
                                                ? new TryCatchListFinallyStatement(labels, tryBlock, catchList, finallyBlock, lineno, this.source)
                                                : new TryCatchListStatement(labels, tryBlock, catchList, lineno, this.source);
                                        }

                                        case Token.THROW: {
                                            this.consumeToken();
                                            if ( this.peekTokenOrEOL() === Token.EOL ) {
                                                // ECMAScript does not allow new lines before throw expression,
                                                // see bug 256617
                                                this.reportError("msg.bad.throw.eol");
                                            }

                                            var lineno = this.ts.getLineno();
                                            statement = new ThrowStatement(labels, this.expr(false), lineno, this.source);
                                            break;
                                        }

                                        case Token.BREAK: {
                                            this.consumeToken();
                                            var lineno = this.ts.getLineno();
                                            var target = this.matchJumpLabelName(Token.BREAK);
                                            if ( target == null ) {
                                                if ( !this.nestingOfLoop && !this.nestingOfSwitch ) this.reportError("msg.bad.break");
                                            }
                                            statement = new BreakStatement(labels, target, lineno, this.source);
                                            break;
                                        }

                                        case Token.CONTINUE: {
                                            this.consumeToken();
                                            var lineno = this.ts.getLineno();
                                            var target = this.matchJumpLabelName(Token.CONTINUE);
                                            if ( target == null ) {
                                                if ( !this.nestingOfLoop ) reportError("msg.continue.outside");
                                            }
                                            statement = new ContinueStatement(labels, target, lineno, this.source);
                                            break;
                                        }

                                        case Token.WITH: {
                                            this.consumeToken();
                                            var lineno = this.ts.getLineno();
                                            this.mustMatchToken(Token.LP, "msg.no.paren.with");
                                            var exp = this.expr(false);
                                            this.mustMatchToken(Token.RP, "msg.no.paren.after.with");
                                            var body = this.statement();
                                            return new WithStatement(labels, exp, body, lineno, this.source);
                                        }

                                        case Token.VAR: {
                                            this.consumeToken();
                                            statement = new VarStatement(labels, this.variables(false), lineno, this.source);
                                            break;
                                        }

                                        case Token.RETURN: {
                                            if ( !this.insideFunction() ) this.reportError("msg.bad.return");
                                            this.consumeToken();
                                            var lineno = this.ts.getLineno();
                                            var exp;
                                            /* This is ugly, but we don't want to require a semicolon. */
                                            switch ( this.peekTokenOrEOL() ) {
                                                case Token.SEMI:
                                                case Token.RC:
                                                case Token.EOF:
                                                case Token.EOL:
                                                case Token.ERROR:
                                                    exp = null;
                                                    break;
                                                default:
                                                    exp = this.expr(false);
                                            }
                                            statement = new ReturnStatement(labels, exp, lineno, this.source);
                                            break;
                                        }

                                        case Token.LC:
                                            this.consumeToken();
                                            var block = new Block(labels, this.statements(), lineno, this.source);
                                            this.mustMatchToken(Token.RC, "msg.no.brace.block");
                                            return block;

                                        case Token.ERROR:
                                        // Fall thru, to have a node for error recovery to work on
                                        case Token.SEMI:
                                            this.consumeToken();
                                            return new EmptyStatement(labels, lineno, this.source);

                                        case Token.FUNCTION: {
                                            this.consumeToken();
                                            return this.functionDecl(labels);
                                        }

                                        case Token.DEFAULT: {
                                            this.consumeToken();
                                            this.reportError("msg.XML.not.available");
                                        }

                                        case Token.NAME: {
                                            var lineno = this.ts.getLineno();
                                            this.setCheckForLabel();
                                            try {
                                                statement = new ExpStatement(labels, this.expr(false), lineno, this.source);
                                            } catch ( e ) {
                                                if ( e instanceof LabelException ) {
                                                    // Label found!
                                                    if ( this.allLabelSet.contains(e.label) ) this.reportError("msg.dup.label");
                                                    this.allLabelSet.add(e.label);
                                                    labels.push(e.label);
                                                    try {
                                                        statement = this.statementHelper(labels);
                                                    } finally {
                                                        this.allLabelSet.remove(e.label);
                                                    }
                                                    return statement;
                                                } else {
                                                    throw e;
                                                }
                                            }
                                            break;
                                        }

                                        default: {
                                            var lineno = this.ts.getLineno();
                                            statement = new ExpStatement(labels, this.expr(false), lineno, this.source);
                                            break;
                                        }
                                    }

                                    switch ( this.peekTokenOrEOL() ) {
                                        case Token.SEMI:
                                            // Consume ';' as a part of statement
                                            this.consumeToken();
                                            break;
                                        case Token.ERROR:
                                        case Token.EOF:
                                        case Token.EOL:
                                        case Token.RC:
                                            // Autoinsert ;
                                            break;
                                        default:
                                            // Report error if no EOL or autoinsert ; otherwise
                                            this.reportError("msg.no.semi.stmt");
                                    }

                                    return statement;
                                };

                                proto.condition = function ( )
                                {
                                    this.mustMatchToken(Token.LP, "msg.no.paren.cond");
                                    var exp = this.expr(false);
                                    this.mustMatchToken(Token.RP, "msg.no.paren.after.cond");
                                    if ( exp instanceof SimpleAssignExpression ) this.addWarning("msg.assign.cond");
                                    return exp;
                                };

// match a NAME; return null if no match.
                                proto.matchJumpLabelName = function ( token )
                                {
                                    if ( this.peekTokenOrEOL() !== Token.NAME ) return null;
                                    var label = new Identifier(this.ts.getString());
                                    this.consumeToken();
                                    switch ( token ) {
                                        case Token.CONTINUE:
                                            if ( !this.loopLabelSet.contains(label) ) {
                                                this.reportError("msg.undef.label");
                                            }
                                            break;
                                        case Token.BREAK:
                                            if ( !this.allLabelSet.contains(label) ) {
                                                this.reportError("msg.undef.label");
                                            }
                                            break;
                                        default:
                                            throw Kit.codeBug();
                                    }
                                    return label;
                                };

                                proto.statementsInSwitch = function ( )
                                {
                                    var head, cell;
                                    head = cell = cons(null, nil());
                                    clauseLoop: for (;;) {
                                        switch ( this.peekToken() ) {
                                            case Token.ERROR:
                                            case Token.EOF:
                                            case Token.RC:
                                            case Token.CASE:
                                                break clauseLoop;
                                            case Token.DEFAULT:
                                                this.consumeToken();
                                                var tt = this.peekToken();
                                                this.ungetToken(Token.DEFAULT);
                                                if ( tt === Token.COLON ) break clauseLoop;
                                            // fall thru
                                            default:
                                                cell = cell.cdr = cons(this.statement(), cell.cdr);
                                        }
                                    }
                                    return head.cdr;
                                };

                                proto.variables = function ( inForInit )
                                {
                                    var decls = [];
                                    for (;;) {
                                        this.mustMatchToken(Token.NAME, "msg.bad.var");
                                        var name = new Identifier(this.ts.getString());
                                        var init = this.matchToken(Token.ASSIGN)
                                            ?  this.assignExpr(inForInit)
                                            :  null;
                                        decls.push({id: name, exp: init});
                                        if ( !this.matchToken(Token.COMMA) ) break;
                                    }
                                    return decls;
                                };


                                proto.expr = function ( inForInit )
                                {
                                    var exp = this.assignExpr(inForInit);
                                    while ( this.matchToken(Token.COMMA) ) {
                                        exp = new CommaExpression(exp, this.assignExpr(inForInit));
                                    }
                                    return exp;
                                };


                                proto.assignExpr = function ( inForInit )
                                {
                                    var exp = this.condExpr(inForInit);
                                    var tt  = this.peekToken();
                                    if ( tt < Token.FIRST_ASSIGN || Token.LAST_ASSIGN < tt ) return exp;

                                    if ( !exp.hasLvalue() ) this.reportError("msg.bad.assign.left");

                                    switch ( this.nextToken() ) {
                                        case Token.ASSIGN:
                                            return new SimpleAssignExpression(exp, this.assignExpr(inForInit));
                                        case Token.ASSIGN_BITOR:
                                            return new BitOrAssignExpression(exp, this.assignExpr(inForInit));
                                        case Token.ASSIGN_BITXOR:
                                            return new BitXorAssignExpression(exp, this.assignExpr(inForInit));
                                        case Token.ASSIGN_BITAND:
                                            return new BitAndAssignExpression(exp, this.assignExpr(inForInit));
                                        case Token.ASSIGN_LSH:
                                            return new LShiftAssignExpression(exp, this.assignExpr(inForInit));
                                        case Token.ASSIGN_RSH:
                                            return new RShiftAssignExpression(exp, this.assignExpr(inForInit));
                                        case Token.ASSIGN_URSH:
                                            return new URShiftAssignExpression(exp, this.assignExpr(inForInit));
                                        case Token.ASSIGN_ADD:
                                            return new AddAssignExpression(exp, this.assignExpr(inForInit));
                                        case Token.ASSIGN_SUB:
                                            return new SubAssignExpression(exp, this.assignExpr(inForInit));
                                        case Token.ASSIGN_MUL:
                                            return new MulAssignExpression(exp, this.assignExpr(inForInit));
                                        case Token.ASSIGN_DIV:
                                            return new DivAssignExpression(exp, this.assignExpr(inForInit));
                                        case Token.ASSIGN_MOD:
                                            return new ModAssignExpression(exp, this.assignExpr(inForInit));
                                        default:
                                            throw Kit.codeBug();
                                    }
                                };


                                proto.condExpr = function ( inForInit )
                                {
                                    var exp = this.orExpr(inForInit);
                                    if ( !this.matchToken(Token.HOOK) ) return exp;
                                    var ifTrue = this.assignExpr(false);
                                    this.mustMatchToken(Token.COLON, "msg.no.colon.cond");
                                    var ifFalse = this.assignExpr(inForInit);
                                    return new ConditionalExpression(exp, ifTrue, ifFalse);
                                };


                                proto.orExpr = function ( inForInit )
                                {
                                    var exp = this.andExpr(inForInit);
                                    while ( this.matchToken(Token.OR) ) {
                                        exp = new OrExpression(exp, this.andExpr(inForInit));
                                    }
                                    return exp;
                                };


                                proto.andExpr = function ( inForInit )
                                {
                                    var exp = this.bitOrExpr(inForInit);
                                    while ( this.matchToken(Token.AND) ) {
                                        exp = new AndExpression(exp, this.bitOrExpr(inForInit));
                                    }
                                    return exp;
                                };


                                proto.bitOrExpr = function ( inForInit )
                                {
                                    var exp = this.bitXorExpr(inForInit);
                                    while ( this.matchToken(Token.BITOR) ) {
                                        exp = new BitOrExpression(exp, this.bitXorExpr(inForInit));
                                    }
                                    return exp;
                                };


                                proto.bitXorExpr = function ( inForInit )
                                {
                                    var exp = this.bitAndExpr(inForInit);
                                    while ( this.matchToken(Token.BITXOR) ) {
                                        exp = new BitXorExpression(exp, this.bitAndExpr(inForInit));
                                    }
                                    return exp;
                                };


                                proto.bitAndExpr = function ( inForInit )
                                {
                                    var exp = this.eqExpr(inForInit);
                                    while ( this.matchToken(Token.BITAND) ) {
                                        exp = new BitAndExpression(exp, this.eqExpr(inForInit));
                                    }
                                    return exp;
                                };


                                proto.eqExpr = function ( inForInit )
                                {
                                    var exp = this.relExpr(inForInit);
                                    for (;;) {
                                        var constructor;
                                        switch ( this.peekToken() ) {
                                            case Token.EQ:
                                                constructor = EqualExpression;
                                                break;
                                            case Token.NE:
                                                constructor = NotEqualExpression;
                                                break;
                                            case Token.SHEQ:
                                                constructor = StrictEqualExpression;
                                                break;
                                            case Token.SHNE:
                                                constructor = StrictNotEqualExpression;
                                                break;
                                            default:
                                                return exp;
                                        }
                                        this.consumeToken();
                                        exp = new constructor(exp, this.relExpr(inForInit));
                                    }
                                };


                                proto.relExpr = function ( inForInit )
                                {
                                    var exp = this.shiftExpr();
                                    for (;;) {
                                        var constructor;
                                        switch ( this.peekToken() ) {
                                            case Token.IN:
                                                if ( inForInit ) return exp;
                                                constructor = InExpression;
                                                break;
                                            case Token.INSTANCEOF:
                                                constructor = InstanceofExpression;
                                                break;
                                            case Token.LE:
                                                constructor = LessEqualExpression;
                                                break;
                                            case Token.LT:
                                                constructor = LessThanExpression;
                                                break;
                                            case Token.GE:
                                                constructor = GreaterEqualExpression;
                                                break;
                                            case Token.GT:
                                                constructor = GreaterThanExpression;
                                                break;
                                            default:
                                                return exp;
                                        }
                                        this.consumeToken();
                                        exp = new constructor(exp, this.shiftExpr());
                                    }
                                };


                                proto.shiftExpr = function ( )
                                {
                                    var exp = this.addExpr();
                                    for (;;) {
                                        var constructor;
                                        switch ( this.peekToken() ) {
                                            case Token.LSH:
                                                constructor = LShiftExpression;
                                                break;
                                            case Token.RSH:
                                                constructor = RShiftExpression;
                                                break;
                                            case Token.URSH:
                                                constructor = URShiftExpression;
                                                break;
                                            default:
                                                return exp;
                                        }
                                        this.consumeToken();
                                        exp = new constructor(exp, this.addExpr());
                                    }
                                };


                                proto.addExpr = function ( )
                                {
                                    var exp = this.mulExpr();
                                    for (;;) {
                                        var constructor;
                                        switch ( this.peekToken() ) {
                                            case Token.ADD:
                                                constructor = AddExpression;
                                                break;
                                            case Token.SUB:
                                                constructor = SubExpression;
                                                break;
                                            default:
                                                return exp;
                                        }
                                        this.consumeToken();
                                        exp = new constructor(exp, this.mulExpr());
                                    }
                                };


                                proto.mulExpr = function ( )
                                {
                                    var exp = this.unaryExpr();
                                    for (;;) {
                                        var constructor;
                                        switch ( this.peekToken() ) {
                                            case Token.MUL:
                                                constructor = MulExpression;
                                                break;
                                            case Token.DIV:
                                                constructor = DivExpression;
                                                break;
                                            case Token.MOD:
                                                constructor = ModExpression;
                                                break;
                                            default:
                                                return exp;
                                        }
                                        this.consumeToken();
                                        exp = new constructor(exp, this.unaryExpr());
                                    }
                                };


                                proto.unaryExpr = function ( )
                                {
                                    var constructor;
                                    var needLvalue = null;
                                    switch( this.peekToken() ) {
                                        case Token.VOID:
                                            constructor = VoidExpression;
                                            break;
                                        case Token.NOT:
                                            constructor = NotExpression;
                                            break;
                                        case Token.BITNOT:
                                            constructor = BitNotExpression;
                                            break;
                                        case Token.TYPEOF:
                                            constructor = TypeofExpression;
                                            break;
                                        case Token.ADD:
                                            constructor = PosExpression;
                                            break;
                                        case Token.SUB:
                                            constructor = NegExpression;
                                            break;
                                        case Token.INC:
                                            constructor = PreIncExpression;
                                            needLvalue = "msg.bad.incr";
                                            break;
                                        case Token.DEC:
                                            constructor = PreDecExpression;
                                            needLvalue = "msg.bad.decr";
                                            break;
                                        case Token.DELPROP:
                                            constructor = DeleteExpression;
                                            break;
                                        default:
                                            var exp = this.memberExpr(true);
                                            // Don't look across a newline boundary for a postfix incop.
                                            switch ( this.peekTokenOrEOL() ) {
                                                case Token.INC:
                                                    if ( !exp.hasLvalue() ) this.reportError("msg.bad.incr");
                                                    this.consumeToken();
                                                    return new PostIncExpression(exp);
                                                case Token.DEC:
                                                    if ( !exp.hasLvalue() ) this.reportError("msg.bad.decr");
                                                    this.consumeToken();
                                                    return new PostDecExpression(exp);
                                                default:
                                                    return exp;
                                            }
                                    }
                                    this.consumeToken();
                                    var exp = this.unaryExpr();
                                    if ( needLvalue  &&  !exp.hasLvalue() ) this.reportError(needLvalue);
                                    return new constructor(exp);
                                };


                                proto.argumentList = function ( )
                                {
                                    if ( this.matchToken(Token.RP) ) return [];
                                    var args = [];
                                    do {
                                        args.push( this.assignExpr(false) );
                                    } while ( this.matchToken(Token.COMMA) );
                                    this.mustMatchToken(Token.RP, "msg.no.paren.arg");
                                    return args;
                                };


                                proto.memberExpr = function ( allowCallSyntax )
                                {
                                    var base;
                                    if ( this.matchToken(Token.NEW) ) {
                                        var func = this.memberExpr(false);
                                        var args = this.matchToken(Token.LP)
                                            ?  this.argumentList()
                                            :  [];
                                        base = new NewExpression(func, args);
                                    } else {
                                        base = this.primaryExpr();
                                    }
                                    return this.memberExprTail(allowCallSyntax, base);
                                }


                                proto.memberExprTail = function ( allowCallSyntax, base )
                                {
                                    tailLoop: for (;;) {
                                        switch ( this.peekToken() ) {
                                            case Token.DOTDOT:
                                                this.reportError("msg.XML.not.available");

                                            case Token.DOT: {
                                                this.consumeToken();
                                                switch ( this.nextToken() ) {
                                                    case Token.NAME:
                                                        base = new DotAccessor(base, new Identifier(this.ts.getString()));
                                                        break;
                                                    case Token.MUL:
                                                        this.reportError("msg.XML.not.available");
                                                    case Token.XMLATTR:
                                                        this.reportError("msg.XML.not.available");
                                                    default:
                                                        this.reportError("msg.no.name.after.dot");
                                                }
                                            }
                                                break;

                                            case Token.DOTQUERY:
                                                this.reportError("msg.XML.not.available");

                                            case Token.LB:
                                                this.consumeToken();
                                                base = new BracketAccessor(base, this.expr(false));
                                                this.mustMatchToken(Token.RB, "msg.no.bracket.index");
                                                break;

                                            case Token.LP:
                                                if ( !allowCallSyntax ) break tailLoop;
                                                this.consumeToken();
                                                base = new CallExpression(base, this.argumentList());
                                                break;

                                            default:
                                                break tailLoop;
                                        }
                                    }
                                    return base;
                                };


                                proto.primaryExpr = function ( )
                                {
                                    var exp;
                                    var ttFlagged = this.nextFlaggedToken();
                                    var tt = ttFlagged & CLEAR_TI_MASK;
                                    switch ( tt ) {

                                        case Token.FUNCTION:
                                            return this.functionExpr();

                                        case Token.LB: {
                                            var elems = [];
                                            elemLoop: for (;;) {
                                                switch ( this.peekToken() ) {
                                                    case Token.RB:
                                                        this.consumeToken();
                                                        break elemLoop;
                                                    case Token.COMMA:
                                                        while ( this.matchToken(Token.COMMA) ) {
                                                            elems.push(new Elision());
                                                        }
                                                        break;
                                                    default:
                                                        elems.push(this.assignExpr(false));
                                                        if ( this.matchToken(Token.COMMA) ) {
                                                            continue elemLoop;
                                                        } else if ( this.matchToken(Token.RB) ) {
                                                            break elemLoop;
                                                        } else {
                                                            this.reportError("msg.no.bracket.arg");
                                                        }
                                                }
                                            }
                                            return new ArrayInitializer(elems);
                                        }

                                        case Token.LC: {
                                            var pairs = [];
                                            commaloop: do {
                                                var prop;
                                                switch ( this.peekToken() ) {
                                                    case Token.NAME:
                                                        this.consumeToken();
                                                        prop = new Identifier(this.ts.getString());
                                                        break;
                                                    case Token.STRING:
                                                        this.consumeToken();
                                                        prop = new StringLiteral(this.ts.getString());
                                                        break;
                                                    case Token.NUMBER:
                                                        this.consumeToken();
                                                        prop = new NumberLiteral(this.ts.getString());
                                                        break;
                                                    case Token.RC:
                                                        // trailing comma is OK.
                                                        break commaloop;
                                                    default:
                                                        this.reportError("msg.bad.prop");
                                                        break commaloop;
                                                }
                                                this.mustMatchToken(Token.COLON, "msg.no.colon.prop");
                                                pairs.push({prop:prop, exp:this.assignExpr(false)});
                                            } while ( this.matchToken(Token.COMMA) );
                                            this.mustMatchToken(Token.RC, "msg.no.brace.prop");
                                            return new ObjectInitializer(pairs);
                                        }

                                        case Token.LP:
                                            var exp = this.expr(false);
                                            this.mustMatchToken(Token.RP, "msg.no.paren");
                                            return exp;

                                        case Token.XMLATTR:
                                            this.reportError("msg.XML.not.available");

                                        case Token.NAME:
                                            var name = new Identifier(this.ts.getString());
                                            if ( ttFlagged & TI_CHECK_LABEL ) {
                                                if ( this.matchToken(Token.COLON) ) throw new LabelException(name);
                                            }
                                            return name;

                                        case Token.NUMBER:
                                            return new NumberLiteral(this.ts.getString());

                                        case Token.STRING:
                                            return new StringLiteral(this.ts.getString());

                                        case Token.DIV:
                                        case Token.ASSIGN_DIV:
                                            // Got / or /= which should be treated as regexp in fact
                                            this.ts.readRegExp(tt);
                                            return new RegExpLiteral(this.ts.getString());

                                        case Token.NULL:
                                            return new NullLiteral();

                                        case Token.THIS:
                                            return new ThisExpression();

                                        case Token.TRUE:
                                            return new TrueLiteral();

                                        case Token.FALSE:
                                            return new FalseLiteral();

                                        case Token.RESERVED:
                                            this.reportError("msg.reserved.id");
                                            break;

                                        case Token.ERROR:
                                            /* the scanner or one of its subroutines reported the error. */
                                            break;

                                        case Token.EOF:
                                            this.reportError("msg.unexpected.eof");
                                            break;

                                        default:
                                            this.reportError("msg.syntax");
                                            break;
                                    }
                                    return null;    // should never reach here
                                }



                                return {
                                    Parser: Parser
                                };
                            }();
                        }
                    }
                }
            }
        }.call(null) ) {
            this.Concurrent.Thread.Compiler.Parser = Parser;
        }
    }).call(null);
    (function(){
        if ( !this.Concurrent || (typeof this.Concurrent != 'object' && typeof this.Concurrent != 'function') ) this.Concurrent = new Object();
        if ( !this.Concurrent.Thread || (typeof this.Concurrent.Thread != 'object' && typeof this.Concurrent.Thread != 'function') ) this.Concurrent.Thread = new Object();
        if ( !this.Concurrent.Thread.Compiler || (typeof this.Concurrent.Thread.Compiler != 'object' && typeof this.Concurrent.Thread.Compiler != 'function') ) this.Concurrent.Thread.Compiler = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Cons || (typeof this.Data.Cons != 'object' && typeof this.Data.Cons != 'function') ) this.Data.Cons = new Object();
        if ( !this.Data.Cons.Util || (typeof this.Data.Cons.Util != 'object' && typeof this.Data.Cons.Util != 'function') ) this.Data.Cons.Util = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Error || (typeof this.Data.Error != 'object' && typeof this.Data.Error != 'function') ) this.Data.Error = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Cons || (typeof this.Data.Cons != 'object' && typeof this.Data.Cons != 'function') ) this.Data.Cons = new Object();
        if ( !this.Concurrent || (typeof this.Concurrent != 'object' && typeof this.Concurrent != 'function') ) this.Concurrent = new Object();
        if ( !this.Concurrent.Thread || (typeof this.Concurrent.Thread != 'object' && typeof this.Concurrent.Thread != 'function') ) this.Concurrent.Thread = new Object();
        if ( this.Concurrent.Thread.Compiler.CfConvert === undefined ) this.Concurrent.Thread.Compiler.CfConvert = undefined;
        if ( this.Concurrent.Thread.Compiler.CyclicExceptionHandlerError === undefined ) this.Concurrent.Thread.Compiler.CyclicExceptionHandlerError = undefined;
        with ( function(){
            with ( Data.Cons.Util ) {
                with ( Data.Cons ) {
                    with ( Data.Error ) {
                        with ( Concurrent.Thread ) {
                            with ( Concurrent.Thread.Compiler ) {

                                return function () {
                                    var VERSION ;
                                    var NAMESPACE;

                                    /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Concurrent.Thread code.
 *
 * The Initial Developer of the Original Code is
 * Daisuke Maki.
 * Portions created by the Initial Developer are Copyright (C) 2006-2007
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */


                                    NAMESPACE = 'Concurrent.Thread.Compiler';








                                    var IL = Concurrent.Thread.Compiler.IntermediateLanguage;












                                    var Cf = "$Concurrent_Thread_Compiler_Cf";


                                    function CfConvert ( func ) {
                                        var cache = new IdentifierMap();
                                        var start = CfTarget(func.start, cache);
                                        var cache2 = new IdentifierMap();
                                        cache.values().forEach(function( it ){
                                            cache2.put(new Identifier(it.id), it);
                                        });
                                        var body  = cons(null, nil());
                                        append = adder(body);
                                        cacheToList(cache2).forEach(function( it ){
                                            return append(cache2.get(it));
                                        });
                                        return new IL.Function(func.name, func.params, func.vars, body.cdr, start);
                                    }


                                    function cacheToList ( cache ) {
                                        // Resolves exception-dependency and sort blocks in valid order.
                                        var blocks = [];
                                        var depends = new IdentifierMap();
                                        cache.values().forEach(function( it ){
                                            blocks.push(it);
                                            depends.put(
                                                new Identifier(it.id),
                                                it.exception instanceof IL.Block ? new Identifier(it.exception.id) : undefined
                                            );
                                        });
                                        return check_cyclic(depends);
                                    }



                                    var CyclicExceptionHandlerError = Error.extend(
                                        function ( $super, message ) { $super(message); },
                                        {name: NAMESPACE + ".CyclicExceptionHandlerError"}
                                    );

                                    function check_cyclic ( depends ) {
                                        var ok = {};
                                        function traverse ( id, path ) {
                                            if ( ok[id] ) return "OK";
                                            var next = depends.get(id);
                                            if ( !next ) {
                                                ok[id] = true;
                                                path.push(id);
                                                return "OK";
                                            }
                                            path.forEach(function( it ){
                                                if ( it.valueOf() == id.valueOf() ) {
                                                    throw new CyclicExceptionHandlerError("cyclic exception handler: " + path.concat([id]).join(" -> "));
                                                }
                                            });
                                            path.push(id);
                                            traverse(next, path);
                                            ok[id] = true;
                                            return "OK";
                                        }
                                        var result = [];
                                        depends.keys().forEach(function( it ){
                                            var path = [];
                                            traverse(it, path);
                                            result = path.concat(result);
                                        });
                                        return result.reverse();
                                    }


                                    function CfTarget ( b, cache ) {
                                        if ( b === "return" || b === "throw" ) return b;
                                        if ( cache.get(new Identifier(b.id)) ) return cache.get(new Identifier(b.id));
                                        return b[Cf](cache);
                                    }


                                    IL.GotoBlock.prototype[Cf] = function ( cache ) {
                                        var block = new IL.GotoBlock();
                                        cache.put(new Identifier(this.id), block);
                                        block.scopes    = this.scopes.map(function( it ){ return it[Cf](cache); });
                                        block.body      = this.body.map(function( it ){ return it[Cf](cache); });
                                        block.arg       = this.arg[Cf](cache);
                                        block.target    = CfTarget(this.target, cache);
                                        block.exception = CfTarget(this.exception, cache);
                                        return block;
                                    };

                                    IL.CallBlock.prototype[Cf] = function ( cache ) {
                                        var block = new IL.CallBlock();
                                        cache.put(new Identifier(this.id), block);
                                        block.scopes    = this.scopes.map(function( it ){ return it[Cf](cache); });
                                        block.body      = this.body.map(function( it ){ return it[Cf](cache); });
                                        block.this_val  = this.this_val[Cf](cache);
                                        block.func      = this.func[Cf](cache);
                                        block.args      = this.args.map(function( it ){ return it[Cf](cache); });
                                        block.target    = CfTarget(this.target, cache);
                                        block.exception = CfTarget(this.exception, cache);
                                        return block;
                                    };

                                    IL.NewBlock.prototype[Cf] = function ( cache ) {
                                        var block = new IL.NewBlock();
                                        cache.put(new Identifier(this.id), block);
                                        block.scopes    = this.scopes.map(function( it ){ return it[Cf](cache); });
                                        block.body      = this.body.map(function( it ){ return it[Cf](cache); });
                                        block.func      = this.func[Cf](cache);
                                        block.args      = this.args.map(function( it ){ return it[Cf](cache); });
                                        block.target    = CfTarget(this.target, cache);
                                        block.exception = CfTarget(this.exception, cache);
                                        return block;
                                    };


                                    IL.ExpStatement.prototype[Cf] = function ( cache ) {
                                        return new IL.ExpStatement(
                                            this.exp[Cf](cache)
                                        );
                                    };

                                    IL.CondStatement.prototype[Cf] = function ( cache ) {
                                        return new IL.CondStatement(
                                            this.cond[Cf](cache),
                                            CfTarget(this.target, cache)
                                        );
                                    };

                                    IL.RecvStatement.prototype[Cf] = function ( cache ) {
                                        return new IL.RecvStatement(
                                            this.assignee[Cf](cache)
                                        );
                                    };

                                    IL.EnumStatement.prototype[Cf] = function ( cache ) {
                                        return new IL.EnumStatement(
                                            this.exp[Cf](cache),
                                            this.assignee[Cf](cache)
                                        );
                                    };


                                    Expression.prototype[Cf] = function ( cache ) {
                                        return this;
                                    };

                                    UnaryExpression.prototype[Cf] = function ( cache ) {
                                        return new this.constructor(this.exp[Cf](cache));
                                    };

                                    BinaryExpression.prototype[Cf] = function ( cache ) {
                                        return new this.constructor(this.left[Cf](cache), this.right[Cf](cache));
                                    };

                                    ArrayInitializer.prototype[Cf] = function ( cache ) {
                                        return new ArrayInitializer(this.elems.map(function( it ){
                                            return it[Cf](cache);
                                        }));
                                    };

                                    FunctionExpression.prototype[Cf] = function ( cache ) {
                                        return prepareTree(this);
                                    };

                                    ObjectInitializer.prototype[Cf] = function ( cache ) {
                                        return new ObjectInitializer(this.pairs.map(function( it ){
                                            return { prop: it.prop,  exp: it.exp[Cf](cache) };
                                        }));
                                    };

                                    DotAccessor.prototype[Cf] = function ( cache ) {
                                        return new DotAccessor(this.base[Cf](cache), this.prop);
                                    };

                                    ConditionalExpression.prototype[Cf] = function ( cache ) {
                                        return new ConditionalExpression(
                                            this.cond[Cf](cache),
                                            this.texp[Cf](cache),
                                            this.fexp[Cf](cache)
                                        );
                                    };


                                    return {
                                        CfConvert: CfConvert, CyclicExceptionHandlerError: CyclicExceptionHandlerError
                                    };
                                }();
                            }
                        }
                    }
                }
            }
        }.call(null) ) {
            this.Concurrent.Thread.Compiler.CfConvert = CfConvert;
            this.Concurrent.Thread.Compiler.CyclicExceptionHandlerError = CyclicExceptionHandlerError;
        }
    }).call(null);
    (function(){
        if ( !this.Concurrent || (typeof this.Concurrent != 'object' && typeof this.Concurrent != 'function') ) this.Concurrent = new Object();
        if ( !this.Concurrent.Thread || (typeof this.Concurrent.Thread != 'object' && typeof this.Concurrent.Thread != 'function') ) this.Concurrent.Thread = new Object();
        if ( !this.Concurrent.Thread.Compiler || (typeof this.Concurrent.Thread.Compiler != 'object' && typeof this.Concurrent.Thread.Compiler != 'function') ) this.Concurrent.Thread.Compiler = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Functional || (typeof this.Data.Functional != 'object' && typeof this.Data.Functional != 'function') ) this.Data.Functional = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Cons || (typeof this.Data.Cons != 'object' && typeof this.Data.Cons != 'function') ) this.Data.Cons = new Object();
        if ( this.Concurrent.Thread.Compiler.CsConvert === undefined ) this.Concurrent.Thread.Compiler.CsConvert = undefined;
        with ( function(){
            with ( Data.Functional ) {
                with ( Data.Cons ) {
                    with ( Concurrent.Thread.Compiler ) {

                        return function () {
                            var VERSION = '0.0.0';
                            var NAMESPACE;

                            /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Concurrent.Thread code.
 *
 * The Initial Developer of the Original Code is
 * Daisuke Maki.
 * Portions created by the Initial Developer are Copyright (C) 2006-2007
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */



                            NAMESPACE = 'Concurrent.Thread.Compiler';








                            var IL = Concurrent.Thread.Compiler.IntermediateLanguage;








                            var Cs = "Concurrent.Thread.Compiler.CsConvert";
                            var STACK_VAR = "$Concurrent_Thread_stack";

                            var undefinedExp = new VoidExpression(new NumberLiteral(0));
                            var emptyLabel   = new Identifier("");

                            function isStackVar ( v ) {
                                return v instanceof Identifier
                                    && v.valueOf().match(/^$Concurrent_Thread_stack/);
                            }


                            function Context ( ) {
                                this.stackVars = [];
                                this.contBreak    = new IdentifierMap();
                                this.contContinue = new IdentifierMap();
                                this.contReturn   = "return";
                                this.contThrow    = "throw";
                                this.scopes       = [];
                            }

                            var proto = Context.prototype;

                            proto.getStackVar = function ( n ) {
                                n = Math.floor(n);
                                if ( isNaN(n) || n < 0 ) Kit.codeBug("must be integer greater than zero");
                                for ( var i=this.stackVars.length;  i <= n;  i++ ) {
                                    this.stackVars[i] = new Identifier(STACK_VAR + i);
                                }
                                return this.stackVars[n];
                            };

                            proto.putBreakLabels = function ( labels, target ) {
                                if ( !labels.length ) return this.contBreak;
                                var restore = this.contBreak;
                                this.contBreak = this.contBreak.clone();
                                for ( var i=0;  i < labels.length;  i++ ) {
                                    this.contBreak.put(labels[i], target);
                                }
                                return restore;
                            };

                            proto.putBreakAndContinueLabels = function ( labels, breakTarget, continueTarget ) {
                                if ( !labels.length ) {
                                    return {
                                        contBreak   : this.contBreak,
                                        contContinue: this.contContinue
                                    };
                                }
                                var restore = {
                                    contBreak   : this.contBreak,
                                    contContinue: this.contContinue
                                };
                                this.contBreak    = this.contBreak.clone();
                                this.contContinue = this.contContinue.clone();
                                for ( var i=0;  i < labels.length;  i++ ) {
                                    this.contBreak.put(labels[i], breakTarget);
                                    this.contContinue.put(labels[i], continueTarget);
                                }
                                return restore;
                            };

                            proto.getScopes = function ( ) {
                                return this.scopes.slice(0, this.scopes.length);
                            };

                            proto.pushScope = function ( /* variable args */ ) {
                                return this.scopes.push.apply(this.scopes, arguments);
                            };

                            proto.popScope = function ( ) {
                                return this.scopes.pop();
                            };

                            proto.makeGotoBlock = function ( arg, target ) {
                                return new IL.GotoBlock(this.getScopes(), nil(), arg, target, this.contThrow);
                            };




                            function CsConvert ( func ) {
                                var context = new Context();
                                var last_block = new IL.GotoBlock([], nil(), undefinedExp, "return", "throw");
                                func.body  = CsStatements(func.body, list(last_block), context, 0);
                                func.start = func.body.car;
                                func.vars  = func.vars.concat(context.stackVars);
                                return func;
                            }


                            function CsStatements ( stmts, follows, ctxt, sttop ) {
                                if ( stmts.isNil() ) return follows;
                                follows = CsStatements(stmts.cdr, follows, ctxt, sttop);
                                return stmts.car[Cs](follows, ctxt, sttop);
                            }

                            function CsReference ( exp, ctxt, sttop, rest ) {  // Expression -> Context -> Int -> (Expression -> <Block>) -> <Block>
                                if ( exp instanceof DotAccessor ) {
                                    var e = new DotAccessor(ctxt.getStackVar(sttop), exp.prop);
                                    var follows = rest(e, sttop+1);
                                    return exp.base[Cs](follows, ctxt, sttop);
                                } else if ( exp instanceof BracketAccessor ) {
                                    var e = new BracketAccessor(ctxt.getStackVar(sttop), ctxt.getStackVar(sttop+1));
                                    var follows = rest(e, sttop+2);
                                    follows = exp.right[Cs](follows, ctxt, sttop+1);
                                    return exp.left[Cs](follows, ctxt, sttop);
                                } else if ( exp instanceof Identifier ) {
                                    return rest(exp, sttop);
                                } else {
                                    var follows = rest(ctxt.getStackVar(sttop), sttop+1);
                                    return exp[Cs](follows, ctxt, sttop);
                                }
                            }



                            EmptyStatement.prototype[Cs] = function ( follows, ctxt, sttop ) {
                                return follows;
                            };

                            Block.prototype[Cs] = function ( follows, ctxt, sttop ) {
                                var restore = ctxt.putBreakLabels(this.labels, follows.car);
                                follows = cons( ctxt.makeGotoBlock(undefinedExp, follows.car), follows);
                                try {
                                    return CsStatements(this.body, follows, ctxt, sttop);
                                } finally {
                                    ctxt.contBreak = restore;
                                }
                            };

                            ExpStatement.prototype[Cs] = function ( follows, ctxt, sttop ) {
                                return this.exp[Cs](follows, ctxt, sttop);
                            };


                            IfStatement.prototype[Cs] = function ( follows, ctxt, sttop ) {
                                var next_block = follows.car;
                                follows = cons( ctxt.makeGotoBlock(undefinedExp, next_block), follows);
                                var restore = ctxt.putBreakLabels(this.labels, next_block);
                                try {
                                    follows = this.body[Cs](follows, ctxt, sttop);
                                    follows.car.prependStatement( new IL.CondStatement(new NotExpression(ctxt.getStackVar(sttop)), next_block) );
                                    return this.cond[Cs](follows, ctxt, sttop);
                                } finally {
                                    ctxt.contBreak = restore;
                                }
                            };

                            IfElseStatement.prototype[Cs] = function ( follows, ctxt, sttop ) {
                                var next_block = follows.car;
                                follows = cons( ctxt.makeGotoBlock(undefinedExp, next_block), follows);
                                var restore = ctxt.putBreakLabels(this.labels, next_block);
                                try {
                                    follows = this.tbody[Cs](follows, ctxt, sttop);
                                    var true_block = follows.car;
                                    follows = cons( ctxt.makeGotoBlock(undefinedExp, next_block), follows);
                                    follows = this.fbody[Cs](follows, ctxt, sttop);
                                    follows.car.prependStatement( new IL.CondStatement(ctxt.getStackVar(sttop), true_block) );
                                    return this.cond[Cs](follows, ctxt, sttop);
                                } finally {
                                    ctxt.contBreak = restore;
                                }
                            };


                            DoWhileStatement.prototype[Cs] = function ( follows, ctxt, sttop ) {
                                var next_block  = follows.car;
                                var first_block = ctxt.makeGotoBlock(undefinedExp, null);
                                follows = cons( ctxt.makeGotoBlock(undefinedExp, next_block), follows );
                                if ( this.cond.containsFunctionCall() ) {
                                    follows.car.prependStatement( new IL.CondStatement(ctxt.getStackVar(sttop), first_block) );
                                    follows = this.cond[Cs](follows, ctxt, sttop);
                                } else {
                                    follows.car.prependStatement( new IL.CondStatement(this.cond, first_block) );
                                }
                                var continue_block = follows.car;
                                follows = cons( ctxt.makeGotoBlock(undefinedExp, follows.car), follows );
                                var restore = ctxt.putBreakAndContinueLabels(this.labels.concat(emptyLabel), next_block, continue_block);
                                try {
                                    follows = this.body[Cs](follows, ctxt, sttop);
                                } finally {
                                    ctxt.contBreak    = restore.contBreak;
                                    ctxt.contContinue = restore.contContinue;
                                }
                                first_block.target = follows.car;
                                return cons( ctxt.makeGotoBlock(undefinedExp, first_block),
                                    cons(first_block, follows) );
                            };

                            WhileStatement.prototype[Cs] = function ( follows, ctxt, sttop ) {
                                var next_block  = follows.car;
                                var first_block = ctxt.makeGotoBlock(undefinedExp, null);
                                follows = cons( ctxt.makeGotoBlock(undefinedExp, first_block), follows );
                                var restore = ctxt.putBreakAndContinueLabels(this.labels.concat(emptyLabel), next_block, first_block);
                                try {
                                    follows = this.body[Cs](follows, ctxt, sttop);
                                } finally {
                                    ctxt.contBreak    = restore.contBreak;
                                    ctxt.contContinue = restore.contContinue;
                                }
                                if ( this.cond.containsFunctionCall() ) {
                                    follows.car.prependStatement( new IL.CondStatement(new NotExpression(ctxt.getStackVar(sttop)), next_block) );
                                    follows = this.cond[Cs](follows, ctxt, sttop);
                                } else {
                                    follows.car.prependStatement( new IL.CondStatement(new NotExpression(this.cond), next_block) );
                                }
                                first_block.target = follows.car;
                                return cons( ctxt.makeGotoBlock(undefinedExp, first_block),
                                    cons(first_block, follows) );
                            };

                            ForStatement.prototype[Cs] = function ( follows, ctxt, sttop ) {
                                var next_block = follows.car;
                                var last_block = ctxt.makeGotoBlock(undefinedExp, null);
                                follows = cons(last_block, follows);
                                if ( this.incr ) follows = this.incr[Cs](follows, ctxt, sttop);
                                var incr_block = follows.car;
                                follows = cons( ctxt.makeGotoBlock(undefinedExp, follows.car), follows );
                                var restore = ctxt.putBreakAndContinueLabels(this.labels.concat(emptyLabel), next_block, incr_block);
                                try {
                                    follows = this.body[Cs](follows, ctxt, sttop);
                                } finally {
                                    ctxt.contBreak    = restore.contBreak;
                                    ctxt.contContinue = restore.contContinue;
                                }
                                if ( this.cond ) {
                                    if ( this.cond.containsFunctionCall() ) {
                                        follows.car.prependStatement( new IL.CondStatement(new NotExpression(ctxt.getStackVar(sttop)), next_block) );
                                        follows = this.cond[Cs](follows, ctxt, sttop);
                                    } else {
                                        follows.car.prependStatement( new IL.CondStatement(new NotExpression(this.cond), next_block) );
                                    }
                                }
                                last_block.target = follows.car;
                                follows = cons( ctxt.makeGotoBlock(undefinedExp, follows.car), follows );
                                if ( this.init ) {
                                    follows = this.init[Cs](follows, ctxt, sttop);
                                }
                                return follows;
                            };

                            ForInStatement.prototype[Cs] = function ( follows, ctxt, sttop ) {
                                if ( !this.lhs.hasLvalue() ) Kit.codeBug('for-in requires lvalue on the left hand side of "in": ' + this);
                                var next_block = follows.car;
                                var loop_block = ctxt.makeGotoBlock(undefinedExp, null);
                                follows = cons( ctxt.makeGotoBlock(undefinedExp, loop_block), follows );
                                var restore = ctxt.putBreakAndContinueLabels(this.labels.concat(emptyLabel), next_block, loop_block);
                                try {
                                    follows = this.body[Cs](follows, ctxt, sttop+2);
                                } finally {
                                    ctxt.contBreak    = restore.contBreak;
                                    ctxt.contContinue = restore.contContinue;
                                }
                                if ( this.lhs.containsFunctionCall() ) {
                                    follows = CsReference(this.lhs, ctxt, sttop+2, function( exp ){
                                        follows.car.prependStatement( make_assign(
                                            exp,
                                            new BracketAccessor(
                                                ctxt.getStackVar(sttop),
                                                new PostIncExpression(ctxt.getStackVar(sttop+1))
                                            )
                                        ) );
                                        return follows;
                                    });
                                } else {
                                    follows.car.prependStatement( make_assign(
                                        this.lhs,
                                        new BracketAccessor(
                                            ctxt.getStackVar(sttop),
                                            new PostIncExpression(ctxt.getStackVar(sttop+1))
                                        )
                                    ) );
                                }
                                follows.car.prependStatement( new IL.CondStatement(
                                    new GreaterEqualExpression(
                                        ctxt.getStackVar(sttop+1),
                                        new DotAccessor(ctxt.getStackVar(sttop), new Identifier("length"))
                                    ),
                                    next_block
                                ) );
                                loop_block.target = follows.car;
                                follows = cons( loop_block, follows );
                                follows = cons( ctxt.makeGotoBlock(undefinedExp, loop_block), follows );
                                follows.car.prependStatement( make_assign(ctxt.getStackVar(sttop+1), new NumberLiteral(0)) );
                                if ( this.exp.containsFunctionCall() ) {
                                    follows.car.prependStatement( new IL.EnumStatement(ctxt.getStackVar(sttop), ctxt.getStackVar(sttop)) );
                                    follows = this.exp[Cs](follows, ctxt, sttop);
                                } else {
                                    follows.car.prependStatement( new IL.EnumStatement(this.exp, ctxt.getStackVar(sttop)) );
                                }
                                return follows;
                            };


                            ContinueStatement.prototype[Cs] = function ( follows, ctxt, sttop ) {
                                return cons(
                                    ctxt.makeGotoBlock(
                                        undefinedExp,
                                        ctxt.contContinue.get( this.target ? this.target : emptyLabel )
                                    ),
                                    follows
                                );
                            };

                            BreakStatement.prototype[Cs] = function ( follows, ctxt, sttop ) {
                                var restore = ctxt.putBreakLabels(this.labels, follows.car);
                                try {
                                    return cons(
                                        ctxt.makeGotoBlock(
                                            undefinedExp,
                                            ctxt.contBreak.get( this.target ? this.target : emptyLabel )
                                        ),
                                        follows
                                    );
                                } finally {
                                    ctxt.contBreak = restore;
                                }
                            };

                            ReturnStatement.prototype[Cs] = function ( follows, ctxt, sttop ) {
                                if ( this.exp ) {
                                    if ( this.exp.containsFunctionCall() ) {
                                        follows = cons( ctxt.makeGotoBlock(ctxt.getStackVar(sttop), ctxt.contReturn), follows );
                                        return this.exp[Cs](follows, ctxt, sttop);
                                    } else {
                                        return cons( ctxt.makeGotoBlock(this.exp, ctxt.contReturn), follows );
                                    }
                                } else {
                                    return cons( ctxt.makeGotoBlock(undefinedExp, ctxt.contReturn), follows );
                                }
                            };


                            WithStatement.prototype[Cs] = function ( follows, ctxt, sttop ) {
                                var next_block = follows.car;
                                var restore = ctxt.putBreakLabels(this.labels, next_block);
                                try {
                                    ctxt.pushScope(ctxt.getStackVar(sttop));
                                    try {
                                        follows = cons( ctxt.makeGotoBlock(undefinedExp, next_block), follows );
                                        follows = this.body[Cs](follows, ctxt, sttop+1);
                                    } finally {
                                        ctxt.popScope();
                                    }
                                    follows = cons( ctxt.makeGotoBlock(undefinedExp, follows.car), follows );
                                    return this.exp[Cs](follows, ctxt, sttop);
                                } finally {
                                    ctxt.contBreak = restore;
                                }
                            };


                            SwitchStatement.prototype[Cs] = function ( follows, ctxt, sttop ) {
                                var next_block = follows.car;
                                var restore = ctxt.putBreakLabels(this.labels.concat(emptyLabel) , next_block);
                                try {
                                    var default_target  = next_block;
                                    var cond_and_target = this.clauses.reverse().map(function( clause ){
                                        follows = cons( ctxt.makeGotoBlock(undefinedExp, follows.car), follows );
                                        follows = CsStatements(clause.body, follows, ctxt, sttop);
                                        var clause_block = follows.car;
                                        if ( clause instanceof DefaultClause ) {
                                            default_target = clause_block;
                                            ignore();
                                        } else {
                                            return {cond:clause.exp, target:clause_block};
                                        }
                                    });
                                    follows = cons( ctxt.makeGotoBlock(undefinedExp, default_target), follows );
                                    cond_and_target.forEach(function( it ){
                                        if ( it.cond.containsFunctionCall() ) {
                                            follows.car.prependStatement(
                                                new IL.CondStatement(
                                                    new StrictEqualExpression(ctxt.getStackVar(sttop), ctxt.getStackVar(sttop+1)),
                                                    it.target
                                                )
                                            );
                                            follows = it.cond[Cs](follows, ctxt, sttop+1);
                                        } else {
                                            follows.car.prependStatement(
                                                new IL.CondStatement(
                                                    new StrictEqualExpression(ctxt.getStackVar(sttop), it.cond),
                                                    it.target
                                                )
                                            );
                                        }
                                    });
                                    return this.exp[Cs](follows, ctxt,sttop);
                                } finally {
                                    ctxt.contBreak = restore;
                                }
                            };


                            ThrowStatement.prototype[Cs] = function ( follows, ctxt, sttop ) {
                                if ( this.exp.containsFunctionCall() ) {
                                    follows = cons( ctxt.makeGotoBlock(ctxt.getStackVar(sttop), ctxt.contThrow), follows );
                                    return this.exp[Cs](follows, ctxt, sttop);
                                } else {
                                    return cons( ctxt.makeGotoBlock(this.exp, ctxt.contThrow), follows );
                                }
                            };

                            TryCatchStatement.prototype[Cs] = function ( follows, ctxt, sttop ) {
                                var next_block = follows.car;
                                follows = cons( ctxt.makeGotoBlock(undefinedExp, next_block), follows );
                                var restore = ctxt.putBreakLabels(this.labels, next_block);
                                try {
                                    follows = this.catchBlock[Cs](follows, ctxt, sttop);
                                    follows.car.prependStatement( new IL.RecvStatement(this.variable) );
                                    var storeContThrow = ctxt.contThrow;
                                    ctxt.contThrow = follows.car;
                                    try {
                                        follows = cons( ctxt.makeGotoBlock(undefinedExp, next_block), follows );
                                        return this.tryBlock[Cs](follows, ctxt, sttop);
                                    } finally {
                                        ctxt.contThrow = storeContThrow;
                                    }
                                } finally {
                                    ctxt.contBreak = restore;
                                }
                            };

                            TryFinallyStatement.prototype[Cs] = function ( follows, ctxt, sttop ) {
                                var next_block = follows.car;
                                follows = cons( ctxt.makeGotoBlock(undefinedExp, next_block), follows );
                                var restoreBreak = ctxt.putBreakLabels(this.labels, next_block);
                                try {
                                    var self = this;

                                    var contBreak = new IdentifierMap();
                                    ctxt.contBreak.keys().forEach(function( label ){
                                        follows = cons( ctxt.makeGotoBlock(undefinedExp, ctxt.contBreak.get(label)), follows );
                                        follows = self.finallyBlock[Cs](follows, ctxt, sttop);
                                        contBreak.put(label, follows.car);
                                    });

                                    var contContinue = new IdentifierMap();
                                    ctxt.contContinue.keys().forEach(function( label ){
                                        follows = cons( ctxt.makeGotoBlock(undefinedExp, ctxt.contContinue.get(label)), follows );
                                        follows = self.finallyBlock[Cs](follows, ctxt, sttop);
                                        contContinue.put(label, follows.car);
                                    });

                                    follows = cons( ctxt.makeGotoBlock(ctxt.getStackVar(sttop), ctxt.contReturn), follows );
                                    follows = this.finallyBlock[Cs](follows, ctxt, sttop+1);
                                    follows.car.prependStatement( new IL.RecvStatement(ctxt.getStackVar(sttop)) );
                                    var contReturn = follows.car;

                                    follows = cons( ctxt.makeGotoBlock(ctxt.getStackVar(sttop), ctxt.contThrow), follows );
                                    follows = this.finallyBlock[Cs](follows, ctxt, sttop+1);
                                    follows.car.prependStatement( new IL.RecvStatement(ctxt.getStackVar(sttop)) );
                                    var contThrow = follows.car;

                                    follows = cons( ctxt.makeGotoBlock(undefinedExp, next_block), follows );
                                    follows = this.finallyBlock[Cs](follows, ctxt, sttop);

                                    var restoreContinue = ctxt.contContinue;
                                    var restoreReturn   = ctxt.contReturn;
                                    var restoreThrow    = ctxt.contThrow;
                                    ctxt.contBreak    = contBreak;
                                    ctxt.contContinue = contContinue;
                                    ctxt.contReturn   = contReturn;
                                    ctxt.contThrow    = contThrow;
                                    try {
                                        return this.tryBlock[Cs](follows, ctxt, sttop);
                                    } finally {
                                        ctxt.contContinue = restoreContinue;
                                        ctxt.contReturn   = restoreReturn;
                                        ctxt.contThrow    = restoreThrow;
                                    }
                                } finally {
                                    ctxt.contBreak = restoreBreak;
                                }
                            };



                            function make_assign ( left, right ) {
                                return new IL.ExpStatement( new SimpleAssignExpression(left, right) );
                            }

                            Expression.prototype[Cs] = function ( follows, ctxt, sttop ) {
                                follows.car.prependStatement( make_assign(ctxt.getStackVar(sttop), this) );
                                return follows;
                            };

                            ArrayInitializer.prototype[Cs] = function ( follows, ctxt, sttop ) {
                                for ( var asis_from=this.elems.length-1;  asis_from >= 0;  asis_from-- ) {
                                    if ( this.elems[asis_from].containsFunctionCall() ) break;
                                }
                                asis_from++;
                                var elems = [];
                                for ( var i=0;  i < asis_from;  i++ ) {
                                    elems[i] = ctxt.getStackVar(sttop+i);
                                }
                                for ( ;  i < this.elems.length;  i++ ) {
                                    elems[i] = this.elems[i];
                                }
                                follows.car.prependStatement( make_assign(ctxt.getStackVar(sttop), new ArrayInitializer(elems)) );
                                for ( var i=asis_from-1;  i >= 0;  i-- ) {
                                    follows = this.elems[i][Cs](follows, ctxt, sttop+i);
                                }
                                return follows;
                            };

                            ObjectInitializer.prototype[Cs] = function ( follows, ctxt, sttop ) {
                                for ( var asis_from=this.pairs.length-1;  asis_from >= 0;  asis_from-- ) {
                                    if ( this.pairs[asis_from].exp.containsFunctionCall() ) break;
                                }
                                asis_from++;
                                var pairs = [];
                                for ( var i=0;  i < asis_from;  i++ ) {
                                    pairs[i] = {prop:this.pairs[i].prop, exp:ctxt.getStackVar(sttop+i)};
                                }
                                for ( ;  i < this.pairs.length;  i++ ) {
                                    pairs[i] = this.pairs[i];
                                }
                                follows.car.prependStatement( make_assign(ctxt.getStackVar(sttop), new ObjectInitializer(pairs)) );
                                for ( var i=asis_from-1;  i >= 0;  i-- ) {
                                    follows = this.pairs[i].exp[Cs](follows, ctxt, sttop+i);
                                }
                                return follows;
                            };

                            UnaryExpression.prototype[Cs] = function ( follows, ctxt, sttop ) {
                                if ( this.exp.containsFunctionCall() ) {
                                    follows.car.prependStatement( make_assign(ctxt.getStackVar(sttop), new this.constructor(ctxt.getStackVar(sttop))) );
                                    return this.exp[Cs](follows, ctxt, sttop);
                                } else {
                                    return Expression.prototype[Cs].apply(this, arguments);
                                }
                            };

                            BinaryExpression.prototype[Cs] = function ( follows, ctxt, sttop ) {
                                if ( this.right.containsFunctionCall() ) {
                                    follows.car.prependStatement( make_assign(
                                        ctxt.getStackVar(sttop),
                                        new this.constructor(ctxt.getStackVar(sttop), ctxt.getStackVar(sttop+1))
                                    ) );
                                    follows = this.right[Cs](follows, ctxt, sttop+1);
                                    return this.left[Cs](follows, ctxt, sttop);
                                } else if ( this.left.containsFunctionCall() ) {
                                    follows.car.prependStatement( make_assign(
                                        ctxt.getStackVar(sttop),
                                        new this.constructor(ctxt.getStackVar(sttop), this.right)
                                    ) );
                                    return this.left[Cs](follows, ctxt, sttop);
                                } else {
                                    return Expression.prototype[Cs].apply(this, arguments);
                                }
                            };

                            DotAccessor.prototype[Cs] = function ( follows, ctxt, sttop ) {
                                if ( this.base.containsFunctionCall() ) {
                                    follows.car.prependStatement( make_assign(
                                        ctxt.getStackVar(sttop),
                                        new DotAccessor(ctxt.getStackVar(sttop), this.prop)
                                    ) );
                                    return this.base[Cs](follows, ctxt, sttop);
                                } else {
                                    return Expression.prototype[Cs].apply(this, arguments);
                                }
                            };

                            CallExpression.prototype[Cs] = function ( follows, ctxt, sttop ) {
                                var self = this;
                                return CsReference(this.func, ctxt, sttop, function ( func, sttop2 ) {
                                    for ( var asis_from=self.args.length-1;  asis_from >= 0;  asis_from-- ) {
                                        if ( self.args[asis_from].containsFunctionCall() ) break;
                                    }
                                    asis_from++;
                                    var args = [];
                                    for ( var i=0;  i < asis_from;  i++ ) {
                                        args[i] = ctxt.getStackVar(sttop2+i);
                                    }
                                    for ( ;  i < self.args.length;  i++ ) {
                                        args[i] = self.args[i];
                                    }
                                    follows.car.prependStatement( new IL.RecvStatement(ctxt.getStackVar(sttop)) );
                                    follows = cons( new IL.CallBlock(
                                        ctxt.getScopes(),
                                        nil(),
                                        func instanceof DotAccessor     ? func.base :
                                            func instanceof BracketAccessor ? func.left : new NullLiteral(),
                                        func,
                                        args,
                                        follows.car,
                                        ctxt.contThrow
                                    ), follows );
                                    for ( var i=asis_from-1;  i >= 0;  i-- ) {
                                        follows = self.args[i][Cs](follows, ctxt, sttop2+i);
                                    }
                                    return follows;
                                });
                            };

                            NewExpression.prototype[Cs] = function ( follows, ctxt, sttop ) {
                                for ( var asis_from=this.args.length-1;  asis_from >= 0;  asis_from-- ) {
                                    if ( this.args[asis_from].containsFunctionCall() ) break;
                                }
                                asis_from++;
                                var args = [];
                                for ( var i=0;  i < asis_from;  i++ ) {
                                    args[i] = ctxt.getStackVar(sttop+1+i);
                                }
                                for ( ;  i < this.args.length;  i++ ) {
                                    args[i] = this.args[i];
                                }
                                follows.car.prependStatement( new IL.RecvStatement(ctxt.getStackVar(sttop)) );
                                follows = cons( new IL.NewBlock(
                                    ctxt.getScopes(),
                                    nil(),
                                    ctxt.getStackVar(sttop),
                                    args,
                                    follows.car,
                                    ctxt.contThrow
                                ), follows );
                                for ( var i=asis_from-1;  i >= 0;  i-- ) {
                                    follows = this.args[i][Cs](follows, ctxt, sttop+1+i);
                                }
                                this.func[Cs](follows, ctxt, sttop);
                                return follows;
                            };

                            AssignExpression.prototype[Cs] = function ( follows, ctxt, sttop ) {
                                var self = this;
                                if ( this.right.containsFunctionCall() ) {
                                    return CsReference(this.left, ctxt, sttop, function ( left, sttop2 ) {
                                        follows.car.prependStatement( make_assign(
                                            ctxt.getStackVar(sttop),
                                            new self.constructor(left, ctxt.getStackVar(sttop2))
                                        ) );
                                        return self.right[Cs](follows, ctxt, sttop2);
                                    });
                                } else if ( this.left.containsFunctionCall() ) {
                                    return CsReference(this.left, ctxt, sttop, function ( left, sttop2 ) {
                                        follows.car.prependStatement( make_assign(
                                            ctxt.getStackVar(sttop),
                                            new self.constructor(left, self.right)
                                        ) );
                                        return follows;
                                    });
                                } else {
                                    return Expression.prototype[Cs].apply(this, arguments);
                                }
                            };

                            AndExpression.prototype[Cs] = function ( follows, ctxt, sttop ) {
                                if ( this.right.containsFunctionCall() ) {
                                    var next_block = follows.car;
                                    follows = cons( ctxt.makeGotoBlock(undefinedExp, next_block), follows );
                                    follows = this.right[Cs](follows, ctxt, sttop);
                                    follows.car.prependStatement( new IL.CondStatement(new NotExpression(ctxt.getStackVar(sttop)), next_block) );
                                    return this.left[Cs](follows, ctxt, sttop);
                                } else if ( this.left.containsFunctionCall() ) {
                                    follows.car.prependStatement( make_assign(ctxt.getStackVar(sttop), new AndExpression(ctxt.getStackVar(sttop), this.right)) );
                                    return this.left[Cs](follows, ctxt, sttop);
                                } else {
                                    return Expression.prototype[Cs].apply(this, arguments);
                                }
                            };

                            OrExpression.prototype[Cs] = function ( follows, ctxt, sttop ) {
                                if ( this.right.containsFunctionCall() ) {
                                    var next_block = follows.car;
                                    follows = cons( ctxt.makeGotoBlock(undefinedExp, next_block), follows );
                                    follows = this.right[Cs](follows, ctxt, sttop);
                                    follows.car.prependStatement( new IL.CondStatement(ctxt.getStackVar(sttop), next_block) );
                                    return this.left[Cs](follows, ctxt, sttop);
                                } else if ( this.left.containsFunctionCall() ) {
                                    follows.car.prependStatement( make_assign(ctxt.getStackVar(sttop), new OrExpression(ctxt.getStackVar(sttop), this.right)) );
                                    return this.left[Cs](follows, ctxt, sttop);
                                } else {
                                    return Expression.prototype[Cs].apply(this, arguments);
                                }
                            };

                            ConditionalExpression.prototype[Cs] = function ( follows, ctxt, sttop ) {
                                if ( this.texp.containsFunctionCall() || this.fexp.containsFunctionCall() ) {
                                    var next_block = follows.car;
                                    follows = cons( ctxt.makeGotoBlock(undefinedExp, next_block), follows );
                                    follows = this.texp[Cs](follows, ctxt, sttop);
                                    var true_block = follows.car;
                                    follows = cons( ctxt.makeGotoBlock(undefinedExp, next_block), follows );
                                    follows = this.fexp[Cs](follows, ctxt, sttop);
                                    follows.car.prependStatement(new IL.CondStatement(ctxt.getStackVar(sttop), true_block));
                                    return this.cond[Cs](follows, ctxt, sttop);
                                } else if ( this.cond.containsFunctionCall() ) {
                                    follows.car.prependStatement( make_assign(ctxt.getStackVar(sttop), new ConditionalExpression(ctxt.getStackVar(sttop), this.texp, this.fexp)) );
                                    return this.cond[Cs](follows, ctxt, sttop);
                                } else {
                                    return Expression.prototype[Cs].apply(this, arguments);
                                }
                            };

                            return {
                                CsConvert: CsConvert
                            };
                        }();
                    }
                }
            }
        }.call(null) ) {
            this.Concurrent.Thread.Compiler.CsConvert = CsConvert;
        }
    }).call(null);
    (function(){
        if ( !this.Concurrent || (typeof this.Concurrent != 'object' && typeof this.Concurrent != 'function') ) this.Concurrent = new Object();
        if ( !this.Concurrent.Thread || (typeof this.Concurrent.Thread != 'object' && typeof this.Concurrent.Thread != 'function') ) this.Concurrent.Thread = new Object();
        if ( !this.Concurrent.Thread.Compiler || (typeof this.Concurrent.Thread.Compiler != 'object' && typeof this.Concurrent.Thread.Compiler != 'function') ) this.Concurrent.Thread.Compiler = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Cons || (typeof this.Data.Cons != 'object' && typeof this.Data.Cons != 'function') ) this.Data.Cons = new Object();
        if ( !this.Data.Cons.Util || (typeof this.Data.Cons.Util != 'object' && typeof this.Data.Cons.Util != 'function') ) this.Data.Cons.Util = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Cons || (typeof this.Data.Cons != 'object' && typeof this.Data.Cons != 'function') ) this.Data.Cons = new Object();
        if ( this.Concurrent.Thread.Compiler.CvConvert === undefined ) this.Concurrent.Thread.Compiler.CvConvert = undefined;
        with ( function(){
            with ( Data.Cons.Util ) {
                with ( Data.Cons ) {
                    with ( Concurrent.Thread.Compiler ) {

                        return function () {
                            var VERSION = '0.0.0';
                            var NAMESPACE;

                            /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Concurrent.Thread code.
 *
 * The Initial Developer of the Original Code is
 * Daisuke Maki.
 * Portions created by the Initial Developer are Copyright (C) 2006-2007
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */



                            NAMESPACE = 'Concurrent.Thread.Compiler';












                            var IL = IntermediateLanguage;


                            var Cv = "$Concurrent_Thread_Compiler_CvConvert";



                            function CvConvert ( func ) {
                                var vars  = new IdentifierSet()
                                function add_vars ( /* variable arguments */ ) {
                                    return vars.add.apply(vars, arguments);
                                }
                                var decls     = cons(null, nil());
                                var add_decls = adder(decls);
                                for ( var c=func.body;  !c.isNil();  c=c.cdr ) {
                                    c.car = c.car[Cv](add_vars, add_decls);
                                }
                                return new IL.Function(func.name, func.params, vars.toArray(), concat(decls, func.body).cdr);
                            }



                            Statement.prototype[Cv] = function ( add_vars, add_decls ) {
                                return this;
                            };


                            Block.prototype[Cv] = function ( add_vars, add_decls ) {
                                for ( var c=this.body;  !c.isNil();  c=c.cdr ) {
                                    c.car = c.car[Cv](add_vars, add_decls);
                                }
                                return this;
                            };


                            VarStatement.prototype[Cv] = function ( add_vars, add_decls ) {
                                var assigns = [];
                                for ( var i=0;  i < this.decls.length;  i++ ) {
                                    add_vars(this.decls[i].id);
                                    if ( this.decls[i].exp ) {
                                        assigns.push( new SimpleAssignExpression(this.decls[i].id, this.decls[i].exp) );
                                    }
                                }
                                if ( !assigns.length ) {
                                    return new EmptyStatement([], this.lineno, this.source);
                                } else {
                                    var exp = assigns[0];
                                    for ( var i=1;  i < assigns.length;  i++ ) {
                                        exp = new CommaExpression(exp, assigns[i]);
                                    }
                                    return new ExpStatement([], exp, this.lineno, this.source);
                                }
                            };


                            IfStatement.prototype[Cv] = function ( add_vars, add_decls ) {
                                this.body = this.body[Cv](add_vars, add_decls);
                                return this;
                            };


                            IfElseStatement.prototype[Cv] = function ( add_vars, add_decls ) {
                                this.tbody = this.tbody[Cv](add_vars, add_decls);
                                this.fbody = this.fbody[Cv](add_vars, add_decls);
                                return this;
                            };


                            DoWhileStatement.prototype[Cv] = IfStatement.prototype[Cv];


                            WhileStatement.prototype[Cv] = IfStatement.prototype[Cv];


                            ForStatement.prototype[Cv] = IfStatement.prototype[Cv];


                            ForVarStatement.prototype[Cv] = function ( add_vars, add_decls ) {
                                var init = (new VarStatement([], this.decls))[Cv](add_vars, add_decls);
                                if ( init instanceof EmptyStatement ) {
                                    init = null;
                                } else {
                                    init = init.exp;
                                }
                                return new ForStatement(this.labels, init, this.cond, this.incr, this.body[Cv](add_vars, add_decls), this.lineno, this.source);
                            };


                            ForInStatement.prototype[Cv] = IfStatement.prototype[Cv];


                            ForInVarStatement.prototype[Cv] = function ( add_vars, add_decls ) {
                                add_vars(this.decl.id);
                                var for_in = new ForInStatement(this.labels, this.decl.id, this.exp, this.body[Cv](add_vars, add_decls), this.lineno, this.source);
                                if ( this.decl.exp ) {
                                    return new Block([], list(
                                        new ExpStatement([], new SimpleAssignExpression(this.decl.id, this.decl.exp), this.lineno, this.source),
                                        for_in
                                    ), this.lineno, this.source);
                                } else {
                                    return for_in;
                                }
                            };


                            ForEachStatement.prototype[Cv] = IfStatement.prototype[Cv];


                            ForEachVarStatement.prototype[Cv] = ForInVarStatement.prototype[Cv];


                            WithStatement.prototype[Cv] = IfStatement.prototype[Cv];


                            SwitchStatement.prototype[Cv] = function ( add_vars, add_decls ) {
                                for ( var c=this.clauses;  !c.isNil();  c=c.cdr ) {
                                    c.car = c.car[Cv](add_vars, add_decls);
                                }
                                return this;
                            };


                            CaseClause.prototype[Cv] = Block.prototype[Cv];


                            DefaultClause.prototype[Cv] = Block.prototype[Cv];


                            TryCatchStatement.prototype[Cv] = function ( add_vars, add_decls ) {
                                add_vars(this.variable);
                                this.tryBlock   = this.tryBlock[Cv](add_vars, add_decls);
                                this.catchBlock = this.catchBlock[Cv](add_vars, add_decls);
                                return this;
                            };


                            TryFinallyStatement.prototype[Cv] = function ( add_vars, add_decls ) {
                                this.tryBlock     = this.tryBlock[Cv](add_vars, add_decls);
                                this.finallyBlock = this.finallyBlock[Cv](add_vars, add_decls);
                                return this;
                            };


                            TryCatchFinallyStatement.prototype[Cv] = function ( add_vars, add_decls ) {
                                add_vars(this.variable);
                                this.tryBlock     = this.tryBlock[Cv](add_vars, add_decls);
                                this.catchBlock   = this.catchBlock[Cv](add_vars, add_decls);
                                this.finallyBlock = this.finallyBlock[Cv](add_vars, add_decls);
                                return this;
                            };


                            FunctionDeclaration.prototype[Cv] = function ( add_vars, add_decls ) {
                                add_vars(this.name);
                                add_decls( new ExpStatement(
                                    [],
                                    new SimpleAssignExpression(
                                        this.name,
                                        new FunctionExpression(null, this.params, this.body)
                                    ),
                                    this.lineno,
                                    this.source
                                ));
                                return new EmptyStatement([]);
                            };


                            return {
                                CvConvert: CvConvert
                            };
                        }();
                    }
                }
            }
        }.call(null) ) {
            this.Concurrent.Thread.Compiler.CvConvert = CvConvert;
        }
    }).call(null);
    (function(){
        if ( !this.Concurrent || (typeof this.Concurrent != 'object' && typeof this.Concurrent != 'function') ) this.Concurrent = new Object();
        if ( !this.Concurrent.Thread || (typeof this.Concurrent.Thread != 'object' && typeof this.Concurrent.Thread != 'function') ) this.Concurrent.Thread = new Object();
        if ( !this.Concurrent.Thread.Compiler || (typeof this.Concurrent.Thread.Compiler != 'object' && typeof this.Concurrent.Thread.Compiler != 'function') ) this.Concurrent.Thread.Compiler = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Cons || (typeof this.Data.Cons != 'object' && typeof this.Data.Cons != 'function') ) this.Data.Cons = new Object();
        if ( !this.Data.Cons.Util || (typeof this.Data.Cons.Util != 'object' && typeof this.Data.Cons.Util != 'function') ) this.Data.Cons.Util = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Cons || (typeof this.Data.Cons != 'object' && typeof this.Data.Cons != 'function') ) this.Data.Cons = new Object();
        if ( this.Concurrent.Thread.Compiler.CzConvert === undefined ) this.Concurrent.Thread.Compiler.CzConvert = undefined;
        with ( function(){
            with ( Data.Cons.Util ) {
                with ( Data.Cons ) {
                    with ( Concurrent.Thread.Compiler ) {

                        return function () {
                            var VERSION ;
                            var NAMESPACE;

                            /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Concurrent.Thread code.
 *
 * The Initial Developer of the Original Code is
 * Daisuke Maki.
 * Portions created by the Initial Developer are Copyright (C) 2006-2007
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */


                            NAMESPACE = 'Concurrent.Thread.Compiler';






                            var IL = Concurrent.Thread.Compiler.IntermediateLanguage;









                            var Cz = "$Concurrent_Thread_Compiler_CzConvert";

                            var PREFIX   = "$Concurrent_Thread_";
                            var var_this = new Identifier(PREFIX+"this");
                            var var_args = new Identifier(PREFIX+"arguments");
                            var var_cont = new Identifier(PREFIX+"continuation");
                            var var_self = new Identifier(PREFIX+"self");
                            var var_compiled     = new Identifier(PREFIX+"compiled");
                            var var_intermediate = new Identifier(PREFIX+"intermediate");

                            var name_arguments = new Identifier("arguments");
                            var name_prototype = new Identifier("prototype");
                            var name_apply     = new Identifier("apply");
                            var name_procedure = new Identifier("procedure");
                            var name_this_val  = new Identifier("this_val");
                            var name_exception = new Identifier("exception");

                            var var_null_function = new Identifier(PREFIX+"null_function");
                            var null_function = new FunctionDeclaration([], var_null_function, [], nil());




                            function CzConvert ( func ) {
                                var body = inner_function(func);
                                return new FunctionExpression(
                                    null,
                                    [var_this, var_args, var_cont],
                                    list(
                                        new ReturnStatement([],
                                            new CallExpression(
                                                new DotAccessor(body, name_apply),
                                                [var_this, var_args]
                                            )
                                        )
                                    )
                                );
                            }




                            var arguments_callee = new DotAccessor(name_arguments, new Identifier("callee"));

                            function inner_function ( func ) {
                                var blocks = func.body.map(function(it){ return it[Cz](); });
                                blocks = cons( var_declaration(func.vars),
                                    cons( null_function,
                                        cons( make_assign(var_args, name_arguments),
                                            cons( make_assign(arguments_callee, var_self),
                                                blocks ) ) ) );
                                adder(blocks)( make_return(func.start) );
                                return new FunctionExpression(null, func.params, blocks);
                            }

                            function var_declaration ( vars ) {
                                if ( !vars.length ) return new EmptyStatement([]);
                                var decls = [];
                                vars.forEach(function( it ){
                                    decls.push({ id:it, exp:null });
                                });
                                return new VarStatement([], decls);
                            }


                            function make_assign ( lhs, rhs ) {
                                return new ExpStatement( [], new SimpleAssignExpression(lhs, rhs) );
                            }


                            var var_cont_ex = new DotAccessor(var_cont, name_exception);

                            function target_to_name ( b ) {
                                if ( b instanceof IL.Block ) {
                                    return new Identifier(PREFIX + b.id);
                                } else if ( b === "return" ) {
                                    return var_cont;
                                } else if ( b === "throw" ) {
                                    return var_cont_ex;
                                } else {
                                    Kit.codeBug("invalid target");
                                }
                            }


                            var undefinedExp = new VoidExpression(new Literal(0));
                            var name_continuation = new Identifier("continuation");
                            var name_timeout      = new Identifier("timeout");
                            var name_ret_val      = new Identifier("ret_val");

                            function make_return ( continuation, ret_val ) {
                                return new ReturnStatement([], new ObjectInitializer([
                                    { prop: name_continuation, exp: target_to_name(continuation) },
                                    { prop: name_ret_val     , exp: ret_val || undefinedExp },
                                    { prop: name_timeout     , exp: undefinedExp            }
                                ]) );
                            }


                            var assign_arguments = make_assign(name_arguments, var_args);

                            function make_continuation ( block, body ) {
                                body = new Block([], body);
                                for ( var i=block.scopes.length-1;  i >= 0;  i-- ) {
                                    body = new WithStatement([], block.scopes[i], body);
                                }
                                return new VarStatement([], [{
                                    id : target_to_name(block),
                                    exp: new ObjectInitializer([
                                        {prop: name_procedure, exp: new FunctionExpression(null, [var_intermediate], list(assign_arguments, body))},
                                        {prop: name_this_val , exp: new ThisExpression() },
                                        {prop: name_exception, exp: target_to_name(block.exception) }
                                    ])
                                }]);
                            }



                            IL.GotoBlock.prototype[Cz] = function ( ) {
                                var body = this.body.map(function( it ) {
                                    return it[Cz]();
                                });
                                body = cons(null, body);
                                adder(body)( make_return(this.target, this.arg) );
                                return make_continuation(this, body.cdr);
                            };


                            var string_object   = new StringLiteral('"object"');
                            var string_function = new StringLiteral('"function"');

                            IL.CallBlock.prototype[Cz] = function ( ) {
                                var body = this.body.map(function( it ) {
                                    return it[Cz]();
                                });
                                body = cons(null, body);
                                adder(body)( new IfElseStatement([],
                                    new AndExpression(
                                        this.func,
                                        new StrictEqualExpression(
                                            new TypeofExpression(
                                                new DotAccessor(this.func, var_compiled)
                                            ),
                                            string_function
                                        )
                                    ),
                                    new ReturnStatement([],
                                        new CallExpression(
                                            new DotAccessor(this.func, var_compiled),
                                            [
                                                this.this_val,
                                                new ArrayInitializer(this.args),
                                                target_to_name(this.target)
                                            ]
                                        )
                                    ),
                                    make_return(
                                        this.target,
                                        new CallExpression(this.func, this.args)
                                    )
                                ) );
                                return make_continuation(this, body.cdr);
                            };


                            IL.NewBlock.prototype[Cz] = function ( ) {
                                var body = this.body.map(function( it ) {
                                    return it[Cz]();
                                });
                                body = cons(null, body);
                                /*  // Construct the following code-tree.
        if ( CONSTRUCTOR && typeof CONSTRUCTOR.$Concurrent_Thread_compiled == "function" ) {
        $Concurrent_Thread_null_function.prototype = CONSTRUCTOR.prototype;
        $Concurrent_Thread_this = new $Concurrent_Thread_null_function();
        return CONSTRUCTOR.$Concurrent_Thread_compiled(
                   $Concurrent_Thread_this,
                   [ARG1, ARG2, ...],
                   { procedure: function($Concurrent_Thread_intermediate){
                    if ( !($Concurrent_Thread_intermediate && (typeof $Concurrent_Thread_intermediate === "object" || typeof $Concurrent_Thread_intermediate === "function") )
                      $Concurrent_Thread_intermediate = $Concurrent_Thread_this;
                    $Concurrent_Thread_this = null;  // encourages GC
                       return { continuation: CONTINUATION,
                                ret_val     : $Concurrent_Thread_intermediate,
                                timeout     : void 0                          };
                   }, this_val: this, exception: EXCEPTION }
               );
        } else {
            return { continuation: CONTINUATION,
                     ret_val     : new CONSTRUCTOR(ARG1, ARG2...),
                     timeout     : void 0
                   };
        }
     */
                                adder(body)( new IfElseStatement([],
                                    new AndExpression(
                                        this.func,
                                        new StrictEqualExpression(
                                            new TypeofExpression(
                                                new DotAccessor(this.func, var_compiled)
                                            ),
                                            string_function
                                        )
                                    ),
                                    new Block([],
                                        list(
                                            make_assign( new DotAccessor(var_null_function, name_prototype),
                                                new DotAccessor(this.func        , name_prototype) ),
                                            make_assign( var_this, new NewExpression(var_null_function, []) ),
                                            new ReturnStatement([],
                                                new CallExpression(
                                                    new DotAccessor(this.func, var_compiled),
                                                    [
                                                        var_this,
                                                        new ArrayInitializer(this.args),
                                                        new ObjectInitializer([
                                                            {prop: name_procedure, exp: new FunctionExpression(null, [var_intermediate], list(
                                                                    new IfStatement([],
                                                                        new NotExpression(
                                                                            new AndExpression(
                                                                                var_intermediate,
                                                                                new OrExpression(
                                                                                    new StrictEqualExpression(new TypeofExpression(var_intermediate), string_object),
                                                                                    new StrictEqualExpression(new TypeofExpression(var_intermediate), string_function)
                                                                                )
                                                                            )
                                                                        ),
                                                                        make_assign(var_intermediate, var_this)
                                                                    ),
                                                                    make_assign(var_this, new NullLiteral()),
                                                                    make_return(this.target, var_intermediate)
                                                                ))},
                                                            {prop: name_this_val , exp: new ThisExpression()},
                                                            {prop: name_exception, exp: target_to_name(this.exception)}
                                                        ])
                                                    ]
                                                )
                                            )
                                        )
                                    ),
                                    make_return(this.target, new NewExpression(this.func, this.args))
                                ) );
                                return make_continuation(this, body.cdr);
                            };


                            IL.ExpStatement.prototype[Cz] = function ( ) {
                                return new ExpStatement([], this.exp);
                            };


                            IL.CondStatement.prototype[Cz] = function ( ) {
                                return new IfStatement([], this.cond, make_return(this.target));
                            };


                            IL.RecvStatement.prototype[Cz] = function ( ) {
                                return make_assign(this.assignee, var_intermediate);
                            };


                            var name_push = new Identifier("push");

                            IL.EnumStatement.prototype[Cz] = function ( ) {
                                return new Block([], list(
                                    make_assign(var_this, new ArrayInitializer([])),
                                    new ForInStatement([], var_intermediate, this.exp,
                                        new ExpStatement([],
                                            new CallExpression(
                                                new DotAccessor(var_this, name_push),
                                                [var_intermediate]
                                            )
                                        )
                                    ),
                                    make_assign(this.assignee, var_this),
                                    make_assign(var_this, new NullLiteral())
                                ));
                            };

                            return {
                                CzConvert: CzConvert
                            };
                        }();
                    }
                }
            }
        }.call(null) ) {
            this.Concurrent.Thread.Compiler.CzConvert = CzConvert;
        }
    }).call(null);
    (function(){
        if ( !this.Concurrent || (typeof this.Concurrent != 'object' && typeof this.Concurrent != 'function') ) this.Concurrent = new Object();
        if ( !this.Concurrent.Thread || (typeof this.Concurrent.Thread != 'object' && typeof this.Concurrent.Thread != 'function') ) this.Concurrent.Thread = new Object();
        if ( !this.Concurrent.Thread.Compiler || (typeof this.Concurrent.Thread.Compiler != 'object' && typeof this.Concurrent.Thread.Compiler != 'function') ) this.Concurrent.Thread.Compiler = new Object();
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Cons || (typeof this.Data.Cons != 'object' && typeof this.Data.Cons != 'function') ) this.Data.Cons = new Object();
        if ( !this.Concurrent || (typeof this.Concurrent != 'object' && typeof this.Concurrent != 'function') ) this.Concurrent = new Object();
        if ( !this.Concurrent.Thread || (typeof this.Concurrent.Thread != 'object' && typeof this.Concurrent.Thread != 'function') ) this.Concurrent.Thread = new Object();
        if ( this.Concurrent.Thread.compile === undefined ) this.Concurrent.Thread.compile = undefined;
        if ( this.Concurrent.Thread.CACHE_LIMIT === undefined ) this.Concurrent.Thread.CACHE_LIMIT = undefined;
        if ( this.Concurrent.Thread.prepare === undefined ) this.Concurrent.Thread.prepare = undefined;
        if ( this.Concurrent.Thread.prepareTree === undefined ) this.Concurrent.Thread.prepareTree = undefined;
        with ( function(){
            with ( Data.Cons ) {
                with ( Concurrent.Thread.Compiler ) {
                    with ( Concurrent.Thread ) {

                        return function () {
                            var VERSION = '0.0.0';
                            var NAMESPACE;

                            /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Concurrent.Thread code.
 *
 * The Initial Developer of the Original Code is
 * Daisuke Maki.
 * Portions created by the Initial Developer are Copyright (C) 2006-2007
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */



                            NAMESPACE = 'Concurrent.Thread';














                            var IL = Concurrent.Thread.Compiler.IntermediateLanguage;






                            var PREFIX            = "$Concurrent_Thread_";
                            var var_self     = new Identifier(PREFIX + "self");
                            var var_compiled = new Identifier(PREFIX + "compiled");



                            function compile ( f ) {
                                return eval(prepare(f));
                            }



                            CACHE_LIMIT = 50;
                            var prepare_cache = {};
                            var cache_history = [];


                            function prepare ( f ) {
                                if ( typeof f != "function" ) throw new TypeError("argument must be a function");
                                f = f.toString();
                                var c = prepare_cache[f];
                                if ( c ) return c;
                                c = prepareTree(parseFunction(f)).toString();
                                while ( cache_history.length >= CACHE_LIMIT  &&  cache_history.length > 0 ) {  // avoid endless loop
                                    delete prepare_cache[cache_history.shift()];
                                }
                                if ( CACHE_LIMIT >= 1 ) {
                                    prepare_cache[f] = c;
                                    cache_history.push(f);
                                }
                                return c;
                            }

                            function parseFunction ( f ) {
                                var stmts = (new Parser()).parse("(" + f + ");");
                                if ( !(stmts.car instanceof ExpStatement) ) throw new Error("not exp-statement!");
                                if ( !(stmts.car.exp instanceof FunctionExpression) ) throw new Error("not function-expression!");
                                return stmts.car.exp;
                            }



                            function prepareTree ( f ) {
                                if ( !(f instanceof FunctionExpression) ) Kit.codeBug("not FunctionalExpression");
                                var name = f.name;
                                f.name = null;
                                var g = CssConvert(f);
                                g = CvConvert(g);
                                g = CsConvert(g);
                                g = CfConvert(g);
                                g = CzConvert(g);
                                return new CallExpression(
                                    new FunctionExpression(null, [], list(
                                        new VarStatement([], [{id:var_self, exp:f}]),
                                        name ? new VarStatement([], [{id:name, exp:var_self}]) : new EmptyStatement([]),
                                        new ExpStatement([], new SimpleAssignExpression(new DotAccessor(var_self, var_compiled), g)),
                                        new ReturnStatement([], var_self)
                                    )),
                                    []
                                );
                                /* Constructs the following structure:
        "(function(){",
        "  var $Concurrent_Thread_self = ", f, ";",
        name  ?  "var " + name + " = " + "$Concurrent_Thread_self;"  :  "",
        "  $Concurrent_Thread_self.$Concurrent_Thread_compiled = ", func, ";",
        "  return $Concurrent_Thread_self;",
        "})()"
    */
                            }


                            return {
                                compile: compile, prepareTree: prepareTree, prepare: prepare
                            };
                        }();
                    }
                }
            }
        }.call(null) ) {
            this.Concurrent.Thread.compile = compile;
            this.Concurrent.Thread.prepareTree = prepareTree;
            this.Concurrent.Thread.prepare = prepare;
        }
    }).call(null);
    (function(){
        if ( !this.Concurrent || (typeof this.Concurrent != 'object' && typeof this.Concurrent != 'function') ) this.Concurrent = new Object();
        if ( !this.Concurrent.Thread || (typeof this.Concurrent.Thread != 'object' && typeof this.Concurrent.Thread != 'function') ) this.Concurrent.Thread = new Object();
        if ( !this.Concurrent.Thread.Compiler || (typeof this.Concurrent.Thread.Compiler != 'object' && typeof this.Concurrent.Thread.Compiler != 'function') ) this.Concurrent.Thread.Compiler = new Object();
        with ( function(){
            with ( Concurrent.Thread.Compiler ) {

                return function () {
                    var VERSION ;
                    var NAMESPACE;




                    NAMESPACE = 'Concurrent.Thread.Compiler';



                    WebBrowser.ScriptExecuter.register("text/x-script.multithreaded-js", function ( src ){
                        eval(compile(src)).async(null);
                    });

                    function compile ( src ) {
                        var prog = (new Parser).parse(src);
                        prog = new FunctionExpression(null, [], prog);
                        prog = CssConvert(prog);
                        prog = CvConvert(prog);
                        prog = CsConvert(prog);
                        prog = CfConvert(prog);
                        prog.vars.forEach(function( it ){
                            // Incredibly, window does not have hasOwnProperty method on IE!!
                            if ( !Object.prototype.hasOwnProperty.call(window, it) ) window[it] = undefined;
                        });
                        prog.vars = [];
                        prog = CzConvert(prog);
                        return [
                            "1, function(){",
                            "    var $Concurrent_Thread_self = function(){};",
                            "    $Concurrent_Thread_self.$Concurrent_Thread_compiled = ", prog, ";",
                            "    return $Concurrent_Thread_self;",
                            "}()"
                        ].join("");
                    }

                    return {

                    };
                }();
            }
        }.call(null) ) {
        }
    }).call(null);
    (function(){
        if ( !this.Concurrent || (typeof this.Concurrent != 'object' && typeof this.Concurrent != 'function') ) this.Concurrent = new Object();
        if ( !this.Concurrent.Thread || (typeof this.Concurrent.Thread != 'object' && typeof this.Concurrent.Thread != 'function') ) this.Concurrent.Thread = new Object();
        if ( !this.Concurrent.Thread.Continuation || (typeof this.Concurrent.Thread.Continuation != 'object' && typeof this.Concurrent.Thread.Continuation != 'function') ) this.Concurrent.Thread.Continuation = new Object();
        if ( !this.Concurrent || (typeof this.Concurrent != 'object' && typeof this.Concurrent != 'function') ) this.Concurrent = new Object();
        if ( !this.Concurrent || (typeof this.Concurrent != 'object' && typeof this.Concurrent != 'function') ) this.Concurrent = new Object();
        if ( !this.Concurrent.Thread || (typeof this.Concurrent.Thread != 'object' && typeof this.Concurrent.Thread != 'function') ) this.Concurrent.Thread = new Object();
        if ( this.Concurrent.Thread.Generator === undefined ) this.Concurrent.Thread.Generator = undefined;
        with ( function(){
            with ( Concurrent.Thread.Continuation ) {
                with ( Concurrent ) {
                    with ( Concurrent.Thread ) {

                        return function () {
                            var VERSION = '0.0.0';
                            var NAMESPACE;

                            /* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Concurrent.Thread.Generator module.
 *
 * The Initial Developer of the Original Code is
 * Daisuke Maki.
 * Portions created by the Initial Developer are Copyright (C) 2008
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */



                            NAMESPACE = 'Concurrent.Thread';











                            function Generator ( f ) {
                                if ( typeof f != "function" ) throw new TypeError("not a function");
                                if ( typeof f.$Concurrent_Thread_compiled != "function" ) f = Thread.compile(f);
                                this._mutex       = new Mutex();
                                this._cont_caller = null;
                                this._buf         = null;
                                this._got         = false;

                                var self = this;

                                var generate = eval(Thread.prepare(function( x ){
                                    self._buf = x;
                                    self._got = true;
                                    try {
                                        self._cont_iter = currentContinuation();
                                        self._cont_caller();
                                    } catch ( e ) {
                                        self._cont_iter = null;
                                        if ( e instanceof ContinuationCalledException ) {
                                            return;  // resume iteration
                                        } else {
                                            throw e;
                                        }
                                    }
                                    // execution never reaches here
                                }));

                                this._cont_iter = eval(Thread.prepare(function(){
                                    f(generate);
                                    self._got       = false;
                                    self._cont_iter = null;  // null means that the iteration function has finished
                                    self._cont_caller();
                                }));
                            }


                            var proto = Generator.prototype;


                            proto.hasNext = function ( ) {
                                // This definition is called when generator is used in non-converted context.
                                // The implementation is quite tricky and strongly dependent on the internal
                                // implementation of Concurrent.Thread.

                                if ( !this._mutex.isAcquirable() ) this._mutex.acquire();  // must throw an error
                                if ( this._got            ) return true;
                                if ( !this._cont_iter     ) return false;

                                var is_called = false;
                                this._cont_caller = eval(Thread.prepare(function(){
                                    is_called = true;
                                    Thread.stop();
                                }));

                                var triplet = Thread.create(this._cont_iter)._triplet;
                                triplet.timeout = void 0;
                                while ( 1 ) {
                                    while ( triplet.timeout === void 0 ) {
                                        try {
                                            triplet = triplet.continuation.procedure.call(
                                                triplet.continuation.this_val, triplet.ret_val
                                            );
                                        } catch ( e ) {
                                            if ( e instanceof NoContinuationException ) {
                                                return this._got;
                                            } else if ( e instanceof NoExceptionHandlerException ) {
                                                throw e.thrown;
                                            } else {
                                                triplet.continuation = triplet.continuation.exception;
                                                triplet.ret_val      = e;
                                            }
                                        }
                                    }
                                    if ( is_called ) {
                                        break;
                                    } else {
                                        triplet.continuation = triplet.continuation.exception;
                                        triplet.ret_val      = new Error("can't suspend in non-converted context");
                                    }
                                }
                                this._cont_caller = null;
                                return this._got;
                            };


                            proto.hasNext.$Concurrent_Thread_compiled = eval(Thread.prepare(
                                function ( ) {
                                    this._mutex.acquire();
                                    try {
                                        if ( this._got        ) return true;
                                        if ( !this._cont_iter ) return false;
                                        try {
                                            this._cont_caller = currentContinuation();
                                            this._cont_iter();
                                        } catch ( e ) {
                                            this._cont_caller = null;
                                            if ( e instanceof ContinuationCalledException ) {
                                                return this._got;
                                            } else {
                                                throw e;
                                            }
                                        }
                                    } finally {
                                        this._mutex.release();
                                    }
                                    // execution never reaches here
                                }
                            )).$Concurrent_Thread_compiled;


                            proto.next = eval(Thread.prepare(
                                function ( ) {
                                    if ( this.hasNext() ) {
                                        var x = this._buf;
                                        this._buf = void 0;
                                        this._got = false;
                                        return x;
                                    } else {
                                        return void 0;
                                    }
                                }
                            ));

                            return {
                                Generator: Generator
                            };
                        }();
                    }
                }
            }
        }.call(null) ) {
            this.Concurrent.Thread.Generator = Generator;
        }
    }).call(null);
    (function(){
        if ( !this.Data || (typeof this.Data != 'object' && typeof this.Data != 'function') ) this.Data = new Object();
        if ( !this.Data.Error || (typeof this.Data.Error != 'object' && typeof this.Data.Error != 'function') ) this.Data.Error = new Object();
        if ( !this.Concurrent || (typeof this.Concurrent != 'object' && typeof this.Concurrent != 'function') ) this.Concurrent = new Object();
        if ( !this.Concurrent || (typeof this.Concurrent != 'object' && typeof this.Concurrent != 'function') ) this.Concurrent = new Object();
        if ( !this.Concurrent.Thread || (typeof this.Concurrent.Thread != 'object' && typeof this.Concurrent.Thread != 'function') ) this.Concurrent.Thread = new Object();
        if ( !this.Concurrent.Thread.JSON || (typeof this.Concurrent.Thread.JSON != 'object' && typeof this.Concurrent.Thread.JSON != 'function') ) this.Concurrent.Thread.JSON = new Object();
        if ( !this.Concurrent.Thread.JSON.RPC || (typeof this.Concurrent.Thread.JSON.RPC != 'object' && typeof this.Concurrent.Thread.JSON.RPC != 'function') ) this.Concurrent.Thread.JSON.RPC = new Object();
        if ( !this.JSON || (typeof this.JSON != 'object' && typeof this.JSON != 'function') ) this.JSON = new Object();
        if ( !this.Util || (typeof this.Util != 'object' && typeof this.Util != 'function') ) this.Util = new Object();
        if ( !this.Util.Arrayize || (typeof this.Util.Arrayize != 'object' && typeof this.Util.Arrayize != 'function') ) this.Util.Arrayize = new Object();
        if ( this.Concurrent.Thread.JSON.RPC.bind === undefined ) this.Concurrent.Thread.JSON.RPC.bind = undefined;
        if ( this.Concurrent.Thread.JSON.RPC.JSONRPCError === undefined ) this.Concurrent.Thread.JSON.RPC.JSONRPCError = undefined;
        with ( function(){
            with ( Data.Error ) {
                with ( Util.Arrayize ) {
                    with ( JSON ) {
                        with ( Concurrent ) {
                            with ( Concurrent.Thread.JSON.RPC ) {

                                return function () {
                                    var VERSION = '0.0.0';
                                    var NAMESPACE;



                                    NAMESPACE = 'Concurrent.Thread.JSON.RPC';

















                                    function bind ( opts ) {
                                        if ( !(opts instanceof Object) ) throw new TypeError("argument for " + NAMESPACE + ".bind must be a hash.");
                                        var request = opts.request;
                                        if ( request != null ) {
                                            if ( !String(request).match(/^(?:GET|POST)$/i) ) throw new Error('"request" option must be "GET" or "POST".');
                                        } else {
                                            request = "POST";
                                        }
                                        var params = opts.params;
                                        if ( params != null ) {
                                            if ( !String(params).match(/^(?:Named|Positioned)$/i) ) throw new Error('"params" option must be "Named" or "Positioned".');
                                        } else {
                                            params = "Named";
                                        }
                                        var body;
                                        if ( request.match(/^POST$/i) ) {
                                            if ( params.match(/^Named$/i) ) {
                                                body = makeNamedPost(opts.url, opts.method);
                                            } else {
                                                body = makePositionedPost(opts.url, opts.method);
                                            }
                                        } else {
                                            if ( params.match(/^Named$/i) ) {
                                                body = makeNamedGet(opts.url, opts.method);
                                            } else {
                                                body = makePositionedGet(opts.url, opts.method);
                                            }
                                        }
                                        var with_pre;
                                        var pre = opts.preprocess;
                                        if ( pre != null ) {
                                            if ( typeof pre != "function" ) throw new TypeError('"preprocess" option must be function');
                                            with_pre = eval(Thread.prepare(function(){
                                                return body.apply(this, pre.apply(this, arguments));
                                            }));
                                        } else {
                                            with_pre = body;
                                        }
                                        var post = opts.postprocess;
                                        if ( post != null ) {
                                            if ( typeof post != "function" ) throw new TypeError('"preprocess" option must be function');
                                            return eval(Thread.prepare(function(){
                                                return post(with_pre.apply(this, arguments));
                                            }));
                                        } else {
                                            return with_pre;
                                        }
                                    }


                                    var COMMON_HEADERS = [
                                        'User-Agent'  , 'Concurrent.Thread.JSON.RPC',
                                        'Accept'      , 'application/json'
                                    ];

                                    var POST_HEADERS = COMMON_HEADERS.concat(
                                        'Content-type', 'application/json'
                                    );

                                    function makeNamedPost( url, method ) {
                                        return eval(Thread.prepare(
                                            function ( /* variable arguments */ ) {
                                                var res = Thread.Http.post(url, dump({
                                                    version: "1.1",
                                                    method : method,
                                                    params : args2params(arguments)
                                                }), POST_HEADERS);
                                                res = eval("(" + res.responseText + ")");
                                                if ( res.error ) throw new JSONRPCError(res.error);
                                                return res.result;
                                            }
                                        ));
                                    };

                                    function makePositionedPost ( url, method ) {
                                        return eval(Thread.prepare(
                                            function ( /* variable arguments */ ) {
                                                var res = Thread.Http.post(url, dump({
                                                    version: "1.1",
                                                    method : method,
                                                    params : arrayize(arguments)
                                                }), POST_HEADERS);
                                                res = eval("(" + res.responseText + ")");
                                                if ( res.error ) throw new JSONRPCError(res.error);
                                                return res.result;
                                            }
                                        ));
                                    };

                                    function makeNamedGet ( url, method ) {
                                        url = url.replace(/\/+$/, "") + "/" + encodeURIComponent(method) + "?";
                                        return eval(Thread.prepare(
                                            function ( /* variable arguments */ ) {
                                                var res = Thread.Http.get(url + params2query(args2params(arguments)), COMMON_HEADERS);
                                                res = eval("(" + res.responseText + ")");
                                                if ( res.error ) throw new JSONRPCError(res.error);
                                                return res.result;
                                            }
                                        ));
                                    };

                                    function makePositionedGet ( url, method ) {
                                        url = url.replace(/\/+$/, "") + "/" + encodeURIComponent(method) + "?";
                                        return eval(Thread.prepare(
                                            function ( /* variable arguments */ ) {
                                                arguments[arguments.length] = {};
                                                arguments.length++;
                                                var res = Thread.Http.get(url + params2query(args2params(arguments)), COMMON_HEADERS);
                                                res = eval("(" + res.responseText + ")");
                                                if ( res.error ) throw new JSONRPCError(res.error);
                                                return res.result;
                                            }
                                        ));
                                    };

                                    function args2params ( args ) {
                                        var params = {};
                                        if ( args.length ) {
                                            var hash = args[args.length-1];
                                            if ( !(hash instanceof Object) ) throw new Error("the last argument must be a hash");
                                            for ( var i in hash ) {
                                                if ( hash.hasOwnProperty(i) ) params[i] = hash[i];
                                            }
                                            for ( var i=0;  i < args.length-1;  i++ ) {
                                                params[i] = args[i];
                                            }
                                        }
                                        return params;
                                    }

                                    function params2query ( params ) {
                                        var query = [];
                                        for ( var i in params ) {
                                            if ( !params.hasOwnProperty(i) ) continue;
                                            if ( params[i] instanceof Array ) {
                                                var arr = params[i];
                                                for ( var j=0;  j < arr.length;  j++ ) {
                                                    query.push(encodeURIComponent(i) + "=" + encodeURIComponent(arr[j]));
                                                }
                                            } else {
                                                query.push(encodeURIComponent(i) + "=" + encodeURIComponent(params[i]));
                                            }
                                        }
                                        return query.join("&");
                                    }



                                    var JSONRPCError = Error.extend(
                                        function ( $super, e ) {
                                            if ( e instanceof Object ) {
                                                $super(e.message);
                                                for ( var i in e ) this[i] = e[i];
                                            } else {
                                                $super(e);
                                            }
                                        },
                                        {name: NAMESPACE + ".JSONRPCError"}
                                    );

                                    return {
                                        JSONRPCError: JSONRPCError, bind: bind
                                    };
                                }();
                            }
                        }
                    }
                }
            }
        }.call(null) ) {
            this.Concurrent.Thread.JSON.RPC.JSONRPCError = JSONRPCError;
            this.Concurrent.Thread.JSON.RPC.bind = bind;
        }
    }).call(null);
    (function(){
        if ( !this.WebBrowser || (typeof this.WebBrowser != 'object' && typeof this.WebBrowser != 'function') ) this.WebBrowser = new Object();
        if ( !this.WebBrowser.GUI || (typeof this.WebBrowser.GUI != 'object' && typeof this.WebBrowser.GUI != 'function') ) this.WebBrowser.GUI = new Object();
        if ( !this.WebBrowser.GUI.Event || (typeof this.WebBrowser.GUI.Event != 'object' && typeof this.WebBrowser.GUI.Event != 'function') ) this.WebBrowser.GUI.Event = new Object();
        if ( !this.Concurrent || (typeof this.Concurrent != 'object' && typeof this.Concurrent != 'function') ) this.Concurrent = new Object();
        if ( !this.Concurrent || (typeof this.Concurrent != 'object' && typeof this.Concurrent != 'function') ) this.Concurrent = new Object();
        if ( !this.Concurrent.Thread || (typeof this.Concurrent.Thread != 'object' && typeof this.Concurrent.Thread != 'function') ) this.Concurrent.Thread = new Object();
        if ( !this.Concurrent.Thread.Event || (typeof this.Concurrent.Thread.Event != 'object' && typeof this.Concurrent.Thread.Event != 'function') ) this.Concurrent.Thread.Event = new Object();
        if ( !this.Util || (typeof this.Util != 'object' && typeof this.Util != 'function') ) this.Util = new Object();
        if ( !this.Util.Arrayize || (typeof this.Util.Arrayize != 'object' && typeof this.Util.Arrayize != 'function') ) this.Util.Arrayize = new Object();
        if ( this.Concurrent.Thread.Event.waitFor === undefined ) this.Concurrent.Thread.Event.waitFor = undefined;
        if ( this.Concurrent.Thread.Event.select === undefined ) this.Concurrent.Thread.Event.select = undefined;
        with ( function(){
            with ( Util.Arrayize ) {
                with ( WebBrowser.GUI.Event ) {
                    with ( Concurrent ) {
                        with ( Concurrent.Thread.Event ) {

                            return function () {
                                var VERSION = '0.0.0';
                                var NAMESPACE;



                                NAMESPACE = 'Concurrent.Thread.Event';
















                                var waitFor = eval(Concurrent.Thread.prepare(
                                    function waitFor ( target, type, options ) {
                                        var arg = {};
                                        for ( var i in options ) arg[i] = options[i];
                                        arg.target = target;
                                        arg.type   = type;
                                        return select(arg);
                                    }
                                ));



                                var select = eval(Concurrent.Thread.prepare(
                                    function select ( /* variable args */ ) {
                                        try {
                                            var signal = {};
                                            set_handlers(arrayize(arguments), signal);
                                            Concurrent.Thread.stop();
                                        } catch ( e ) {
                                            if ( e === signal ) {
                                                return signal.event;
                                            } else {
                                                throw e;
                                            }
                                        }
                                    }
                                ));


                                function set_handlers ( args, signal ) {
                                    var self = Concurrent.Thread.self();

                                    args = args.map(function( arg ){
                                        if ( !arg.target || typeof arg.target !== "object" ) {
                                            throw new TypeError("not a object: " + target);
                                        }
                                        return {
                                            target         : arg.target,
                                            type           : String(arg.type),
                                            useCapture     : Boolean(arg.useCapture),
                                            preventDefault : Boolean(arg.preventDefault),
                                            stopPropagation: Boolean(arg.stopPropagation)
                                        };
                                    });

                                    var lsn_ids = args.map(function( arg ){
                                        function handler ( e ) {
                                            if ( arg.preventDefault  ) e.preventDefault();
                                            if ( arg.stopPropagation ) e.stopPropagation();
                                            lsn_ids.forEach(function( id ){
                                                detach(id);
                                            });
                                            // IE invalidates event properties after leaving the event handler.
                                            // So, we pass a copy of the current event object (but DO NOT copy its methods).
                                            var evt = {};
                                            for ( var i in e ) {
                                                if ( typeof e[i] !== "function" ) evt[i] = e[i];
                                            }
                                            signal.event  = evt;
                                            self.notify(signal);
                                        }
                                        return attach(arg.target, arg.type, handler, arg.useCapture);
                                    });
                                }

                                return {
                                    waitFor: waitFor, select: select
                                };
                            }();
                        }
                    }
                }
            }
        }.call(null) ) {
            this.Concurrent.Thread.Event.waitFor = waitFor;
            this.Concurrent.Thread.Event.select = select;
        }
    }).call(null);

</script>

<div id="x-spreadsheet-demo"></div>
<script>
    function load() {
        let options = {
            // formula: {
            //     wland: () => {
            //         console.log("17wland")
            //
            //     }
            // },
            showFreeze: true,
            showEditor: true,
            rowWidth: {
                state: false,
                width: 180
            },
            view: {
                // height: () => 5000,
            },
            row: {
                len: 300,
                height: 25,
            },
            showGrid: true,
            showToolbar: true,
            minus: false,
            col: {
                len: 26,
                width: 100,
                indexWidth: 60,
                minWidth: 60,
            },
        };

        let rows1 = {
            1: {
                cells: {
                    0: { text: 'testingtesttestetst' },
                    2: { text: 'testing' },
                    3: { text: '1' },
                    4: { text: '1',  },
                },
            },
            2: {
                cells: {
                    0: { text: 'render', style: 0 },
                    1: { text: 'Hello' },
                    2: { text: 'haha',  },
                    3: { text: '1' },
                    4: { text: '=A2',  },
                }
            },
            8: {
                cells: {
                    8: { text: 'border test', style: 0 },
                }
            }
        };
        let flex = [
            {
                ri: 6,
                ci: 0,
                set_total: 3,
                state: false
            },
            // {
            //     ri: 7,
            //     ci: 0,
            //     set_total: 2,
            //     state: false
            // },
            // {
            //     ri: 12,
            //     ci: 0,
            //     set_total: 2,
            //     state: false
            // }
        ]

        let spaces = ['          ', '                    '];     // 1020

        var xs = x.spreadsheet('#x-spreadsheet-demo', options, {})
            .loadData({
                styles: [
                    {
                        bgcolor: 'rgb(146, 208, 80)',
                        textwrap: true,
                        color: '#900b09',
                        font: {name: "Arial", size: 10, bold: true, italic: false},
                        border: {
                            top: ['thin', '#0366d6'],
                            bottom: ['thin', '#0366d6'],
                            right: ['thin', '#0366d6'],
                            left: ['thin', '#0366d6'],
                        },
                    },
                    {
                        font: {name: "Arial", size: 10, bold: true, italic: false},
                        bgcolor: '#5CACEE',
                        align: "center"
                    },
                    {
                        bgcolor: '#EBF3FD',
                        border: {
                            top: ['thin', '#fff'],
                            bottom: ['thin', '#fff'],
                            right: ['thin', '#fff'],
                            left: ['thin', '#fff'],
                        },
                    },
                    {
                        align: "center",
                        bgcolor: '#F2F2F2',
                        border: {
                            top: ['thin', '#fff'],
                            bottom: ['thin', '#fff'],
                            right: ['thin', '#fff'],
                            left: ['thin', '#fff'],
                        },
                    },
                    {
                        bgcolor: '#fff',
                        // color: 'blue',
                        border: {
                            top: ['thin', '#fff'],
                            bottom: ['thin', '#fff'],
                            right: ['thin', '#fff'],
                            left: ['thin', '#fff'],
                        },
                    },
                    {
                        bgcolor: '#fff',
                        align: "right",
                        color: 'blue',
                        border: {
                            top: ['thin', '#fff'],
                            bottom: ['thin', '#fff'],
                            right: ['thin', '#fff'],
                            left: ['thin', '#fff'],
                        },
                    },
                    {
                        bgcolor: '#F2F2F2',
                        align: "right",
                        color: 'blue',
                        border: {
                            top: ['thin', '#fff'],
                            bottom: ['thin', '#fff'],
                            right: ['thin', '#fff'],
                            left: ['thin', '#fff'],
                        },
                    }
                ],
                // autofilter: {
                //     filters: [],
                //     ref: "A1:D3",
                //     sort: null
                // },
                flex: [],
                refRow: [{
                    calc: rows1,
                    data: rows1,
                }],
                rows: rows1,
                pictures: [
                    {
                        ci: 3,
                        left: 310,
                        nextLeft: 325,
                        nextTop: 325,
                        offsetLeft: 0,
                        offsetTop: 0,
                        range: {sri: 41, sci: 3, eri: 41, eci: 3, w: 0, h: 0},
                        ri: 41,
                        src: "data:image/png;base64,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",
                        top: 535,
                    }
                ]
            }).change((cdata) => {
                console.log(cdata);
                console.log(xs.validate());
            });
    }
</script>
<!--script type="text/javascript" src="https://unpkg.com/x-data-spreadsheet@1.0.20/dist/locale/zh-cn.js"></script-->
</body>
</html>
